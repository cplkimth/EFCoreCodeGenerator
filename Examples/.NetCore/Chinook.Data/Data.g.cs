
/*
This file has been generated by UsingEntityFrameworkCore on 2022-12-29 오후 8:18:23.
You may not need to modify this file.
*/

#region
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
#endregion

namespace Chinook.Data;

#region Entities

#region IEntity
public partial interface IEntity
{
}
#endregion

#region Untyped Entity
/// <summary>
///   모든 엔터티 클래스의 부모 클래스
/// </summary>
public abstract partial class UntypedEntity : IEntity
{
	/// <summary>
	///   부가정보를 저장하기 위한 object 객체
	/// </summary>
	[NotMapped]
	public object EntityTag { get; set; }

	/// <summary>
	///   모든 속성의 값을 초기화한다.string형 속성은 string.Empty 값으로 채우고, DateTime형 속성은 DateTime.Today 값으로 채운다.
	/// </summary>
	/// <returns> 생성된 엔터티 </returns>
	public void Clear()
	{
		Clear(string.Empty, DateTime.Today);
	}

	/// <summary>
	///   모든 속성의 값을 초기화한다. string형 속성은 string.Empty 값으로 채우고, DateTime형 속성은 기본 DateTime 값으로 채운다.
	/// </summary>
	/// <param name="defaultDateTime"> 기본 DateTime 값 </param>
	/// <returns> 생성된 엔터티 </returns>
	public void Clear(DateTime defaultDateTime)
	{
		Clear(string.Empty, defaultDateTime);
	}

	/// <summary>
	///   모든 속성의 값을 초기화한다. string형 속성은 기본 string 값으로 채우고, DateTime형 속성은 기본 DateTime 값으로 채운다.
	/// </summary>
	/// <param name="defaultString"> 기본 string 값 </param>
	/// <param name="defaultDateTime"> 기본 DateTime 값 </param>
	/// <returns> 생성된 엔터티 </returns>
	public void Clear(string defaultString, DateTime defaultDateTime)
	{
		Type type = GetType();
		PropertyInfo[] propertyInfoArray = type.GetProperties(BindingFlags.Instance | BindingFlags.Public);

		foreach (PropertyInfo propertyInfo in propertyInfoArray)
		{
			if (propertyInfo.CanWrite == false)
				continue;

			if (propertyInfo.PropertyType == typeof (string))
				propertyInfo.SetValue(this, defaultString, null);

			else if (propertyInfo.PropertyType == typeof (DateTime))
				propertyInfo.SetValue(this, defaultDateTime, null);
		}
	}

	/// <summary>
	///   기본키 값들을 구분자(":")로 연결하여 반환한다.
	/// </summary>
	/// <returns> </returns>
	public abstract string PrimaryKeyValues {get;}

	/// <summary>
	/// 엔터티를 대표하는 문자열을 구한다.
	/// </summary>
	public abstract string EntityText { get; }

	/// <summary>
	///   엔터티의 이름을 구한다.
	/// </summary>
	public abstract string GetEntityTypeName();

	partial void IsLogWritable(ref bool? logWritable);

	public virtual bool LogWritable
	{
		get
		{
		bool? logWritable = null;
		IsLogWritable(ref logWritable);

		if (logWritable.HasValue)
			return logWritable.Value;

		return false;
		}
	}

	/// <summary>
	///   EntityLog에 찍힐 문자열을 구한다. Code로 끝나는 코드 프로퍼티의 경우 대응하는 문자열 프로퍼티의 값도 추가한다.
	///   주의) EntityLog 테이블의 설계 상 최대 2000자 까지만 저장할 수 있음.
	/// </summary>
	/// <returns> </returns>
	public virtual string ToEntityLog()
	{
		const int MaxLength = 2000; // 최대 2000자 까지만 저장.

		Type type = GetType();

		var propertyInfoes = type.GetProperties();

		StringBuilder builder = new StringBuilder(ToString());

		builder.AppendLine();
		foreach (var propertyInfo in propertyInfoes)
		{
			if (propertyInfo.PropertyType != typeof (int))
				continue;

			if (propertyInfo.Name.EndsWith("Code") == false)
				continue;

			string textPropertyName = propertyInfo.Name.Substring(0, propertyInfo.Name.Length - 4) + "Text";
			string textValue = GetTextFromCodeProperty(this, type, textPropertyName);

			if (textValue != null)
				builder.AppendFormat("[{0}] {1}{2}", textPropertyName, textValue, Environment.NewLine);
		}

		if (builder.Length > MaxLength)
			return builder.ToString(0, MaxLength);
		else
			return builder.ToString();
	}

	private static string GetTextFromCodeProperty(object entity, Type objectType, string textPropertyName)
	{
		var propertyInfo = objectType.GetProperty(textPropertyName);
		object propertyValue = propertyInfo.GetValue(entity, null);

		if (propertyValue is string)
			return (string) propertyValue;
		else
			return null;
	}
}
#endregion

#region Entity<T>
/// <summary>
/// 모든 엔터티 클래스의 형이 지정된 부모 클래스
/// </summary>
/// <typeparam name="T">엔터티 클래스의 형식</typeparam>
public abstract partial class Entity<T> : UntypedEntity, IEditableObject where T : class, new()
{
	/// <summary>
	/// 객체를 복사한다.
	/// </summary>
	/// <returns></returns>
	public abstract T Clone();

	#region Implementation of IEditableObject

	protected T _clone = null;

	/// <summary>
	/// IEditableObject.BeginEdit 구현
	/// </summary>
	public void BeginEdit()
	{
		if (_clone == null)
			_clone = Clone();
	}

	/// <summary>
	/// IEditableObject.EndEdit 구현
	/// </summary>
	public void EndEdit()
	{
		_clone = null;
	}

	public abstract void CancelEdit();

	#endregion

	/// <summary>
	/// 객체에 감사정보를 기입한다. 보통 ModifiedAt, ModifiedBy 등의 속성을 기록함.
	/// </summary>
    public partial void WriteAuditInfo();
}

#endregion

#region Album
/// <summary>
/// Album 엔터티
/// </summary>
public partial class Album : Entity<Album>, IEntity
{
	public const string EntityTypeName = "Album";

	public static void Copy(Album source, Album target)
	{
				target.AlbumId = source.AlbumId;		
		target.ArtistId = source.ArtistId;		
		target.Title = source.Title;
	}

	/// <summary>
	/// Album 객체를 복사한다.
	/// </summary>
	/// <returns></returns>
	public override Album Clone()
	{
		var clone = new Album();

		Copy(this, clone);

		return clone;
	}

	partial void GetEntityTextCore(ref string value);

	/// <summary>
	/// Album 객체를 대표하는 이름을 구한다.
	/// </summary>
	/// <returns></returns>
	public override string EntityText
	{
		get 
		{ 
			string value = null;
			GetEntityTextCore(ref value);

			if (value != null)
				return value;

			return PrimaryKeyValues; 
		}
	}

	partial void ToStringCore(ref string value);

	public override string ToString()
	{
		string value = null;
		ToStringCore(ref value);

		if (value != null)
			return value;

		return "[AlbumId]" + AlbumId + ", " + "[ArtistId]" + ArtistId + ", " + "[Title]" + Title;
	}

	/// <summary>
	/// IEditableObject.CancelEdit 구현
	/// </summary>
	public override void CancelEdit()
	{
		if (_clone != null)
			Copy(_clone, this);
	}

	public override string PrimaryKeyValues
	{
		get { return string.Join(":", AlbumId); }
	}

	public override string GetEntityTypeName()
	{
		return EntityTypeName;
	}
}

/// <summary>
/// Album 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
/// </summary>
public enum AlbumColumn
{
		AlbumId,
	ArtistId,
	Title
}


/// <summary>
/// Album 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer<Album> 구현)
/// </summary>
public class AlbumEqualityComparer : IEqualityComparer<Album>
{
	public bool Equals(Album x, Album y)
	{
		return x.AlbumId == y.AlbumId;
	}

	public int GetHashCode(Album obj)
	{
		return obj.AlbumId.GetHashCode();
	}
}

#endregion
#region Artist
/// <summary>
/// Artist 엔터티
/// </summary>
public partial class Artist : Entity<Artist>, IEntity
{
	public const string EntityTypeName = "Artist";

	public static void Copy(Artist source, Artist target)
	{
				target.ArtistId = source.ArtistId;		
		target.CompanyId = source.CompanyId;		
		target.Name = source.Name;
	}

	/// <summary>
	/// Artist 객체를 복사한다.
	/// </summary>
	/// <returns></returns>
	public override Artist Clone()
	{
		var clone = new Artist();

		Copy(this, clone);

		return clone;
	}

	partial void GetEntityTextCore(ref string value);

	/// <summary>
	/// Artist 객체를 대표하는 이름을 구한다.
	/// </summary>
	/// <returns></returns>
	public override string EntityText
	{
		get 
		{ 
			string value = null;
			GetEntityTextCore(ref value);

			if (value != null)
				return value;

			return PrimaryKeyValues; 
		}
	}

	partial void ToStringCore(ref string value);

	public override string ToString()
	{
		string value = null;
		ToStringCore(ref value);

		if (value != null)
			return value;

		return "[ArtistId]" + ArtistId + ", " + "[CompanyId]" + CompanyId + ", " + "[Name]" + Name;
	}

	/// <summary>
	/// IEditableObject.CancelEdit 구현
	/// </summary>
	public override void CancelEdit()
	{
		if (_clone != null)
			Copy(_clone, this);
	}

	public override string PrimaryKeyValues
	{
		get { return string.Join(":", ArtistId); }
	}

	public override string GetEntityTypeName()
	{
		return EntityTypeName;
	}
}

/// <summary>
/// Artist 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
/// </summary>
public enum ArtistColumn
{
		ArtistId,
	CompanyId,
	Name
}


/// <summary>
/// Artist 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer<Artist> 구현)
/// </summary>
public class ArtistEqualityComparer : IEqualityComparer<Artist>
{
	public bool Equals(Artist x, Artist y)
	{
		return x.ArtistId == y.ArtistId;
	}

	public int GetHashCode(Artist obj)
	{
		return obj.ArtistId.GetHashCode();
	}
}

#endregion
#region Company
/// <summary>
/// Company 엔터티
/// </summary>
public partial class Company : Entity<Company>, IEntity
{
	public const string EntityTypeName = "Company";

	public static void Copy(Company source, Company target)
	{
				target.CompanyId = source.CompanyId;		
		target.Name = source.Name;
	}

	/// <summary>
	/// Company 객체를 복사한다.
	/// </summary>
	/// <returns></returns>
	public override Company Clone()
	{
		var clone = new Company();

		Copy(this, clone);

		return clone;
	}

	partial void GetEntityTextCore(ref string value);

	/// <summary>
	/// Company 객체를 대표하는 이름을 구한다.
	/// </summary>
	/// <returns></returns>
	public override string EntityText
	{
		get 
		{ 
			string value = null;
			GetEntityTextCore(ref value);

			if (value != null)
				return value;

			return PrimaryKeyValues; 
		}
	}

	partial void ToStringCore(ref string value);

	public override string ToString()
	{
		string value = null;
		ToStringCore(ref value);

		if (value != null)
			return value;

		return "[CompanyId]" + CompanyId + ", " + "[Name]" + Name;
	}

	/// <summary>
	/// IEditableObject.CancelEdit 구현
	/// </summary>
	public override void CancelEdit()
	{
		if (_clone != null)
			Copy(_clone, this);
	}

	public override string PrimaryKeyValues
	{
		get { return string.Join(":", CompanyId); }
	}

	public override string GetEntityTypeName()
	{
		return EntityTypeName;
	}
}

/// <summary>
/// Company 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
/// </summary>
public enum CompanyColumn
{
		CompanyId,
	Name
}


/// <summary>
/// Company 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer<Company> 구현)
/// </summary>
public class CompanyEqualityComparer : IEqualityComparer<Company>
{
	public bool Equals(Company x, Company y)
	{
		return x.CompanyId == y.CompanyId;
	}

	public int GetHashCode(Company obj)
	{
		return obj.CompanyId.GetHashCode();
	}
}

#endregion
#region Playlist
/// <summary>
/// Playlist 엔터티
/// </summary>
public partial class Playlist : Entity<Playlist>, IEntity
{
	public const string EntityTypeName = "Playlist";

	public static void Copy(Playlist source, Playlist target)
	{
				target.PlaylistId = source.PlaylistId;		
		target.Name = source.Name;
	}

	/// <summary>
	/// Playlist 객체를 복사한다.
	/// </summary>
	/// <returns></returns>
	public override Playlist Clone()
	{
		var clone = new Playlist();

		Copy(this, clone);

		return clone;
	}

	partial void GetEntityTextCore(ref string value);

	/// <summary>
	/// Playlist 객체를 대표하는 이름을 구한다.
	/// </summary>
	/// <returns></returns>
	public override string EntityText
	{
		get 
		{ 
			string value = null;
			GetEntityTextCore(ref value);

			if (value != null)
				return value;

			return PrimaryKeyValues; 
		}
	}

	partial void ToStringCore(ref string value);

	public override string ToString()
	{
		string value = null;
		ToStringCore(ref value);

		if (value != null)
			return value;

		return "[PlaylistId]" + PlaylistId + ", " + "[Name]" + Name;
	}

	/// <summary>
	/// IEditableObject.CancelEdit 구현
	/// </summary>
	public override void CancelEdit()
	{
		if (_clone != null)
			Copy(_clone, this);
	}

	public override string PrimaryKeyValues
	{
		get { return string.Join(":", PlaylistId); }
	}

	public override string GetEntityTypeName()
	{
		return EntityTypeName;
	}
}

/// <summary>
/// Playlist 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
/// </summary>
public enum PlaylistColumn
{
		PlaylistId,
	Name
}


/// <summary>
/// Playlist 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer<Playlist> 구현)
/// </summary>
public class PlaylistEqualityComparer : IEqualityComparer<Playlist>
{
	public bool Equals(Playlist x, Playlist y)
	{
		return x.PlaylistId == y.PlaylistId;
	}

	public int GetHashCode(Playlist obj)
	{
		return obj.PlaylistId.GetHashCode();
	}
}

#endregion
#region PlaylistTrack
/// <summary>
/// PlaylistTrack 엔터티
/// </summary>
public partial class PlaylistTrack : Entity<PlaylistTrack>, IEntity
{
	public const string EntityTypeName = "PlaylistTrack";

	public static void Copy(PlaylistTrack source, PlaylistTrack target)
	{
				target.PlaylistId = source.PlaylistId;		
		target.TrackId = source.TrackId;		
		target.Dummy = source.Dummy;
	}

	/// <summary>
	/// PlaylistTrack 객체를 복사한다.
	/// </summary>
	/// <returns></returns>
	public override PlaylistTrack Clone()
	{
		var clone = new PlaylistTrack();

		Copy(this, clone);

		return clone;
	}

	partial void GetEntityTextCore(ref string value);

	/// <summary>
	/// PlaylistTrack 객체를 대표하는 이름을 구한다.
	/// </summary>
	/// <returns></returns>
	public override string EntityText
	{
		get 
		{ 
			string value = null;
			GetEntityTextCore(ref value);

			if (value != null)
				return value;

			return PrimaryKeyValues; 
		}
	}

	partial void ToStringCore(ref string value);

	public override string ToString()
	{
		string value = null;
		ToStringCore(ref value);

		if (value != null)
			return value;

		return "[PlaylistId]" + PlaylistId + ", " + "[TrackId]" + TrackId + ", " + "[Dummy]" + Dummy;
	}

	/// <summary>
	/// IEditableObject.CancelEdit 구현
	/// </summary>
	public override void CancelEdit()
	{
		if (_clone != null)
			Copy(_clone, this);
	}

	public override string PrimaryKeyValues
	{
		get { return string.Join(":", PlaylistId, TrackId); }
	}

	public override string GetEntityTypeName()
	{
		return EntityTypeName;
	}
}

/// <summary>
/// PlaylistTrack 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
/// </summary>
public enum PlaylistTrackColumn
{
		PlaylistId,
	TrackId,
	Dummy
}


/// <summary>
/// PlaylistTrack 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer<PlaylistTrack> 구현)
/// </summary>
public class PlaylistTrackEqualityComparer : IEqualityComparer<PlaylistTrack>
{
	public bool Equals(PlaylistTrack x, PlaylistTrack y)
	{
		return x.PlaylistId == y.PlaylistId && x.TrackId == y.TrackId;
	}

	public int GetHashCode(PlaylistTrack obj)
	{
		return obj.PlaylistId.GetHashCode() ^ obj.TrackId.GetHashCode();
	}
}

#endregion
#region PlaylistTrackHistory
/// <summary>
/// PlaylistTrackHistory 엔터티
/// </summary>
public partial class PlaylistTrackHistory : Entity<PlaylistTrackHistory>, IEntity
{
	public const string EntityTypeName = "PlaylistTrackHistory";

	public static void Copy(PlaylistTrackHistory source, PlaylistTrackHistory target)
	{
				target.PlaylistId = source.PlaylistId;		
		target.TrackId = source.TrackId;		
		target.WrittenAt = source.WrittenAt;
	}

	/// <summary>
	/// PlaylistTrackHistory 객체를 복사한다.
	/// </summary>
	/// <returns></returns>
	public override PlaylistTrackHistory Clone()
	{
		var clone = new PlaylistTrackHistory();

		Copy(this, clone);

		return clone;
	}

	partial void GetEntityTextCore(ref string value);

	/// <summary>
	/// PlaylistTrackHistory 객체를 대표하는 이름을 구한다.
	/// </summary>
	/// <returns></returns>
	public override string EntityText
	{
		get 
		{ 
			string value = null;
			GetEntityTextCore(ref value);

			if (value != null)
				return value;

			return PrimaryKeyValues; 
		}
	}

	partial void ToStringCore(ref string value);

	public override string ToString()
	{
		string value = null;
		ToStringCore(ref value);

		if (value != null)
			return value;

		return "[PlaylistId]" + PlaylistId + ", " + "[TrackId]" + TrackId + ", " + "[WrittenAt]" + WrittenAt;
	}

	/// <summary>
	/// IEditableObject.CancelEdit 구현
	/// </summary>
	public override void CancelEdit()
	{
		if (_clone != null)
			Copy(_clone, this);
	}

	public override string PrimaryKeyValues
	{
		get { return string.Join(":", PlaylistId, TrackId, WrittenAt); }
	}

	public override string GetEntityTypeName()
	{
		return EntityTypeName;
	}
}

/// <summary>
/// PlaylistTrackHistory 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
/// </summary>
public enum PlaylistTrackHistoryColumn
{
		PlaylistId,
	TrackId,
	WrittenAt
}


/// <summary>
/// PlaylistTrackHistory 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer<PlaylistTrackHistory> 구현)
/// </summary>
public class PlaylistTrackHistoryEqualityComparer : IEqualityComparer<PlaylistTrackHistory>
{
	public bool Equals(PlaylistTrackHistory x, PlaylistTrackHistory y)
	{
		return x.PlaylistId == y.PlaylistId && x.TrackId == y.TrackId && x.WrittenAt == y.WrittenAt;
	}

	public int GetHashCode(PlaylistTrackHistory obj)
	{
		return obj.PlaylistId.GetHashCode() ^ obj.TrackId.GetHashCode() ^ obj.WrittenAt.GetHashCode();
	}
}

#endregion
#region Track
/// <summary>
/// Track 엔터티
/// </summary>
public partial class Track : Entity<Track>, IEntity
{
	public const string EntityTypeName = "Track";

	public static void Copy(Track source, Track target)
	{
				target.TrackId = source.TrackId;		
		target.AlbumId = source.AlbumId;		
		target.BigIntCol = source.BigIntCol;		
		target.BigIntColNull = source.BigIntColNull;		
		target.BinaryCol = source.BinaryCol;		
		target.BinaryColNull = source.BinaryColNull;		
		target.BitCol = source.BitCol;		
		target.BitColNull = source.BitColNull;		
		target.CharCol = source.CharCol;		
		target.CharColNull = source.CharColNull;		
		target.DateCol = source.DateCol;		
		target.DateColNull = source.DateColNull;		
		target.DateTimeCol = source.DateTimeCol;		
		target.DateTimeColNull = source.DateTimeColNull;		
		target.DecimalCol = source.DecimalCol;		
		target.DecimalColNull = source.DecimalColNull;		
		target.FloatCol = source.FloatCol;		
		target.FloatColNull = source.FloatColNull;		
		target.GuidCol = source.GuidCol;		
		target.GuidColNull = source.GuidColNull;		
		target.Name = source.Name;		
		target.NcharCol = source.NcharCol;		
		target.NcharColNull = source.NcharColNull;		
		target.NvarCharCol = source.NvarCharCol;		
		target.NvarCharColNull = source.NvarCharColNull;		
		target.RealCol = source.RealCol;		
		target.RealColNull = source.RealColNull;		
		target.SmallDateTimeCol = source.SmallDateTimeCol;		
		target.SmallDateTimeColNull = source.SmallDateTimeColNull;		
		target.SmallIntCol = source.SmallIntCol;		
		target.SmallIntColNull = source.SmallIntColNull;		
		target.SmallMoneyCol = source.SmallMoneyCol;		
		target.SmallMoneyColNull = source.SmallMoneyColNull;		
		target.TimeCol = source.TimeCol;		
		target.TimeColNull = source.TimeColNull;		
		target.TimeStampCol = source.TimeStampCol;		
		target.TinyIntCol = source.TinyIntCol;		
		target.TinyIntColNull = source.TinyIntColNull;		
		target.VarBinaryCol = source.VarBinaryCol;		
		target.VarBinaryColNull = source.VarBinaryColNull;		
		target.VarCharCol = source.VarCharCol;		
		target.VarCharColNull = source.VarCharColNull;
	}

	/// <summary>
	/// Track 객체를 복사한다.
	/// </summary>
	/// <returns></returns>
	public override Track Clone()
	{
		var clone = new Track();

		Copy(this, clone);

		return clone;
	}

	partial void GetEntityTextCore(ref string value);

	/// <summary>
	/// Track 객체를 대표하는 이름을 구한다.
	/// </summary>
	/// <returns></returns>
	public override string EntityText
	{
		get 
		{ 
			string value = null;
			GetEntityTextCore(ref value);

			if (value != null)
				return value;

			return PrimaryKeyValues; 
		}
	}

	partial void ToStringCore(ref string value);

	public override string ToString()
	{
		string value = null;
		ToStringCore(ref value);

		if (value != null)
			return value;

		return "[TrackId]" + TrackId + ", " + "[AlbumId]" + AlbumId + ", " + "[BigIntCol]" + BigIntCol + ", " + "[BigIntColNull]" + BigIntColNull + ", " + "[BinaryCol]" + BinaryCol + ", " + "[BinaryColNull]" + BinaryColNull + ", " + "[BitCol]" + BitCol + ", " + "[BitColNull]" + BitColNull + ", " + "[CharCol]" + CharCol + ", " + "[CharColNull]" + CharColNull + ", " + "[DateCol]" + DateCol + ", " + "[DateColNull]" + DateColNull + ", " + "[DateTimeCol]" + DateTimeCol + ", " + "[DateTimeColNull]" + DateTimeColNull + ", " + "[DecimalCol]" + DecimalCol + ", " + "[DecimalColNull]" + DecimalColNull + ", " + "[FloatCol]" + FloatCol + ", " + "[FloatColNull]" + FloatColNull + ", " + "[GuidCol]" + GuidCol + ", " + "[GuidColNull]" + GuidColNull + ", " + "[Name]" + Name + ", " + "[NcharCol]" + NcharCol + ", " + "[NcharColNull]" + NcharColNull + ", " + "[NvarCharCol]" + NvarCharCol + ", " + "[NvarCharColNull]" + NvarCharColNull + ", " + "[RealCol]" + RealCol + ", " + "[RealColNull]" + RealColNull + ", " + "[SmallDateTimeCol]" + SmallDateTimeCol + ", " + "[SmallDateTimeColNull]" + SmallDateTimeColNull + ", " + "[SmallIntCol]" + SmallIntCol + ", " + "[SmallIntColNull]" + SmallIntColNull + ", " + "[SmallMoneyCol]" + SmallMoneyCol + ", " + "[SmallMoneyColNull]" + SmallMoneyColNull + ", " + "[TimeCol]" + TimeCol + ", " + "[TimeColNull]" + TimeColNull + ", " + "[TimeStampCol]" + TimeStampCol + ", " + "[TinyIntCol]" + TinyIntCol + ", " + "[TinyIntColNull]" + TinyIntColNull + ", " + "[VarBinaryCol]" + VarBinaryCol + ", " + "[VarBinaryColNull]" + VarBinaryColNull + ", " + "[VarCharCol]" + VarCharCol + ", " + "[VarCharColNull]" + VarCharColNull;
	}

	/// <summary>
	/// IEditableObject.CancelEdit 구현
	/// </summary>
	public override void CancelEdit()
	{
		if (_clone != null)
			Copy(_clone, this);
	}

	public override string PrimaryKeyValues
	{
		get { return string.Join(":", TrackId); }
	}

	public override string GetEntityTypeName()
	{
		return EntityTypeName;
	}
}

/// <summary>
/// Track 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
/// </summary>
public enum TrackColumn
{
		TrackId,
	AlbumId,
	BigIntCol,
	BigIntColNull,
	BinaryCol,
	BinaryColNull,
	BitCol,
	BitColNull,
	CharCol,
	CharColNull,
	DateCol,
	DateColNull,
	DateTimeCol,
	DateTimeColNull,
	DecimalCol,
	DecimalColNull,
	FloatCol,
	FloatColNull,
	GuidCol,
	GuidColNull,
	Name,
	NcharCol,
	NcharColNull,
	NvarCharCol,
	NvarCharColNull,
	RealCol,
	RealColNull,
	SmallDateTimeCol,
	SmallDateTimeColNull,
	SmallIntCol,
	SmallIntColNull,
	SmallMoneyCol,
	SmallMoneyColNull,
	TimeCol,
	TimeColNull,
	TimeStampCol,
	TinyIntCol,
	TinyIntColNull,
	VarBinaryCol,
	VarBinaryColNull,
	VarCharCol,
	VarCharColNull
}


/// <summary>
/// Track 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer<Track> 구현)
/// </summary>
public class TrackEqualityComparer : IEqualityComparer<Track>
{
	public bool Equals(Track x, Track y)
	{
		return x.TrackId == y.TrackId;
	}

	public int GetHashCode(Track obj)
	{
		return obj.TrackId.GetHashCode();
	}
}

#endregion

#endregion

#region PropertyChangedEventArgs
/// <summary>
/// 속성 값이 변경된 후 발생하는 이벤트의 매개변수 클래스
/// </summary>
/// <typeparam name="T"></typeparam>
internal class PropertyChangedEventArgs<T> : EventArgs where T : Entity<T>, new()
{
	/// <summary>
	/// 속성 값이 변경된 엔티티
	/// </summary>
	public T Entity { get; set; }

	public PropertyChangedEventArgs(T entity)
	{
		Entity = entity;
	}
}

/// <summary>
/// 속성 값이 변경되기 전 발생하는 이벤트의 매개변수 클래스
/// </summary>
/// <typeparam name="T"></typeparam>
/// <typeparam name="K"></typeparam>
internal class PropertyChangingEventArgs<T, K> : EventArgs where T : Entity<T>, new()
{
	/// <summary>
	/// 속성 값이 변경될 엔티티
	/// </summary>
	public T Entity { get; set; }

	/// <summary>
	/// 새로 변경 될 속성 값
	/// </summary>
	public K Value { get; set; }

	public PropertyChangingEventArgs(T entity, K value)
	{
		Entity = entity;
		Value = value;
	}
}
#endregion

#region Data
#region EntityDao<T>
[Data]
public abstract partial class EntityDao<T> where T : Entity<T>, new()
{
	internal EntityDao() { }

	#region Create
	/// <summary>
	/// 엔터티를 생성한다. string형 속성은 string.Empty 값으로 채우고, DateTime형 속성은 DateTime.Today 값으로 채운다.
	/// </summary>
	/// <returns>생성된 엔터티</returns>
	public virtual T Create()
	{
		return Create(string.Empty, DateTime.Today);
	}

	/// <summary>
	/// 엔터티를 생성한다. string형 속성은 string.Empty 값으로 채우고, DateTime형 속성은 기본 DateTime 값으로 채운다.
	/// </summary>
	/// <param name="defaultDateTime">기본 DateTime 값</param>
	/// <returns>생성된 엔터티</returns>
	public virtual T Create(DateTime defaultDateTime)
	{
		return Create(string.Empty, defaultDateTime);
	}

	/// <summary>
	/// 엔터티를 생성한다. string형 속성은 기본 string 값으로 채우고, DateTime형 속성은 기본 DateTime 값으로 채운다.
	/// </summary>
	/// <param name="defaultString">기본 string 값</param>
	/// <param name="defaultDateTime">기본 DateTime 값</param>
	/// <returns>생성된 엔터티</returns>
	public virtual T Create(string defaultString, DateTime defaultDateTime)
	{
		T entity = new T();
		entity.Clear(defaultString, defaultDateTime);

		return entity;
	}
	#endregion

	#region Get
	/// <summary>
	/// 모든 엔터티를 반환한다.
	/// </summary>
	/// <returns>엔터티의 리스트</returns>
    public virtual List<T> Get()
	{
		return Get<T>(null, null, false, 0, int.MaxValue);
	}

    public virtual Task<List<T>> GetAsync() 
        => Task.Run(() => Get());

    /// <summary>
    /// 조건식에 맞는 엔터티들을 반환한다.
    /// </summary>
    /// <param name="where">조건식</param>
    /// <returns>엔터티의 리스트</returns>
    public virtual List<T> Get(Expression<Func<T, bool>> where)
	{
		return Get<T>(where, null, false, 0, int.MaxValue);
	}

    public virtual Task<List<T>> GetAsync(Expression<Func<T, bool>> where)
        => Task.Run(() => Get(where));

	/// <summary>
	/// 모든 엔터티들을 정렬식에 따라 정렬한 후 반환한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
	/// </summary>
	/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
	/// <param name="orderBy">정렬식</param>
	/// <param name="ascending">true이면 오름차순, false이면 내림차순</param>
	/// <returns>엔터티의 리스트</returns>
    public virtual List<T> Get<U>(Expression<Func<T, U>> orderBy, bool ascending)
	{
		return Get(null, orderBy, ascending, 0, int.MaxValue);
	}

    public virtual Task<List<T>> GetAsync<U>(Expression<Func<T, U>> orderBy, bool ascending)
        => Task.Run(() => Get(orderBy, ascending));

	/// <summary>
	/// 조건식에 맞는 엔터티들을 정렬식에 따라 정렬한 후 반환한다. 페이징을 지원한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
	/// </summary>
	/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
	/// <param name="orderBy">정렬식</param>
	/// <param name="ascending">true이면 오름차순, false이면 내림차순</param>
	/// <param name="startRowIndex">반환할 엔터티의 시작 인덱스</param>
	/// <param name="maximumRows">반환할 엔터티의 갯수</param>
	/// <returns>엔터티의 리스트</returns>
    public virtual List<T> Get<U>(Expression<Func<T, U>> orderBy, bool ascending, int startRowIndex, int maximumRows)
	{
		return Get(null, orderBy, ascending, startRowIndex, maximumRows);
	}

    public virtual Task<List<T>> GetAsync<U>(Expression<Func<T, U>> orderBy, bool ascending, int startRowIndex, int maximumRows)
        => Task.Run(() => Get(orderBy, ascending, startRowIndex, maximumRows));

	/// <summary>
	/// 조건식에 맞는 엔터티들을 정렬식에 따라 정렬한 후 반환한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
	/// </summary>
	/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
	/// <param name="where">조건식</param>
	/// <param name="orderBy">정렬식</param>
	/// <param name="ascending">true이면 오름차순, false이면 내림차순</param>
	/// <returns>엔터티의 리스트</returns>
    public virtual List<T> Get<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending)
	{
		return Get(where, orderBy, ascending, 0, int.MaxValue);
	}

    public virtual Task<List<T>> GetAsync<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending)
        => Task.Run(() => Get(where, orderBy, ascending));

	/// <summary>
	/// 조건식에 맞는 엔터티들을 정렬식에 따라 정렬한 후 반환한다. 페이징을 지원한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
	/// </summary>
	/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
	/// <param name="where">조건식</param>
	/// <param name="orderBy">정렬식</param>
	/// <param name="ascending">true이면 오름차순, false이면 내림차순</param>
	/// <param name="startRowIndex">반환할 엔터티의 시작 인덱스</param>
	/// <param name="maximumRows">반환할 엔터티의 갯수</param>
	/// <returns>엔터티의 리스트</returns>
    public virtual List<T> Get<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending, int startRowIndex, int maximumRows)
	{
        using var context = DbContextFactory.Create();

        return GetCore(where, orderBy, ascending, startRowIndex, maximumRows, context).ToList();
	}

    public virtual Task<List<T>> GetAsync<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending, int startRowIndex, int maximumRows)
        => Task.Run(() => Get(where, orderBy, ascending, startRowIndex, maximumRows));
	#endregion

	#region select
	/// <summary>
	///   모든 선택식의 결과를 반환한다.
	/// </summary>
	/// <typeparam name="R"> 선택 형식 </typeparam>
	/// <param name="select"> 선택식 </param>
	/// <returns> 엔터티의 리스트 </returns>
    public virtual List<R> Select<R>(Expression<Func<T, R>> select)
	{
		return Select<T, R>(null, null, false, 0, int.MaxValue, select);
	}

    public virtual Task<List<R>> SelectAsync<R>(Expression<Func<T, R>> select)
        => Task.Run(() => Select(select));

	/// <summary>
	///   조건식에 맞는 선택식의 결과를 반환한다.
	/// </summary>
	/// <typeparam name="R"> 선택 형식 </typeparam>
	/// <param name="where"> 조건식 </param>
	/// <param name="select"> 선택식 </param>
	/// <returns> 엔터티의 리스트 </returns>
    public virtual List<R> Select<R>(Expression<Func<T, bool>> where, Expression<Func<T, R>> select)
	{
		return Select<T, R>(where, null, false, 0, int.MaxValue, select);
	}

    public virtual Task<List<R>> SelectAsync<R>(Expression<Func<T, bool>> where, Expression<Func<T, R>> select)
        => Task.Run(() => Select(where, select));

	/// <summary>
	///   모든 엔터티들을 정렬식에 따라 정렬한 후 선택식의 결과를 반환한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
	/// </summary>
	/// <typeparam name="U"> 정렬 기준이 되는 속성의 형식 </typeparam>
	/// <typeparam name="R"> 선택 형식 </typeparam>
	/// <param name="orderBy"> 정렬식 </param>
	/// <param name="ascending"> true이면 오름차순, false이면 내림차순 </param>
	/// <param name="select"> 선택식 </param>
	/// <returns> 엔터티의 리스트 </returns>
    public virtual List<R> Select<U, R>(Expression<Func<T, U>> orderBy, bool ascending, Expression<Func<T, R>> select)
	{
		return Select(null, orderBy, ascending, 0, int.MaxValue, select);
	}

    public virtual Task<List<R>> SelectAsync<U, R>(Expression<Func<T, U>> orderBy, bool ascending, Expression<Func<T, R>> select)
        => Task.Run(() => Select(orderBy, ascending, select));

	/// <summary>
	///   조건식에 맞는 엔터티들을 정렬식에 따라 정렬한 후 선택식의 결과를 반환한다. 페이징을 지원한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
	/// </summary>
	/// <typeparam name="U"> 정렬 기준이 되는 속성의 형식 </typeparam>
	/// <typeparam name="R"> 선택 형식 </typeparam>
	/// <param name="orderBy"> 정렬식 </param>
	/// <param name="ascending"> true이면 오름차순, false이면 내림차순 </param>
	/// <param name="startRowIndex"> 반환할 엔터티의 시작 인덱스 </param>
	/// <param name="maximumRows"> 반환할 엔터티의 갯수 </param>
	/// <param name="select"> 선택식 </param>
	/// <returns> 엔터티의 리스트 </returns>
    public virtual List<R> Select<U, R>(Expression<Func<T, U>> orderBy, bool ascending, int startRowIndex, int maximumRows, Expression<Func<T, R>> select)
	{
		return Select(null, orderBy, ascending, startRowIndex, maximumRows, select);
	}

    public virtual Task<List<R>> SelectAsync<U, R>(Expression<Func<T, U>> orderBy, bool ascending, int startRowIndex, int maximumRows, Expression<Func<T, R>> select)
        => Task.Run(() => Select(orderBy, ascending, startRowIndex, maximumRows, select));
		

	/// <summary>
	///   조건식에 맞는 엔터티들을 정렬식에 따라 정렬한 후 선택식의 결과를 반환한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
	/// </summary>
	/// <typeparam name="U"> 정렬 기준이 되는 속성의 형식 </typeparam>
	/// <typeparam name="R"> 선택 형식 </typeparam>
	/// <param name="where"> 조건식 </param>
	/// <param name="orderBy"> 정렬식 </param>
	/// <param name="ascending"> true이면 오름차순, false이면 내림차순 </param>
	/// <param name="select"> 선택식 </param>
	/// <returns> 엔터티의 리스트 </returns>
    public virtual List<R> Select<U, R>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending, Expression<Func<T, R>> select)
	{
		return Select(where, orderBy, ascending, 0, int.MaxValue, select);
	}

    public virtual Task<List<R>> SelectAsync<U, R>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending, Expression<Func<T, R>> select)
        => Task.Run(() => Select(where, orderBy, ascending, select));

	/// <summary>
	///   조건식에 맞는 엔터티들을 정렬식에 따라 정렬한 후 선택식의 결과를 반환한다. 페이징과 프로젝션을을 지원한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
	/// </summary>
	/// <typeparam name="U"> 정렬 기준이 되는 속성의 형식 </typeparam>
	/// <typeparam name="R"> 선택 형식 </typeparam>
	/// <param name="where"> 조건식 </param>
	/// <param name="orderBy"> 정렬식 </param>
	/// <param name="ascending"> true이면 오름차순, false이면 내림차순 </param>
	/// <param name="startRowIndex"> 반환할 엔터티의 시작 인덱스 </param>
	/// <param name="maximumRows"> 반환할 엔터티의 갯수 </param>
	/// <param name="select"> 선택식 </param>
	/// <returns> 엔터티의 리스트 </returns>
    public virtual List<R> Select<U, R>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending, int startRowIndex, int maximumRows, Expression<Func<T, R>> select)
	{
        using var context = DbContextFactory.Create();

			var query = GetCore(where, orderBy, ascending, startRowIndex, maximumRows, context);
			return query.Select(select).ToList();
	}

    public virtual Task<List<R>> SelectAsync<U, R>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending, int startRowIndex, int maximumRows, Expression<Func<T, R>> select)
        => Task.Run(() => Select(where, orderBy, ascending, startRowIndex, maximumRows, select));

	private static IQueryable<T> GetCore<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending, int startRowIndex, int maximumRows, ChinookContext context)
	{
		var query = from x in context.Set<T>()
					select x;

		if (where != null)
			query = query.Where(where);

		IOrderedQueryable<T> orderedQuery = null;

		if (orderBy != null)
			orderedQuery = (ascending) ? query.OrderBy(orderBy) : query.OrderByDescending(orderBy);

		if (startRowIndex != 0 || maximumRows != int.MaxValue)
		{
			if (orderedQuery != null)
				orderedQuery = (IOrderedQueryable<T>)orderedQuery.Skip(startRowIndex).Take(maximumRows);
			else
				query = query.Skip(startRowIndex).Take(maximumRows);
		}

		return orderedQuery ?? query;
	}
	#endregion

	#region GetFirst / GetLast
	/// <summary>
	/// 모든 엔터티 중 첫번째 엔터티를 반환한다. 엔터티의 순서는 DB에 의해 결정된다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
	/// </summary>
	/// <returns>엔터티</returns>
    public virtual T GetFirst()
	{
		return GetFirst<T>(null, null);
	}

    public virtual Task<T> GetFirstAsync()
        => Task.Run(() => GetFirst());

	/// <summary>
	/// 조건식에 맞는 엔터티 중 첫번째 엔터티를 반환한다. 엔터티의 순서는 DB에 의해 결정된다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
	/// </summary>
	/// <param name="where">조건식</param>
	/// <returns>엔터티</returns>
    public virtual T GetFirst(Expression<Func<T, bool>> where)
	{
		return GetFirst<T>(where, null);
	}

    public virtual Task<T> GetFirstAsync(Expression<Func<T, bool>> where) 
        => Task.Run(() => GetFirst(where));

    /// <summary>
	/// 모든 엔터티를 정렬식에 따라 정렬했을 때 첫번째 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
	/// </summary>
	/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
	/// <param name="orderBy">정렬식</param>
	/// <returns>엔터티</returns>
    public virtual T GetFirst<U>(Expression<Func<T, U>> orderBy)
	{
		return GetFirst(null, orderBy);
	}

    public virtual Task<T> GetFirstAsync<U>(Expression<Func<T, U>> orderBy)
        => Task.Run(() => GetFirst(orderBy));

	/// <summary>
	/// 조건식에 맞는 엔터티를 정렬식에 따라 정렬했을 때 첫번째 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
	/// </summary>
	/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
	/// <param name="where">조건식</param>
	/// <param name="orderBy">정렬식</param>
	/// <returns>엔터티</returns>
    public virtual T GetFirst<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy)
	{
		return GetFirstCore(where, orderBy, true);
	}

    public virtual Task<T> GetFirstAsync<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy)
		=> Task.Run(() => GetFirst(where, orderBy));

	private T GetFirstCore<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending)
	{
        using var context = DbContextFactory.Create();

	    return QueryFirst(where, orderBy, ascending, context).FirstOrDefault();
	}

    /// <summary>
    /// 모든 엔터티를 정렬식에 따라 정렬했을 때 마지막 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
    /// </summary>
    /// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
    /// <param name="orderBy">정렬식</param>
    /// <returns>엔터티</returns>
    public virtual T GetLast<U>(Expression<Func<T, U>> orderBy)
	{
		return GetLast(null, orderBy);
	}

    public virtual Task<T> GetLastAsync<U>(Expression<Func<T, U>> orderBy)
	=> Task.Run(() => GetLast(orderBy));

	/// <summary>
	/// 조건식에 맞는 엔터티를 정렬식에 따라 정렬했을 때 마지막 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
	/// </summary>
	/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
	/// <param name="where">조건식</param>
	/// <param name="orderBy">정렬식</param>
	/// <returns>엔터티</returns>
	[ForAsync]
    public virtual T GetLast<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy)
	{
		return GetFirstCore(where, orderBy, false);
    }

    public virtual Task<T> GetLastAsync<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy)
	=> Task.Run(() => GetLast(where, orderBy));

    private static IQueryable<T> QueryFirst<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending, ChinookContext context)
	{
		var query = from x in context.Set<T>()
					select x;

		if (where != null)
			query = query.Where(where);

        // 마지막 행은 orderby가 반드시 지정되어 있어야 함. orderby를 지정하지 않으면 skip 메서드를 사용할 수 없기 때문.
        if (orderBy != null)
			query = @ascending ? query.OrderBy(orderBy) : query.OrderByDescending(orderBy);

        return query;
	}
	#endregion

	#region SelectFirst / SelectLast
	/// <summary>
	/// 모든 엔터티 중 첫번째 엔터티를 반환한다. 엔터티의 순서는 DB에 의해 결정된다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
	/// </summary>
	/// <param name="select">선택식</param>
	/// <returns>엔터티</returns>
    public virtual R SelectFirst<R>(Expression<Func<T, R>> select)
	{
		return SelectFirst<T, R>(null, null, select);
	}

    public virtual Task<R> SelectFirstAsync<R>(Expression<Func<T, R>> select)
	=> Task.Run(() => SelectFirst(select));

	/// <summary>
	/// 조건식에 맞는 엔터티 중 첫번째 엔터티를 반환한다. 엔터티의 순서는 DB에 의해 결정된다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
	/// </summary>
	/// <typeparam name="R">선택 형식</typeparam>
	/// <param name="where">조건식</param>
	/// <param name="select">선택식</param>
	/// <returns>엔터티</returns>
    public virtual R SelectFirst<R>(Expression<Func<T, bool>> where, Expression<Func<T, R>> select)
	{
		return SelectFirst<T, R>(where, null, select);
	}

    public virtual Task<R> SelectFirstAsync<R>(Expression<Func<T, bool>> where, Expression<Func<T, R>> select)
	=> Task.Run(() => SelectFirst(where, select));

	/// <summary>
	/// 모든 엔터티를 정렬식에 따라 정렬했을 때 첫번째 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
	/// </summary>
	/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
	/// <typeparam name="R">선택 형식</typeparam>
	/// <param name="orderBy">정렬식</param>
	/// <param name="select">선택식</param>
	/// <returns>엔터티</returns>
    public virtual R SelectFirst<U, R>(Expression<Func<T, U>> orderBy, Expression<Func<T, R>> select)
	{
		return SelectFirst(null, orderBy, select);
	}

    public virtual Task<R> SelectFirstAsync<U, R>(Expression<Func<T, U>> orderBy, Expression<Func<T, R>> select)
	=> Task.Run(() => SelectFirst(orderBy, select));

	/// <summary>
	/// 조건식에 맞는 엔터티를 정렬식에 따라 정렬했을 때 첫번째 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
	/// </summary>
	/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
	/// <typeparam name="R">선택 형식</typeparam>
	/// <param name="where">조건식</param>
	/// <param name="orderBy">정렬식</param>
	/// <param name="select">선택식</param>
	/// <returns>엔터티</returns>
    public virtual R SelectFirst<U, R>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, Expression<Func<T, R>> select)
	{
		return SelectFirstCore(where, orderBy, select, true);
	}

    public virtual Task<R> SelectFirstAsync<U, R>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, Expression<Func<T, R>> select)
	=> Task.Run(() => SelectFirst(where, orderBy, select));

    /// <summary>
    /// 조건식에 맞는 엔터티를 정렬식에 따라 정렬했을 때 첫번째 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
    /// </summary>
    /// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
    /// <typeparam name="R">선택 형식</typeparam>
    /// <param name="where">조건식</param>
    /// <param name="orderBy">정렬식</param>
    /// <param name="select">선택식</param>
    /// <param name="ascending">true이면 오름차순, false이면 내림차순</param>
    /// <returns>엔터티</returns>
    private R SelectFirstCore<U, R>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, Expression<Func<T, R>> select, bool ascending)
	{
        using var context = DbContextFactory.Create();

		var query = QueryFirst(where, orderBy, ascending, context);
		return query.Select(select).FirstOrDefault();
	}

    /// <summary>
    /// 모든 엔터티를 정렬식에 따라 정렬했을 때 마지막 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
    /// </summary>
    /// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
    /// <typeparam name="R">선택 형식</typeparam>
    /// <param name="orderBy">정렬식</param>
    /// <param name="select">선택식</param>
    /// <returns>엔터티</returns>
    public virtual R SelectLast<U, R>(Expression<Func<T, U>> orderBy, Expression<Func<T, R>> select)
	{
	    return SelectLast(null, orderBy, select);
	}

    public virtual Task<R> SelectLastAsync<U, R>(Expression<Func<T, U>> orderBy, Expression<Func<T, R>> select)
	=> Task.Run(() => SelectLast(orderBy, select));

    /// <summary>
    /// 조건식에 맞는 엔터티를 정렬식에 따라 정렬했을 때 마지막 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
    /// </summary>
    /// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
    /// <typeparam name="R">선택 형식</typeparam>
    /// <param name="where">조건식</param>
    /// <param name="orderBy">정렬식</param>
    /// <param name="select">선택식</param>
    /// <returns>엔터티</returns>
    public virtual R SelectLast<U, R>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, Expression<Func<T, R>> select)
	{
	    return SelectFirstCore(where, orderBy, select, false);
	}

    public virtual Task<R> SelectLastAsync<U, R>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, Expression<Func<T, R>> select)
	=> Task.Run(() => SelectLast(where, orderBy, select));
    #endregion

	#region GetCount
	/// <summary>
	/// 모든 엔터티의 갯수를 구한다.
	/// </summary>
	/// <returns>엔터티의 갯수</returns>
    public virtual int GetCount()
	{
		return GetCount(null);
	}

    public virtual Task<int> GetCountAsync()
	=> Task.Run(() => GetCount());

	/// <summary>
	/// 조건식에 맞는 엔터티의 갯수를 구한다.
	/// </summary>
	/// <param name="where">조건식</param>
	/// <returns>엔터티의 갯수</returns>
    public virtual int GetCount(Expression<Func<T, bool>> where)
	{
        using var context = DbContextFactory.Create();

		var query = from item in context.Set<T>()
					select item;

		if (where != null)
			query = query.Where(where);

		return query.Count();
	}

    public virtual Task<int> GetCountAsync(Expression<Func<T, bool>> where)
	=> Task.Run(() => GetCount(where));
	#endregion

	#region Exist
	/// <summary>
	/// 조건식에 맞는 엔터티가 존재하는지 검사한다.
	/// </summary>
	/// <param name="where">조건식</param>
	/// <returns>존재 여부</returns>
    public virtual bool Exists(Expression<Func<T, bool>> where)
	{
        using var context = DbContextFactory.Create();

		var query = from item in context.Set<T>()
					select item;

		if (where != null)
			query = query.Where(where);

		return query.Any();
	}

    public virtual Task<bool> ExistsAsync(Expression<Func<T, bool>> where)
	=> Task.Run(() => Exists(where));
	#endregion

	#region Write log partial methods
	/// <summary>
	/// 엔티티의 로그를 기록한다.
	/// </summary>
	/// <param name="entity">엔티티</param>
	/// <param name="logType">로그 타입</param>
	protected virtual partial void OnSaved(T entity, LogType logType);

	/// <summary>
	/// 엔티티 컬렉션의 로그를 기록한다.
	/// </summary>
	/// <param name="entities">엔티티 컬렉션</param>
	/// <param name="logType">로그 타입</param>
	protected virtual partial void OnSaved(IEnumerable<T> entities, LogType logType);
	#endregion

	#region Insert / Update / Delete
	/// <summary>
	/// 엔터티를 삽입한다.
	/// </summary>
	/// <param name="entity">삽입할 엔터티</param>
	/// <param name="withAudit">감사정보(수정자, 수정일)를 기록한다.</param>
    /// <returns>삽입된 엔터티</returns>
    public virtual T Insert(T entity, bool withAudit = false)
	{
        using var context = DbContextFactory.Create();

		MarkToInsert(context, entity);
			
		if (withAudit)
            entity.WriteAuditInfo();

		int count = context.SaveChanges();

		if (count > 0)
			OnSaved(entity, LogType.Insert);

		return entity;
	}

    public virtual Task<T> InsertAsync(T entity, bool withAudit = false)
	=> Task.Run(() => Insert(entity, withAudit));

	internal virtual void MarkToInsert(ChinookContext context, T entity)
	{
		context.Set<T>().Add(entity);
	}

	/// <summary>
	/// 엔터티 컬렉션을 삽입한다.
	/// </summary>
	/// <param name="entities">삽입할 엔터티가 포함된 컬렉션</param>
	/// <param name="withAudit">감사정보(수정자, 수정일)를 기록한다.</param>
	/// <returns>삽입된 엔터티의 갯수</returns>
    public virtual int InsertMany(IEnumerable<T> entities, bool withAudit = false)
	{
        using var context = DbContextFactory.Create();

        foreach (var entity in entities)
        {
            MarkToInsert(context, entity);
				
			if (withAudit)
		        entity.WriteAuditInfo();
        }

		int count = context.SaveChanges();

		if (count > 0)
			OnSaved(entities, LogType.Insert);

		return count;
	}

    public virtual Task<int> InsertManyAsync(IEnumerable<T> entities, bool withAudit = false)
	=> Task.Run(() => InsertMany(entities, withAudit));

	/// <summary>
	/// 엔터티를 갱신한다.
	/// </summary>
	/// <param name="entity">갱신할 엔터티</param>
	/// <param name="withAudit">감사정보(수정자, 수정일)를 기록한다.</param>
	/// <returns>갱신된 엔터티의 갯수</returns>
    public virtual int Update(T entity, bool withAudit = false)
	{
        using var context = DbContextFactory.Create();

		MarkToUpdate(context, entity);
			
		if (withAudit)
            entity.WriteAuditInfo();

		int count = context.SaveChanges();

		if (count > 0)
			OnSaved(entity, LogType.Update);

		return count;
	}

    public virtual Task<int> UpdateAsync(T entity, bool withAudit = false)
	=> Task.Run(() => Update(entity, withAudit));

	internal virtual void MarkToUpdate(ChinookContext context, T entity)
	{
		context.Entry(entity).State = EntityState.Modified;
	}

	/// <summary>
	/// 엔터티 컬렉션을 갱신한다.
	/// </summary>
	/// <param name="entities">갱신할 엔터티가 포함된 컬렉션</param>
	/// <param name="withAudit">감사정보(수정자, 수정일)를 기록한다.</param>
	/// <returns>갱신된 엔터티의 갯수</returns>
    public virtual int UpdateMany(IEnumerable<T> entities, bool withAudit = false)
	{
        using var context = DbContextFactory.Create();

        foreach (var entity in entities)
        {
            MarkToUpdate(context, entity);

			if (withAudit)
				entity.WriteAuditInfo();
        }

		int count = context.SaveChanges();

		if (count > 0)
			OnSaved(entities, LogType.Update);

		return count;
	}

    public virtual Task<int> UpdateManyAsync(IEnumerable<T> entities, bool withAudit = false)
	=> Task.Run(() => UpdateMany(entities, withAudit));

	/// <summary>
	/// 엔터티를 삭제한다.
	/// </summary>
	/// <param name="entity">삭제할 엔터티</param>
	/// <returns>삭제된 엔터티의 갯수</returns>
    public virtual int Delete(T entity)
	{
        using var context = DbContextFactory.Create();

        MarkToDelete(context, entity);
		int count = context.SaveChanges();

		OnSaved(entity, LogType.Delete);
			
		return count;
	}

    public virtual Task<int> DeleteAsync(T entity)
	=> Task.Run(() => Delete(entity));

	internal virtual void MarkToDelete(ChinookContext context, T entity)
	{
		context.Entry(entity).State = EntityState.Deleted;
	}

	/// <summary>
	/// 엔터티 컬렉션을 삭제한다.
	/// </summary>
	/// <param name="entities">삭제할 엔터티 컬렉션</param>
	/// <returns>삭제된 엔터티의 갯수</returns>
    public virtual int DeleteMany(IEnumerable<T> entities)
	{
        using var context = DbContextFactory.Create();
			
		MarkToDeleteMany(context, entities);
		int count = context.SaveChanges();

		OnSaved(entities, LogType.Delete);

		return count;
	}

    public virtual Task<int> DeleteManyAsync(IEnumerable<T> entities)
	=> Task.Run(() => DeleteMany(entities));

	internal virtual void MarkToDeleteMany(ChinookContext context, IEnumerable<T> entities)
	{
		foreach (var entity in entities)
			context.Entry(entity).State = EntityState.Deleted;
	}

	/// <summary>
	/// 조건식을 만족하는 엔터티들을 삭제한다.
	/// </summary>
	/// <param name="where">조건식</param>
	/// <returns>삭제된 엔터티의 갯수</returns>
    public virtual int DeleteAll(Expression<Func<T, bool>> where)
	{
        using var context = DbContextFactory.Create();

		var query = from item in context.Set<T>()
					select item;

		if (where != null)
			query = query.Where(where);

		var entities = query.ToList();

		MarkToDeleteMany(context, entities);

		int count = context.SaveChanges();

		OnSaved(entities, LogType.Delete);

		return count;
	}

    public virtual Task<int> DeleteAllAsync(Expression<Func<T, bool>> where)
	=> Task.Run(() => DeleteAll(where));
	#endregion
}
#endregion

#region AlbumDao
/// <summary>
/// Album 데이터 클래스
/// </summary>
public partial class AlbumDao : EntityDao<Album>
{
	internal AlbumDao() {}

	
	/// <summary>
	/// 기본키가 일치하는 엔터티를 구한다.
	/// </summary>
		/// <param name="albumId">기본키</param>
	/// <returns>기본키가 일치하는 엔터티</returns>
    public virtual Album GetByKey(int albumId)
	{
        using var context = DbContextFactory.Create();

        return context.Set<Album>().FirstOrDefault(x =>  x.AlbumId == albumId);
	}

    public virtual Task<Album> GetByKeyAsync(int albumId)
		=> Task.Run(() => GetByKey(albumId));

	/// <summary>
	/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
	/// </summary>
		/// <param name="albumId">기본키</param>
	/// <returns>존재 여부</returns>
    public virtual bool ExistsByKey(int albumId)
	{
        using var context = DbContextFactory.Create();

		return context.Set<Album>().Count(x =>  x.AlbumId == albumId) > 0;
	}

    public virtual Task<bool> ExistsByKeyAsync(int albumId)
	=> Task.Run(() => ExistsByKey(albumId));

	/// <summary>
	/// 기본키가 일치하는 엔터티를 삭제한다.
	/// </summary>
		/// <param name="albumId">기본키</param>
	/// <returns>삭제된 엔터티의 갯수</returns>
    public virtual int DeleteByKey(int albumId)
	{
        using var context = DbContextFactory.Create();

		var query = from x in context.Set<Album>()
		where x.AlbumId == albumId
		select x;

		var entity = query.FirstOrDefault();

        if (entity == null)
            return 0;

		MarkToDelete(context, entity);

		return context.SaveChanges();
	}

    public virtual Task<int> DeleteByKeyAsync(int albumId)
	=> Task.Run(() => DeleteByKey(albumId));

    /// <summary>
    /// 기본키가 일치하는 엔터티가 없으면 삽입한다.
    /// </summary>
    /// <param name="entity">삽입할 엔터티</param>
	/// <returns>삽입된 엔터티</returns>
    public virtual Album InsertIfNotExist(Album entity)
	{
        using var context = DbContextFactory.Create();

	    if (context.Set<Album>().Count(x =>  x.AlbumId == entity.AlbumId) > 0)
	        return null;

	    return Insert(entity);
	}

    public virtual Task<Album> InsertIfNotExistAsync(Album entity)
	=> Task.Run(() => InsertIfNotExist(entity));

    /// <summary>
    /// 기본키가 일치하는 엔터티가 있으면 갱신하고 없으면 삽입한다.
    /// </summary>
    /// <param name="entity">삽입 혹은 갱신할 엔터티</param>
	/// <param name="withAudit">감사정보(수정자, 수정일)를 기록한다.</param>
	/// <returns>삽입했으면 true, 갱신했으면 false</returns>
    public virtual bool InsertOrUpdate(Album entity, bool withAudit = false)
	{
        using var context = DbContextFactory.Create();
            
	    if (context.Set<Album>().Count(x =>  x.AlbumId == entity.AlbumId) > 0)
	    {
	        Update(entity);
            return false;
        }
        else
	    {
	        Insert(entity);
            return true;
        }
	}

    public virtual Task<bool> InsertOrUpdateAsync(Album entity, bool withAudit = false)
	=> Task.Run(() => InsertOrUpdate(entity, withAudit));
	

		/// <summary>
	/// 외래키 ArtistId 이(가) 일치하는 엔터티 컬렉션을 구한다.
	/// </summary>
	/// <param name="artistId">외래키</param>
	/// <returns>ArtistId 이(가) 일치하는 엔터티 컬렉션</returns>
    public virtual List<Album> GetByArtistId(int artistId)
	{
        using var context = DbContextFactory.Create();

		return context.Set<Album>().Where(x => x.ArtistId == artistId).ToList();
	}

    public virtual Task<List<Album>> GetByArtistIdAsync(int artistId)
	=> Task.Run(() => GetByArtistId(artistId));
}
#endregion
#region ArtistDao
/// <summary>
/// Artist 데이터 클래스
/// </summary>
public partial class ArtistDao : EntityDao<Artist>
{
	internal ArtistDao() {}

	
	/// <summary>
	/// 기본키가 일치하는 엔터티를 구한다.
	/// </summary>
		/// <param name="artistId">기본키</param>
	/// <returns>기본키가 일치하는 엔터티</returns>
    public virtual Artist GetByKey(int artistId)
	{
        using var context = DbContextFactory.Create();

        return context.Set<Artist>().FirstOrDefault(x =>  x.ArtistId == artistId);
	}

    public virtual Task<Artist> GetByKeyAsync(int artistId)
		=> Task.Run(() => GetByKey(artistId));

	/// <summary>
	/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
	/// </summary>
		/// <param name="artistId">기본키</param>
	/// <returns>존재 여부</returns>
    public virtual bool ExistsByKey(int artistId)
	{
        using var context = DbContextFactory.Create();

		return context.Set<Artist>().Count(x =>  x.ArtistId == artistId) > 0;
	}

    public virtual Task<bool> ExistsByKeyAsync(int artistId)
	=> Task.Run(() => ExistsByKey(artistId));

	/// <summary>
	/// 기본키가 일치하는 엔터티를 삭제한다.
	/// </summary>
		/// <param name="artistId">기본키</param>
	/// <returns>삭제된 엔터티의 갯수</returns>
    public virtual int DeleteByKey(int artistId)
	{
        using var context = DbContextFactory.Create();

		var query = from x in context.Set<Artist>()
		where x.ArtistId == artistId
		select x;

		var entity = query.FirstOrDefault();

        if (entity == null)
            return 0;

		MarkToDelete(context, entity);

		return context.SaveChanges();
	}

    public virtual Task<int> DeleteByKeyAsync(int artistId)
	=> Task.Run(() => DeleteByKey(artistId));

    /// <summary>
    /// 기본키가 일치하는 엔터티가 없으면 삽입한다.
    /// </summary>
    /// <param name="entity">삽입할 엔터티</param>
	/// <returns>삽입된 엔터티</returns>
    public virtual Artist InsertIfNotExist(Artist entity)
	{
        using var context = DbContextFactory.Create();

	    if (context.Set<Artist>().Count(x =>  x.ArtistId == entity.ArtistId) > 0)
	        return null;

	    return Insert(entity);
	}

    public virtual Task<Artist> InsertIfNotExistAsync(Artist entity)
	=> Task.Run(() => InsertIfNotExist(entity));

    /// <summary>
    /// 기본키가 일치하는 엔터티가 있으면 갱신하고 없으면 삽입한다.
    /// </summary>
    /// <param name="entity">삽입 혹은 갱신할 엔터티</param>
	/// <param name="withAudit">감사정보(수정자, 수정일)를 기록한다.</param>
	/// <returns>삽입했으면 true, 갱신했으면 false</returns>
    public virtual bool InsertOrUpdate(Artist entity, bool withAudit = false)
	{
        using var context = DbContextFactory.Create();
            
	    if (context.Set<Artist>().Count(x =>  x.ArtistId == entity.ArtistId) > 0)
	    {
	        Update(entity);
            return false;
        }
        else
	    {
	        Insert(entity);
            return true;
        }
	}

    public virtual Task<bool> InsertOrUpdateAsync(Artist entity, bool withAudit = false)
	=> Task.Run(() => InsertOrUpdate(entity, withAudit));
	

		/// <summary>
	/// 외래키 CompanyId 이(가) 일치하는 엔터티 컬렉션을 구한다.
	/// </summary>
	/// <param name="companyId">외래키</param>
	/// <returns>CompanyId 이(가) 일치하는 엔터티 컬렉션</returns>
    public virtual List<Artist> GetByCompanyId(int? companyId)
	{
        using var context = DbContextFactory.Create();

		return context.Set<Artist>().Where(x => x.CompanyId == companyId).ToList();
	}

    public virtual Task<List<Artist>> GetByCompanyIdAsync(int? companyId)
	=> Task.Run(() => GetByCompanyId(companyId));
}
#endregion
#region CompanyDao
/// <summary>
/// Company 데이터 클래스
/// </summary>
public partial class CompanyDao : EntityDao<Company>
{
	internal CompanyDao() {}

	
	/// <summary>
	/// 기본키가 일치하는 엔터티를 구한다.
	/// </summary>
		/// <param name="companyId">기본키</param>
	/// <returns>기본키가 일치하는 엔터티</returns>
    public virtual Company GetByKey(int companyId)
	{
        using var context = DbContextFactory.Create();

        return context.Set<Company>().FirstOrDefault(x =>  x.CompanyId == companyId);
	}

    public virtual Task<Company> GetByKeyAsync(int companyId)
		=> Task.Run(() => GetByKey(companyId));

	/// <summary>
	/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
	/// </summary>
		/// <param name="companyId">기본키</param>
	/// <returns>존재 여부</returns>
    public virtual bool ExistsByKey(int companyId)
	{
        using var context = DbContextFactory.Create();

		return context.Set<Company>().Count(x =>  x.CompanyId == companyId) > 0;
	}

    public virtual Task<bool> ExistsByKeyAsync(int companyId)
	=> Task.Run(() => ExistsByKey(companyId));

	/// <summary>
	/// 기본키가 일치하는 엔터티를 삭제한다.
	/// </summary>
		/// <param name="companyId">기본키</param>
	/// <returns>삭제된 엔터티의 갯수</returns>
    public virtual int DeleteByKey(int companyId)
	{
        using var context = DbContextFactory.Create();

		var query = from x in context.Set<Company>()
		where x.CompanyId == companyId
		select x;

		var entity = query.FirstOrDefault();

        if (entity == null)
            return 0;

		MarkToDelete(context, entity);

		return context.SaveChanges();
	}

    public virtual Task<int> DeleteByKeyAsync(int companyId)
	=> Task.Run(() => DeleteByKey(companyId));

    /// <summary>
    /// 기본키가 일치하는 엔터티가 없으면 삽입한다.
    /// </summary>
    /// <param name="entity">삽입할 엔터티</param>
	/// <returns>삽입된 엔터티</returns>
    public virtual Company InsertIfNotExist(Company entity)
	{
        using var context = DbContextFactory.Create();

	    if (context.Set<Company>().Count(x =>  x.CompanyId == entity.CompanyId) > 0)
	        return null;

	    return Insert(entity);
	}

    public virtual Task<Company> InsertIfNotExistAsync(Company entity)
	=> Task.Run(() => InsertIfNotExist(entity));

    /// <summary>
    /// 기본키가 일치하는 엔터티가 있으면 갱신하고 없으면 삽입한다.
    /// </summary>
    /// <param name="entity">삽입 혹은 갱신할 엔터티</param>
	/// <param name="withAudit">감사정보(수정자, 수정일)를 기록한다.</param>
	/// <returns>삽입했으면 true, 갱신했으면 false</returns>
    public virtual bool InsertOrUpdate(Company entity, bool withAudit = false)
	{
        using var context = DbContextFactory.Create();
            
	    if (context.Set<Company>().Count(x =>  x.CompanyId == entity.CompanyId) > 0)
	    {
	        Update(entity);
            return false;
        }
        else
	    {
	        Insert(entity);
            return true;
        }
	}

    public virtual Task<bool> InsertOrUpdateAsync(Company entity, bool withAudit = false)
	=> Task.Run(() => InsertOrUpdate(entity, withAudit));
	

	
}
#endregion
#region PlaylistDao
/// <summary>
/// Playlist 데이터 클래스
/// </summary>
public partial class PlaylistDao : EntityDao<Playlist>
{
	internal PlaylistDao() {}

	
	/// <summary>
	/// 기본키가 일치하는 엔터티를 구한다.
	/// </summary>
		/// <param name="playlistId">기본키</param>
	/// <returns>기본키가 일치하는 엔터티</returns>
    public virtual Playlist GetByKey(int playlistId)
	{
        using var context = DbContextFactory.Create();

        return context.Set<Playlist>().FirstOrDefault(x =>  x.PlaylistId == playlistId);
	}

    public virtual Task<Playlist> GetByKeyAsync(int playlistId)
		=> Task.Run(() => GetByKey(playlistId));

	/// <summary>
	/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
	/// </summary>
		/// <param name="playlistId">기본키</param>
	/// <returns>존재 여부</returns>
    public virtual bool ExistsByKey(int playlistId)
	{
        using var context = DbContextFactory.Create();

		return context.Set<Playlist>().Count(x =>  x.PlaylistId == playlistId) > 0;
	}

    public virtual Task<bool> ExistsByKeyAsync(int playlistId)
	=> Task.Run(() => ExistsByKey(playlistId));

	/// <summary>
	/// 기본키가 일치하는 엔터티를 삭제한다.
	/// </summary>
		/// <param name="playlistId">기본키</param>
	/// <returns>삭제된 엔터티의 갯수</returns>
    public virtual int DeleteByKey(int playlistId)
	{
        using var context = DbContextFactory.Create();

		var query = from x in context.Set<Playlist>()
		where x.PlaylistId == playlistId
		select x;

		var entity = query.FirstOrDefault();

        if (entity == null)
            return 0;

		MarkToDelete(context, entity);

		return context.SaveChanges();
	}

    public virtual Task<int> DeleteByKeyAsync(int playlistId)
	=> Task.Run(() => DeleteByKey(playlistId));

    /// <summary>
    /// 기본키가 일치하는 엔터티가 없으면 삽입한다.
    /// </summary>
    /// <param name="entity">삽입할 엔터티</param>
	/// <returns>삽입된 엔터티</returns>
    public virtual Playlist InsertIfNotExist(Playlist entity)
	{
        using var context = DbContextFactory.Create();

	    if (context.Set<Playlist>().Count(x =>  x.PlaylistId == entity.PlaylistId) > 0)
	        return null;

	    return Insert(entity);
	}

    public virtual Task<Playlist> InsertIfNotExistAsync(Playlist entity)
	=> Task.Run(() => InsertIfNotExist(entity));

    /// <summary>
    /// 기본키가 일치하는 엔터티가 있으면 갱신하고 없으면 삽입한다.
    /// </summary>
    /// <param name="entity">삽입 혹은 갱신할 엔터티</param>
	/// <param name="withAudit">감사정보(수정자, 수정일)를 기록한다.</param>
	/// <returns>삽입했으면 true, 갱신했으면 false</returns>
    public virtual bool InsertOrUpdate(Playlist entity, bool withAudit = false)
	{
        using var context = DbContextFactory.Create();
            
	    if (context.Set<Playlist>().Count(x =>  x.PlaylistId == entity.PlaylistId) > 0)
	    {
	        Update(entity);
            return false;
        }
        else
	    {
	        Insert(entity);
            return true;
        }
	}

    public virtual Task<bool> InsertOrUpdateAsync(Playlist entity, bool withAudit = false)
	=> Task.Run(() => InsertOrUpdate(entity, withAudit));
	

	
}
#endregion
#region PlaylistTrackDao
/// <summary>
/// PlaylistTrack 데이터 클래스
/// </summary>
public partial class PlaylistTrackDao : EntityDao<PlaylistTrack>
{
	internal PlaylistTrackDao() {}

	
	/// <summary>
	/// 기본키가 일치하는 엔터티를 구한다.
	/// </summary>
		/// <param name="playlistId">기본키</param>	/// <param name="trackId">기본키</param>
	/// <returns>기본키가 일치하는 엔터티</returns>
    public virtual PlaylistTrack GetByKey(int playlistId, int trackId)
	{
        using var context = DbContextFactory.Create();

        return context.Set<PlaylistTrack>().FirstOrDefault(x =>  x.PlaylistId == playlistId &&  x.TrackId == trackId);
	}

    public virtual Task<PlaylistTrack> GetByKeyAsync(int playlistId, int trackId)
		=> Task.Run(() => GetByKey(playlistId, trackId));

	/// <summary>
	/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
	/// </summary>
		/// <param name="playlistId">기본키</param>	/// <param name="trackId">기본키</param>
	/// <returns>존재 여부</returns>
    public virtual bool ExistsByKey(int playlistId, int trackId)
	{
        using var context = DbContextFactory.Create();

		return context.Set<PlaylistTrack>().Count(x =>  x.PlaylistId == playlistId &&  x.TrackId == trackId) > 0;
	}

    public virtual Task<bool> ExistsByKeyAsync(int playlistId, int trackId)
	=> Task.Run(() => ExistsByKey(playlistId, trackId));

	/// <summary>
	/// 기본키가 일치하는 엔터티를 삭제한다.
	/// </summary>
		/// <param name="playlistId">기본키</param>	/// <param name="trackId">기본키</param>
	/// <returns>삭제된 엔터티의 갯수</returns>
    public virtual int DeleteByKey(int playlistId, int trackId)
	{
        using var context = DbContextFactory.Create();

		var query = from x in context.Set<PlaylistTrack>()
		where x.PlaylistId == playlistId && x.TrackId == trackId
		select x;

		var entity = query.FirstOrDefault();

        if (entity == null)
            return 0;

		MarkToDelete(context, entity);

		return context.SaveChanges();
	}

    public virtual Task<int> DeleteByKeyAsync(int playlistId, int trackId)
	=> Task.Run(() => DeleteByKey(playlistId, trackId));

    /// <summary>
    /// 기본키가 일치하는 엔터티가 없으면 삽입한다.
    /// </summary>
    /// <param name="entity">삽입할 엔터티</param>
	/// <returns>삽입된 엔터티</returns>
    public virtual PlaylistTrack InsertIfNotExist(PlaylistTrack entity)
	{
        using var context = DbContextFactory.Create();

	    if (context.Set<PlaylistTrack>().Count(x =>  x.PlaylistId == entity.PlaylistId &&  x.TrackId == entity.TrackId) > 0)
	        return null;

	    return Insert(entity);
	}

    public virtual Task<PlaylistTrack> InsertIfNotExistAsync(PlaylistTrack entity)
	=> Task.Run(() => InsertIfNotExist(entity));

    /// <summary>
    /// 기본키가 일치하는 엔터티가 있으면 갱신하고 없으면 삽입한다.
    /// </summary>
    /// <param name="entity">삽입 혹은 갱신할 엔터티</param>
	/// <param name="withAudit">감사정보(수정자, 수정일)를 기록한다.</param>
	/// <returns>삽입했으면 true, 갱신했으면 false</returns>
    public virtual bool InsertOrUpdate(PlaylistTrack entity, bool withAudit = false)
	{
        using var context = DbContextFactory.Create();
            
	    if (context.Set<PlaylistTrack>().Count(x =>  x.PlaylistId == entity.PlaylistId &&  x.TrackId == entity.TrackId) > 0)
	    {
	        Update(entity);
            return false;
        }
        else
	    {
	        Insert(entity);
            return true;
        }
	}

    public virtual Task<bool> InsertOrUpdateAsync(PlaylistTrack entity, bool withAudit = false)
	=> Task.Run(() => InsertOrUpdate(entity, withAudit));
	

		/// <summary>
	/// 외래키 PlaylistId 이(가) 일치하는 엔터티 컬렉션을 구한다.
	/// </summary>
	/// <param name="playlistId">외래키</param>
	/// <returns>PlaylistId 이(가) 일치하는 엔터티 컬렉션</returns>
    public virtual List<PlaylistTrack> GetByPlaylistId(int playlistId)
	{
        using var context = DbContextFactory.Create();

		return context.Set<PlaylistTrack>().Where(x => x.PlaylistId == playlistId).ToList();
	}

    public virtual Task<List<PlaylistTrack>> GetByPlaylistIdAsync(int playlistId)
	=> Task.Run(() => GetByPlaylistId(playlistId));
	/// <summary>
	/// 외래키 TrackId 이(가) 일치하는 엔터티 컬렉션을 구한다.
	/// </summary>
	/// <param name="trackId">외래키</param>
	/// <returns>TrackId 이(가) 일치하는 엔터티 컬렉션</returns>
    public virtual List<PlaylistTrack> GetByTrackId(int trackId)
	{
        using var context = DbContextFactory.Create();

		return context.Set<PlaylistTrack>().Where(x => x.TrackId == trackId).ToList();
	}

    public virtual Task<List<PlaylistTrack>> GetByTrackIdAsync(int trackId)
	=> Task.Run(() => GetByTrackId(trackId));
}
#endregion
#region PlaylistTrackHistoryDao
/// <summary>
/// PlaylistTrackHistory 데이터 클래스
/// </summary>
public partial class PlaylistTrackHistoryDao : EntityDao<PlaylistTrackHistory>
{
	internal PlaylistTrackHistoryDao() {}

	
	/// <summary>
	/// 기본키가 일치하는 엔터티를 구한다.
	/// </summary>
		/// <param name="playlistId">기본키</param>	/// <param name="trackId">기본키</param>	/// <param name="writtenAt">기본키</param>
	/// <returns>기본키가 일치하는 엔터티</returns>
    public virtual PlaylistTrackHistory GetByKey(int playlistId, int trackId, DateTime writtenAt)
	{
        using var context = DbContextFactory.Create();

        return context.Set<PlaylistTrackHistory>().FirstOrDefault(x =>  x.PlaylistId == playlistId &&  x.TrackId == trackId &&  x.WrittenAt == writtenAt);
	}

    public virtual Task<PlaylistTrackHistory> GetByKeyAsync(int playlistId, int trackId, DateTime writtenAt)
		=> Task.Run(() => GetByKey(playlistId, trackId, writtenAt));

	/// <summary>
	/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
	/// </summary>
		/// <param name="playlistId">기본키</param>	/// <param name="trackId">기본키</param>	/// <param name="writtenAt">기본키</param>
	/// <returns>존재 여부</returns>
    public virtual bool ExistsByKey(int playlistId, int trackId, DateTime writtenAt)
	{
        using var context = DbContextFactory.Create();

		return context.Set<PlaylistTrackHistory>().Count(x =>  x.PlaylistId == playlistId &&  x.TrackId == trackId &&  x.WrittenAt == writtenAt) > 0;
	}

    public virtual Task<bool> ExistsByKeyAsync(int playlistId, int trackId, DateTime writtenAt)
	=> Task.Run(() => ExistsByKey(playlistId, trackId, writtenAt));

	/// <summary>
	/// 기본키가 일치하는 엔터티를 삭제한다.
	/// </summary>
		/// <param name="playlistId">기본키</param>	/// <param name="trackId">기본키</param>	/// <param name="writtenAt">기본키</param>
	/// <returns>삭제된 엔터티의 갯수</returns>
    public virtual int DeleteByKey(int playlistId, int trackId, DateTime writtenAt)
	{
        using var context = DbContextFactory.Create();

		var query = from x in context.Set<PlaylistTrackHistory>()
		where x.PlaylistId == playlistId && x.TrackId == trackId && x.WrittenAt == writtenAt
		select x;

		var entity = query.FirstOrDefault();

        if (entity == null)
            return 0;

		MarkToDelete(context, entity);

		return context.SaveChanges();
	}

    public virtual Task<int> DeleteByKeyAsync(int playlistId, int trackId, DateTime writtenAt)
	=> Task.Run(() => DeleteByKey(playlistId, trackId, writtenAt));

    /// <summary>
    /// 기본키가 일치하는 엔터티가 없으면 삽입한다.
    /// </summary>
    /// <param name="entity">삽입할 엔터티</param>
	/// <returns>삽입된 엔터티</returns>
    public virtual PlaylistTrackHistory InsertIfNotExist(PlaylistTrackHistory entity)
	{
        using var context = DbContextFactory.Create();

	    if (context.Set<PlaylistTrackHistory>().Count(x =>  x.PlaylistId == entity.PlaylistId &&  x.TrackId == entity.TrackId &&  x.WrittenAt == entity.WrittenAt) > 0)
	        return null;

	    return Insert(entity);
	}

    public virtual Task<PlaylistTrackHistory> InsertIfNotExistAsync(PlaylistTrackHistory entity)
	=> Task.Run(() => InsertIfNotExist(entity));

    /// <summary>
    /// 기본키가 일치하는 엔터티가 있으면 갱신하고 없으면 삽입한다.
    /// </summary>
    /// <param name="entity">삽입 혹은 갱신할 엔터티</param>
	/// <param name="withAudit">감사정보(수정자, 수정일)를 기록한다.</param>
	/// <returns>삽입했으면 true, 갱신했으면 false</returns>
    public virtual bool InsertOrUpdate(PlaylistTrackHistory entity, bool withAudit = false)
	{
        using var context = DbContextFactory.Create();
            
	    if (context.Set<PlaylistTrackHistory>().Count(x =>  x.PlaylistId == entity.PlaylistId &&  x.TrackId == entity.TrackId &&  x.WrittenAt == entity.WrittenAt) > 0)
	    {
	        Update(entity);
            return false;
        }
        else
	    {
	        Insert(entity);
            return true;
        }
	}

    public virtual Task<bool> InsertOrUpdateAsync(PlaylistTrackHistory entity, bool withAudit = false)
	=> Task.Run(() => InsertOrUpdate(entity, withAudit));
	

		/// <summary>
	/// 외래키 PlaylistId 이(가) 일치하는 엔터티 컬렉션을 구한다.
	/// </summary>
	/// <param name="playlistId">외래키</param>
	/// <returns>PlaylistId 이(가) 일치하는 엔터티 컬렉션</returns>
    public virtual List<PlaylistTrackHistory> GetByPlaylistId(int playlistId)
	{
        using var context = DbContextFactory.Create();

		return context.Set<PlaylistTrackHistory>().Where(x => x.PlaylistId == playlistId).ToList();
	}

    public virtual Task<List<PlaylistTrackHistory>> GetByPlaylistIdAsync(int playlistId)
	=> Task.Run(() => GetByPlaylistId(playlistId));
	/// <summary>
	/// 외래키 TrackId 이(가) 일치하는 엔터티 컬렉션을 구한다.
	/// </summary>
	/// <param name="trackId">외래키</param>
	/// <returns>TrackId 이(가) 일치하는 엔터티 컬렉션</returns>
    public virtual List<PlaylistTrackHistory> GetByTrackId(int trackId)
	{
        using var context = DbContextFactory.Create();

		return context.Set<PlaylistTrackHistory>().Where(x => x.TrackId == trackId).ToList();
	}

    public virtual Task<List<PlaylistTrackHistory>> GetByTrackIdAsync(int trackId)
	=> Task.Run(() => GetByTrackId(trackId));
}
#endregion
#region TrackDao
/// <summary>
/// Track 데이터 클래스
/// </summary>
public partial class TrackDao : EntityDao<Track>
{
	internal TrackDao() {}

	
	/// <summary>
	/// 기본키가 일치하는 엔터티를 구한다.
	/// </summary>
		/// <param name="trackId">기본키</param>
	/// <returns>기본키가 일치하는 엔터티</returns>
    public virtual Track GetByKey(int trackId)
	{
        using var context = DbContextFactory.Create();

        return context.Set<Track>().FirstOrDefault(x =>  x.TrackId == trackId);
	}

    public virtual Task<Track> GetByKeyAsync(int trackId)
		=> Task.Run(() => GetByKey(trackId));

	/// <summary>
	/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
	/// </summary>
		/// <param name="trackId">기본키</param>
	/// <returns>존재 여부</returns>
    public virtual bool ExistsByKey(int trackId)
	{
        using var context = DbContextFactory.Create();

		return context.Set<Track>().Count(x =>  x.TrackId == trackId) > 0;
	}

    public virtual Task<bool> ExistsByKeyAsync(int trackId)
	=> Task.Run(() => ExistsByKey(trackId));

	/// <summary>
	/// 기본키가 일치하는 엔터티를 삭제한다.
	/// </summary>
		/// <param name="trackId">기본키</param>
	/// <returns>삭제된 엔터티의 갯수</returns>
    public virtual int DeleteByKey(int trackId)
	{
        using var context = DbContextFactory.Create();

		var query = from x in context.Set<Track>()
		where x.TrackId == trackId
		select x;

		var entity = query.FirstOrDefault();

        if (entity == null)
            return 0;

		MarkToDelete(context, entity);

		return context.SaveChanges();
	}

    public virtual Task<int> DeleteByKeyAsync(int trackId)
	=> Task.Run(() => DeleteByKey(trackId));

    /// <summary>
    /// 기본키가 일치하는 엔터티가 없으면 삽입한다.
    /// </summary>
    /// <param name="entity">삽입할 엔터티</param>
	/// <returns>삽입된 엔터티</returns>
    public virtual Track InsertIfNotExist(Track entity)
	{
        using var context = DbContextFactory.Create();

	    if (context.Set<Track>().Count(x =>  x.TrackId == entity.TrackId) > 0)
	        return null;

	    return Insert(entity);
	}

    public virtual Task<Track> InsertIfNotExistAsync(Track entity)
	=> Task.Run(() => InsertIfNotExist(entity));

    /// <summary>
    /// 기본키가 일치하는 엔터티가 있으면 갱신하고 없으면 삽입한다.
    /// </summary>
    /// <param name="entity">삽입 혹은 갱신할 엔터티</param>
	/// <param name="withAudit">감사정보(수정자, 수정일)를 기록한다.</param>
	/// <returns>삽입했으면 true, 갱신했으면 false</returns>
    public virtual bool InsertOrUpdate(Track entity, bool withAudit = false)
	{
        using var context = DbContextFactory.Create();
            
	    if (context.Set<Track>().Count(x =>  x.TrackId == entity.TrackId) > 0)
	    {
	        Update(entity);
            return false;
        }
        else
	    {
	        Insert(entity);
            return true;
        }
	}

    public virtual Task<bool> InsertOrUpdateAsync(Track entity, bool withAudit = false)
	=> Task.Run(() => InsertOrUpdate(entity, withAudit));
	

		/// <summary>
	/// 외래키 AlbumId 이(가) 일치하는 엔터티 컬렉션을 구한다.
	/// </summary>
	/// <param name="albumId">외래키</param>
	/// <returns>AlbumId 이(가) 일치하는 엔터티 컬렉션</returns>
    public virtual List<Track> GetByAlbumId(int? albumId)
	{
        using var context = DbContextFactory.Create();

		return context.Set<Track>().Where(x => x.AlbumId == albumId).ToList();
	}

    public virtual Task<List<Track>> GetByAlbumIdAsync(int? albumId)
	=> Task.Run(() => GetByAlbumId(albumId));
}
#endregion
#endregion

#region Types
/// <summary>
/// 엔티티를 추가/수정/삭제 할 때 기록하는 로그의 종류
/// </summary>
public enum LogType
{
	/// <summary>
	/// 엔티티 삽입
	/// </summary>
	Insert,

	/// <summary>
	/// 엔티티 컬렉션 삽입
	/// </summary>
	InsertMany,

	/// <summary>
	/// 엔티티 갱신
	/// </summary>
	Update,

	/// <summary>
	/// 엔티티 컬렉션 갱신
	/// </summary>
	UpdateMany,

	/// <summary>
	/// 엔티티 삭제
	/// </summary>
	Delete,

	/// <summary>
	/// 엔티티 컬렉션 삭제
	/// </summary>
	DeleteMany
}

/// <summary>
/// 데이터 액세스 레이어 클래스임을 지시
/// </summary>
[AttributeUsage(AttributeTargets.Class)]
public class DataAttribute : Attribute
{
}

/// <summary>
/// 서버 캐시를 사용하도록 지시
/// </summary>
[AttributeUsage(AttributeTargets.Class)]
public class ForCacheAttribute : Attribute
{
}

/// <summary>
/// 서비스 메서드를 만들 것을 지시
/// </summary>
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method)]
public class ForServiceAttribute : Attribute
{
}

/// <summary>
/// 비동기 호출 코드를 생성할 것을 지시
/// </summary>
[AttributeUsage(AttributeTargets.Method, Inherited = false)]
public class ForAsyncAttribute : Attribute
{
}

/// <summary>
/// 비지니스 코드를 생성하지 말것을 지시
/// </summary>
[AttributeUsage(AttributeTargets.Method)]
public class ForCustomBizAttribute : Attribute
{
}

/// <summary>
/// 외래키를 조건으로 하는 Get 메서드 임을 지시
/// </summary>
[AttributeUsage(AttributeTargets.Method)]
public class ByFKAttribute : Attribute
{
}

/// <summary>
/// 인증이 필요하지 않은 메서드임을 표현
/// </summary>
[AttributeUsage(AttributeTargets.Method)]
public class NoAuthorizationAttribute : Attribute
{
}
#endregion

#region DaoBase
/// <summary>
/// Dao의 부모. Dao를 확장하는 용도로 사용한다.
/// </summary>
public partial class DaoBase
{
}
#endregion

#region Dao
/// <summary>
/// 각 엔터티 데이터 객체의 모음
/// </summary>
public partial class Dao : DaoBase
{
	static Dao()
	{
				Album = new AlbumDao();
		Artist = new ArtistDao();
		Company = new CompanyDao();
		Playlist = new PlaylistDao();
		PlaylistTrack = new PlaylistTrackDao();
		PlaylistTrackHistory = new PlaylistTrackHistoryDao();
		Track = new TrackDao();
	}

	#region Data objects
		public static AlbumDao Album { get; }
	public static ArtistDao Artist { get; }
	public static CompanyDao Company { get; }
	public static PlaylistDao Playlist { get; }
	public static PlaylistTrackDao PlaylistTrack { get; }
	public static PlaylistTrackHistoryDao PlaylistTrackHistory { get; }
	public static TrackDao Track { get; }
	#endregion
	}
#endregion

#region ChinookContextLoggerFactory
/// <summary>
/// 간단하게 사용할 수 있는 엔터티 프레임워크 코어용 로거 팩토리. Console과 Debug의 출력창 혹은 파일에 저장 할 수 있음
/// </summary>
internal class ChinookContextLoggerFactory : LoggerFactory
{
    #region singleton
    private static ChinookContextLoggerFactory _instance;

    public static ChinookContextLoggerFactory GetInstance(params LogPath[] loggerTypes) => GetInstance(loggerTypes.Select(x => x.ToString()).ToArray());

    public static ChinookContextLoggerFactory GetInstance(params string[] logPathes)
    {
        if (_instance == null)
        {
            List<ILoggerProvider> logProviders = new List<ILoggerProvider>(logPathes.Select(x => new LogProvider(x)));
            _instance = new ChinookContextLoggerFactory(logProviders);
        }

        return _instance;
    }

    private ChinookContextLoggerFactory(List<ILoggerProvider> providers) : base(providers)
    {
    }

    #endregion

    internal class LogProvider : ILoggerProvider
    {
        public LogProvider(string logPath) => _logPath = logPath;

        private string _logPath;

        public void Dispose()
        {
        }

        public ILogger CreateLogger(string categoryName)
        {
            return new Logger(categoryName, _logPath);
        }
    }

    internal class Logger : ILogger
    {
        private readonly IWriter _writer;

        private readonly string _categoryName;

        public Logger(string categoryName, string logPath)
        {
            _categoryName = categoryName;

            _writer = logPath switch
            {
                nameof(LogPath.Console) => new ConsoleWriter(),
                nameof(LogPath.Debug) => new DebugWriter(),
                _ => new FileWriter(logPath),
            };

            if (_counters.ContainsKey(_writer.UniqueName) is false)
                _counters.TryAdd(_writer.UniqueName, 0);
        }

        private static System.Collections.Concurrent.ConcurrentDictionary<string, int> _counters = new();

        public void Log<TState>(LogLevel logLevel, EventId eventId, TState state, Exception exception, Func<TState, Exception, string> formatter)
        {
            _writer.Open();
            _writer.WriteLine($"[{_counters[_writer.UniqueName]++:N0}] {DateTime.Now:s}");
            _writer.WriteLine(formatter(state, exception));
            _writer.WriteLine("--------------------------------------------------");
            _writer.WriteLine(Environment.NewLine);
            _writer.Save();
        }

        public bool IsEnabled(LogLevel logLevel)
        {
            return logLevel == LogLevel.Information &&
                    _categoryName == DbLoggerCategory.Database.Command.Name;
        }

        public IDisposable BeginScope<TState>(TState state)
        {
            return null;
        }
    }

    public interface IWriter
    {
        string UniqueName { get; }

        void WriteLine(string format, params object[] args);

        void Open()
        {
        }

        void Save()
        {
        }
    }

    internal class ConsoleWriter : IWriter
    {
        public string UniqueName => nameof(ConsoleWriter);

        public void WriteLine(string format, params object[] args) => Console.WriteLine(format, args);
    }

    internal class DebugWriter : IWriter
    {
        public string UniqueName => nameof(DebugWriter);

        public void WriteLine(string format, params object[] args) => Debug.WriteLine(format, args);
    }

    internal class FileWriter : IWriter
    {
        private readonly string _logFilePath;

        public string UniqueName => _logFilePath;

        public FileWriter(string logFilePath)
        {
            _logFilePath = logFilePath;
        }

        private readonly StringBuilder _builder = new StringBuilder();

        public void WriteLine(string format, params object[] args)
        {
            _builder.AppendFormat(format, args);
            _builder.AppendLine();
        }

        public void Open()
        {
            _builder.Clear();
        }

        public void Save()
        {
            File.AppendAllText(_logFilePath, _builder.ToString());
        }
    }
}

internal enum LogPath
{
    /// <summary>
    /// 콘솔에 출력
    /// </summary>
    Console,
    /// <summary>
    /// 디버거 창에 출력
    /// </summary>
    Debug,
}
#endregion