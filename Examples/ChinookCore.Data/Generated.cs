
/*
This file has been generated by UsingEntityFrameworkCore on 2022-06-09 오후 5:14:36.
You may not need to modify this file.
*/

#region
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
#endregion

namespace ChinookCore.Data
{
	#region Entities

    #region IEntity
    public partial interface IEntity
    {
    }
    #endregion

	#region Untyped Entity
	/// <summary>
	///   모든 엔터티 클래스의 부모 클래스
	/// </summary>
	public abstract partial class UntypedEntity : IEntity
	{
		/// <summary>
		///   부가정보를 저장하기 위한 object 객체
		/// </summary>
		[NotMapped]
		public object EntityTag { get; set; }

		/// <summary>
		///   모든 속성의 값을 초기화한다.string형 속성은 string.Empty 값으로 채우고, DateTime형 속성은 DateTime.Today 값으로 채운다.
		/// </summary>
		/// <returns> 생성된 엔터티 </returns>
		public void Clear()
		{
			Clear(string.Empty, DateTime.Today);
		}

		/// <summary>
		///   모든 속성의 값을 초기화한다. string형 속성은 string.Empty 값으로 채우고, DateTime형 속성은 기본 DateTime 값으로 채운다.
		/// </summary>
		/// <param name="defaultDateTime"> 기본 DateTime 값 </param>
		/// <returns> 생성된 엔터티 </returns>
		public void Clear(DateTime defaultDateTime)
		{
			Clear(string.Empty, defaultDateTime);
		}

		/// <summary>
		///   모든 속성의 값을 초기화한다. string형 속성은 기본 string 값으로 채우고, DateTime형 속성은 기본 DateTime 값으로 채운다.
		/// </summary>
		/// <param name="defaultString"> 기본 string 값 </param>
		/// <param name="defaultDateTime"> 기본 DateTime 값 </param>
		/// <returns> 생성된 엔터티 </returns>
		public void Clear(string defaultString, DateTime defaultDateTime)
		{
			Type type = GetType();
			PropertyInfo[] propertyInfoArray = type.GetProperties(BindingFlags.Instance | BindingFlags.Public);

			foreach (PropertyInfo propertyInfo in propertyInfoArray)
			{
				if (propertyInfo.CanWrite == false)
					continue;

				if (propertyInfo.PropertyType == typeof (string))
					propertyInfo.SetValue(this, defaultString, null);

				else if (propertyInfo.PropertyType == typeof (DateTime))
					propertyInfo.SetValue(this, defaultDateTime, null);
			}
		}

		/// <summary>
		///   기본키 값들을 구분자(":")로 연결하여 반환한다.
		/// </summary>
		/// <returns> </returns>
		public abstract string PrimaryKeyValues {get;}

		/// <summary>
		/// 엔터티를 대표하는 문자열을 구한다.
		/// </summary>
		public abstract string EntityText { get; }

		/// <summary>
		///   엔터티의 이름을 구한다.
		/// </summary>
		public abstract string GetEntityTypeName();

		partial void IsLogWritable(ref bool? logWritable);

		public virtual bool LogWritable
		{
			get
			{
			bool? logWritable = null;
			IsLogWritable(ref logWritable);

			if (logWritable.HasValue)
				return logWritable.Value;

			return false;
			}
		}

		/// <summary>
		///   EntityLog에 찍힐 문자열을 구한다. Code로 끝나는 코드 프로퍼티의 경우 대응하는 문자열 프로퍼티의 값도 추가한다.
		///   주의) EntityLog 테이블의 설계 상 최대 2000자 까지만 저장할 수 있음.
		/// </summary>
		/// <returns> </returns>
		public virtual string ToEntityLog()
		{
			const int MaxLength = 2000; // 최대 2000자 까지만 저장.

			Type type = GetType();

			var propertyInfoes = type.GetProperties();

			StringBuilder builder = new StringBuilder(ToString());

			builder.AppendLine();
			foreach (var propertyInfo in propertyInfoes)
			{
				if (propertyInfo.PropertyType != typeof (int))
					continue;

				if (propertyInfo.Name.EndsWith("Code") == false)
					continue;

				string textPropertyName = propertyInfo.Name.Substring(0, propertyInfo.Name.Length - 4) + "Text";
				string textValue = GetTextFromCodeProperty(this, type, textPropertyName);

				if (textValue != null)
					builder.AppendFormat("[{0}] {1}{2}", textPropertyName, textValue, Environment.NewLine);
			}

			if (builder.Length > MaxLength)
				return builder.ToString(0, MaxLength);
			else
				return builder.ToString();
		}

		private static string GetTextFromCodeProperty(object entity, Type objectType, string textPropertyName)
		{
			var propertyInfo = objectType.GetProperty(textPropertyName);
			object propertyValue = propertyInfo.GetValue(entity, null);

			if (propertyValue is string)
				return (string) propertyValue;
			else
				return null;
		}
	}
	#endregion

	#region Entity<T>
	/// <summary>
	/// 모든 엔터티 클래스의 형이 지정된 부모 클래스
	/// </summary>
	/// <typeparam name="T">엔터티 클래스의 형식</typeparam>
	public abstract partial class Entity<T> : UntypedEntity, IEditableObject where T : class, new()
	{
		/// <summary>
		/// 객체를 복사한다.
		/// </summary>
		/// <returns></returns>
		public abstract T Clone();

		#region Implementation of IEditableObject

		protected T _clone = null;

		/// <summary>
		/// IEditableObject.BeginEdit 구현
		/// </summary>
		public void BeginEdit()
		{
			if (_clone == null)
				_clone = Clone();
		}

		/// <summary>
		/// IEditableObject.EndEdit 구현
		/// </summary>
		public void EndEdit()
		{
			_clone = null;
		}

		public abstract void CancelEdit();

	#endregion
	}

	#endregion

		#region Album
    /// <summary>
	/// Album 엔터티
	/// </summary>
    public partial class Album : Entity<Album>, IEntity
	{
		public const string EntityTypeName = "Album";

		public static void Copy(Album source, Album target)
		{
						target.AlbumId = source.AlbumId;		
			target.ArtistId = source.ArtistId;		
			target.Title = source.Title;
		}

		/// <summary>
		/// Album 객체를 복사한다.
		/// </summary>
		/// <returns></returns>
		public override Album Clone()
		{
			var clone = new Album();

			Copy(this, clone);

			return clone;
		}

		partial void GetEntityTextCore(ref string value);

		/// <summary>
		/// Album 객체를 대표하는 이름을 구한다.
		/// </summary>
		/// <returns></returns>
		public override string EntityText
		{
			get 
			{ 
				string value = null;
				GetEntityTextCore(ref value);

				if (value != null)
					return value;

				return PrimaryKeyValues; 
			}
		}

		partial void ToStringCore(ref string value);

		public override string ToString()
		{
			string value = null;
			ToStringCore(ref value);

			if (value != null)
				return value;

			return "[AlbumId]" + AlbumId + ", " + "[ArtistId]" + ArtistId + ", " + "[Title]" + Title;
		}

		/// <summary>
		/// IEditableObject.CancelEdit 구현
		/// </summary>
		public override void CancelEdit()
		{
			if (_clone != null)
				Copy(_clone, this);
		}

		public override string PrimaryKeyValues
		{
			get { return string.Join(":", AlbumId); }
		}

		public override string GetEntityTypeName()
		{
			return EntityTypeName;
		}
	}

	/// <summary>
	/// Album 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
	/// </summary>
	public enum AlbumColumn
	{
				AlbumId,
		ArtistId,
		Title
	}

	
	/// <summary>
	/// Album 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer<Album> 구현)
	/// </summary>
	public class AlbumEqualityComparer : IEqualityComparer<Album>
	{
		public bool Equals(Album x, Album y)
		{
			return x.AlbumId == y.AlbumId;
		}

		public int GetHashCode(Album obj)
		{
			return obj.AlbumId.GetHashCode();
		}
	}
	
	#endregion
	#region Artist
    /// <summary>
	/// Artist 엔터티
	/// </summary>
    public partial class Artist : Entity<Artist>, IEntity
	{
		public const string EntityTypeName = "Artist";

		public static void Copy(Artist source, Artist target)
		{
						target.ArtistId = source.ArtistId;		
			target.Name = source.Name;
		}

		/// <summary>
		/// Artist 객체를 복사한다.
		/// </summary>
		/// <returns></returns>
		public override Artist Clone()
		{
			var clone = new Artist();

			Copy(this, clone);

			return clone;
		}

		partial void GetEntityTextCore(ref string value);

		/// <summary>
		/// Artist 객체를 대표하는 이름을 구한다.
		/// </summary>
		/// <returns></returns>
		public override string EntityText
		{
			get 
			{ 
				string value = null;
				GetEntityTextCore(ref value);

				if (value != null)
					return value;

				return PrimaryKeyValues; 
			}
		}

		partial void ToStringCore(ref string value);

		public override string ToString()
		{
			string value = null;
			ToStringCore(ref value);

			if (value != null)
				return value;

			return "[ArtistId]" + ArtistId + ", " + "[Name]" + Name;
		}

		/// <summary>
		/// IEditableObject.CancelEdit 구현
		/// </summary>
		public override void CancelEdit()
		{
			if (_clone != null)
				Copy(_clone, this);
		}

		public override string PrimaryKeyValues
		{
			get { return string.Join(":", ArtistId); }
		}

		public override string GetEntityTypeName()
		{
			return EntityTypeName;
		}
	}

	/// <summary>
	/// Artist 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
	/// </summary>
	public enum ArtistColumn
	{
				ArtistId,
		Name
	}

	
	/// <summary>
	/// Artist 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer<Artist> 구현)
	/// </summary>
	public class ArtistEqualityComparer : IEqualityComparer<Artist>
	{
		public bool Equals(Artist x, Artist y)
		{
			return x.ArtistId == y.ArtistId;
		}

		public int GetHashCode(Artist obj)
		{
			return obj.ArtistId.GetHashCode();
		}
	}
	
	#endregion
	#region Customer
    /// <summary>
	/// Customer 엔터티
	/// </summary>
    public partial class Customer : Entity<Customer>, IEntity
	{
		public const string EntityTypeName = "Customer";

		public static void Copy(Customer source, Customer target)
		{
						target.CustomerId = source.CustomerId;		
			target.Address = source.Address;		
			target.City = source.City;		
			target.Company = source.Company;		
			target.Country = source.Country;		
			target.Email = source.Email;		
			target.Fax = source.Fax;		
			target.FirstName = source.FirstName;		
			target.LastName = source.LastName;		
			target.Phone = source.Phone;		
			target.PostalCode = source.PostalCode;		
			target.State = source.State;		
			target.SupportRepId = source.SupportRepId;
		}

		/// <summary>
		/// Customer 객체를 복사한다.
		/// </summary>
		/// <returns></returns>
		public override Customer Clone()
		{
			var clone = new Customer();

			Copy(this, clone);

			return clone;
		}

		partial void GetEntityTextCore(ref string value);

		/// <summary>
		/// Customer 객체를 대표하는 이름을 구한다.
		/// </summary>
		/// <returns></returns>
		public override string EntityText
		{
			get 
			{ 
				string value = null;
				GetEntityTextCore(ref value);

				if (value != null)
					return value;

				return PrimaryKeyValues; 
			}
		}

		partial void ToStringCore(ref string value);

		public override string ToString()
		{
			string value = null;
			ToStringCore(ref value);

			if (value != null)
				return value;

			return "[CustomerId]" + CustomerId + ", " + "[Address]" + Address + ", " + "[City]" + City + ", " + "[Company]" + Company + ", " + "[Country]" + Country + ", " + "[Email]" + Email + ", " + "[Fax]" + Fax + ", " + "[FirstName]" + FirstName + ", " + "[LastName]" + LastName + ", " + "[Phone]" + Phone + ", " + "[PostalCode]" + PostalCode + ", " + "[State]" + State + ", " + "[SupportRepId]" + SupportRepId;
		}

		/// <summary>
		/// IEditableObject.CancelEdit 구현
		/// </summary>
		public override void CancelEdit()
		{
			if (_clone != null)
				Copy(_clone, this);
		}

		public override string PrimaryKeyValues
		{
			get { return string.Join(":", CustomerId); }
		}

		public override string GetEntityTypeName()
		{
			return EntityTypeName;
		}
	}

	/// <summary>
	/// Customer 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
	/// </summary>
	public enum CustomerColumn
	{
				CustomerId,
		Address,
		City,
		Company,
		Country,
		Email,
		Fax,
		FirstName,
		LastName,
		Phone,
		PostalCode,
		State,
		SupportRepId
	}

	
	/// <summary>
	/// Customer 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer<Customer> 구현)
	/// </summary>
	public class CustomerEqualityComparer : IEqualityComparer<Customer>
	{
		public bool Equals(Customer x, Customer y)
		{
			return x.CustomerId == y.CustomerId;
		}

		public int GetHashCode(Customer obj)
		{
			return obj.CustomerId.GetHashCode();
		}
	}
	
	#endregion
	#region Employee
    /// <summary>
	/// Employee 엔터티
	/// </summary>
    public partial class Employee : Entity<Employee>, IEntity
	{
		public const string EntityTypeName = "Employee";

		public static void Copy(Employee source, Employee target)
		{
						target.EmployeeId = source.EmployeeId;		
			target.Address = source.Address;		
			target.BirthDate = source.BirthDate;		
			target.City = source.City;		
			target.Country = source.Country;		
			target.Email = source.Email;		
			target.Fax = source.Fax;		
			target.FirstName = source.FirstName;		
			target.HireDate = source.HireDate;		
			target.LastName = source.LastName;		
			target.Phone = source.Phone;		
			target.PostalCode = source.PostalCode;		
			target.ReportsTo = source.ReportsTo;		
			target.State = source.State;		
			target.Title = source.Title;
		}

		/// <summary>
		/// Employee 객체를 복사한다.
		/// </summary>
		/// <returns></returns>
		public override Employee Clone()
		{
			var clone = new Employee();

			Copy(this, clone);

			return clone;
		}

		partial void GetEntityTextCore(ref string value);

		/// <summary>
		/// Employee 객체를 대표하는 이름을 구한다.
		/// </summary>
		/// <returns></returns>
		public override string EntityText
		{
			get 
			{ 
				string value = null;
				GetEntityTextCore(ref value);

				if (value != null)
					return value;

				return PrimaryKeyValues; 
			}
		}

		partial void ToStringCore(ref string value);

		public override string ToString()
		{
			string value = null;
			ToStringCore(ref value);

			if (value != null)
				return value;

			return "[EmployeeId]" + EmployeeId + ", " + "[Address]" + Address + ", " + "[BirthDate]" + BirthDate + ", " + "[City]" + City + ", " + "[Country]" + Country + ", " + "[Email]" + Email + ", " + "[Fax]" + Fax + ", " + "[FirstName]" + FirstName + ", " + "[HireDate]" + HireDate + ", " + "[LastName]" + LastName + ", " + "[Phone]" + Phone + ", " + "[PostalCode]" + PostalCode + ", " + "[ReportsTo]" + ReportsTo + ", " + "[State]" + State + ", " + "[Title]" + Title;
		}

		/// <summary>
		/// IEditableObject.CancelEdit 구현
		/// </summary>
		public override void CancelEdit()
		{
			if (_clone != null)
				Copy(_clone, this);
		}

		public override string PrimaryKeyValues
		{
			get { return string.Join(":", EmployeeId); }
		}

		public override string GetEntityTypeName()
		{
			return EntityTypeName;
		}
	}

	/// <summary>
	/// Employee 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
	/// </summary>
	public enum EmployeeColumn
	{
				EmployeeId,
		Address,
		BirthDate,
		City,
		Country,
		Email,
		Fax,
		FirstName,
		HireDate,
		LastName,
		Phone,
		PostalCode,
		ReportsTo,
		State,
		Title
	}

	
	/// <summary>
	/// Employee 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer<Employee> 구현)
	/// </summary>
	public class EmployeeEqualityComparer : IEqualityComparer<Employee>
	{
		public bool Equals(Employee x, Employee y)
		{
			return x.EmployeeId == y.EmployeeId;
		}

		public int GetHashCode(Employee obj)
		{
			return obj.EmployeeId.GetHashCode();
		}
	}
	
	#endregion
	#region Genre
    /// <summary>
	/// Genre 엔터티
	/// </summary>
    public partial class Genre : Entity<Genre>, IEntity
	{
		public const string EntityTypeName = "Genre";

		public static void Copy(Genre source, Genre target)
		{
						target.GenreId = source.GenreId;		
			target.Name = source.Name;
		}

		/// <summary>
		/// Genre 객체를 복사한다.
		/// </summary>
		/// <returns></returns>
		public override Genre Clone()
		{
			var clone = new Genre();

			Copy(this, clone);

			return clone;
		}

		partial void GetEntityTextCore(ref string value);

		/// <summary>
		/// Genre 객체를 대표하는 이름을 구한다.
		/// </summary>
		/// <returns></returns>
		public override string EntityText
		{
			get 
			{ 
				string value = null;
				GetEntityTextCore(ref value);

				if (value != null)
					return value;

				return PrimaryKeyValues; 
			}
		}

		partial void ToStringCore(ref string value);

		public override string ToString()
		{
			string value = null;
			ToStringCore(ref value);

			if (value != null)
				return value;

			return "[GenreId]" + GenreId + ", " + "[Name]" + Name;
		}

		/// <summary>
		/// IEditableObject.CancelEdit 구현
		/// </summary>
		public override void CancelEdit()
		{
			if (_clone != null)
				Copy(_clone, this);
		}

		public override string PrimaryKeyValues
		{
			get { return string.Join(":", GenreId); }
		}

		public override string GetEntityTypeName()
		{
			return EntityTypeName;
		}
	}

	/// <summary>
	/// Genre 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
	/// </summary>
	public enum GenreColumn
	{
				GenreId,
		Name
	}

	
	/// <summary>
	/// Genre 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer<Genre> 구현)
	/// </summary>
	public class GenreEqualityComparer : IEqualityComparer<Genre>
	{
		public bool Equals(Genre x, Genre y)
		{
			return x.GenreId == y.GenreId;
		}

		public int GetHashCode(Genre obj)
		{
			return obj.GenreId.GetHashCode();
		}
	}
	
	#endregion
	#region Invoice
    /// <summary>
	/// Invoice 엔터티
	/// </summary>
    public partial class Invoice : Entity<Invoice>, IEntity
	{
		public const string EntityTypeName = "Invoice";

		public static void Copy(Invoice source, Invoice target)
		{
						target.InvoiceId = source.InvoiceId;		
			target.BillingAddress = source.BillingAddress;		
			target.BillingCity = source.BillingCity;		
			target.BillingCountry = source.BillingCountry;		
			target.BillingPostalCode = source.BillingPostalCode;		
			target.BillingState = source.BillingState;		
			target.CustomerId = source.CustomerId;		
			target.InvoiceDate = source.InvoiceDate;		
			target.Total = source.Total;
		}

		/// <summary>
		/// Invoice 객체를 복사한다.
		/// </summary>
		/// <returns></returns>
		public override Invoice Clone()
		{
			var clone = new Invoice();

			Copy(this, clone);

			return clone;
		}

		partial void GetEntityTextCore(ref string value);

		/// <summary>
		/// Invoice 객체를 대표하는 이름을 구한다.
		/// </summary>
		/// <returns></returns>
		public override string EntityText
		{
			get 
			{ 
				string value = null;
				GetEntityTextCore(ref value);

				if (value != null)
					return value;

				return PrimaryKeyValues; 
			}
		}

		partial void ToStringCore(ref string value);

		public override string ToString()
		{
			string value = null;
			ToStringCore(ref value);

			if (value != null)
				return value;

			return "[InvoiceId]" + InvoiceId + ", " + "[BillingAddress]" + BillingAddress + ", " + "[BillingCity]" + BillingCity + ", " + "[BillingCountry]" + BillingCountry + ", " + "[BillingPostalCode]" + BillingPostalCode + ", " + "[BillingState]" + BillingState + ", " + "[CustomerId]" + CustomerId + ", " + "[InvoiceDate]" + InvoiceDate + ", " + "[Total]" + Total;
		}

		/// <summary>
		/// IEditableObject.CancelEdit 구현
		/// </summary>
		public override void CancelEdit()
		{
			if (_clone != null)
				Copy(_clone, this);
		}

		public override string PrimaryKeyValues
		{
			get { return string.Join(":", InvoiceId); }
		}

		public override string GetEntityTypeName()
		{
			return EntityTypeName;
		}
	}

	/// <summary>
	/// Invoice 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
	/// </summary>
	public enum InvoiceColumn
	{
				InvoiceId,
		BillingAddress,
		BillingCity,
		BillingCountry,
		BillingPostalCode,
		BillingState,
		CustomerId,
		InvoiceDate,
		Total
	}

	
	/// <summary>
	/// Invoice 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer<Invoice> 구현)
	/// </summary>
	public class InvoiceEqualityComparer : IEqualityComparer<Invoice>
	{
		public bool Equals(Invoice x, Invoice y)
		{
			return x.InvoiceId == y.InvoiceId;
		}

		public int GetHashCode(Invoice obj)
		{
			return obj.InvoiceId.GetHashCode();
		}
	}
	
	#endregion
	#region InvoiceLine
    /// <summary>
	/// InvoiceLine 엔터티
	/// </summary>
    public partial class InvoiceLine : Entity<InvoiceLine>, IEntity
	{
		public const string EntityTypeName = "InvoiceLine";

		public static void Copy(InvoiceLine source, InvoiceLine target)
		{
						target.InvoiceLineId = source.InvoiceLineId;		
			target.InvoiceId = source.InvoiceId;		
			target.Quantity = source.Quantity;		
			target.TrackId = source.TrackId;		
			target.UnitPrice = source.UnitPrice;
		}

		/// <summary>
		/// InvoiceLine 객체를 복사한다.
		/// </summary>
		/// <returns></returns>
		public override InvoiceLine Clone()
		{
			var clone = new InvoiceLine();

			Copy(this, clone);

			return clone;
		}

		partial void GetEntityTextCore(ref string value);

		/// <summary>
		/// InvoiceLine 객체를 대표하는 이름을 구한다.
		/// </summary>
		/// <returns></returns>
		public override string EntityText
		{
			get 
			{ 
				string value = null;
				GetEntityTextCore(ref value);

				if (value != null)
					return value;

				return PrimaryKeyValues; 
			}
		}

		partial void ToStringCore(ref string value);

		public override string ToString()
		{
			string value = null;
			ToStringCore(ref value);

			if (value != null)
				return value;

			return "[InvoiceLineId]" + InvoiceLineId + ", " + "[InvoiceId]" + InvoiceId + ", " + "[Quantity]" + Quantity + ", " + "[TrackId]" + TrackId + ", " + "[UnitPrice]" + UnitPrice;
		}

		/// <summary>
		/// IEditableObject.CancelEdit 구현
		/// </summary>
		public override void CancelEdit()
		{
			if (_clone != null)
				Copy(_clone, this);
		}

		public override string PrimaryKeyValues
		{
			get { return string.Join(":", InvoiceLineId); }
		}

		public override string GetEntityTypeName()
		{
			return EntityTypeName;
		}
	}

	/// <summary>
	/// InvoiceLine 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
	/// </summary>
	public enum InvoiceLineColumn
	{
				InvoiceLineId,
		InvoiceId,
		Quantity,
		TrackId,
		UnitPrice
	}

	
	/// <summary>
	/// InvoiceLine 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer<InvoiceLine> 구현)
	/// </summary>
	public class InvoiceLineEqualityComparer : IEqualityComparer<InvoiceLine>
	{
		public bool Equals(InvoiceLine x, InvoiceLine y)
		{
			return x.InvoiceLineId == y.InvoiceLineId;
		}

		public int GetHashCode(InvoiceLine obj)
		{
			return obj.InvoiceLineId.GetHashCode();
		}
	}
	
	#endregion
	#region MediaType
    /// <summary>
	/// MediaType 엔터티
	/// </summary>
    public partial class MediaType : Entity<MediaType>, IEntity
	{
		public const string EntityTypeName = "MediaType";

		public static void Copy(MediaType source, MediaType target)
		{
						target.MediaTypeId = source.MediaTypeId;		
			target.Name = source.Name;
		}

		/// <summary>
		/// MediaType 객체를 복사한다.
		/// </summary>
		/// <returns></returns>
		public override MediaType Clone()
		{
			var clone = new MediaType();

			Copy(this, clone);

			return clone;
		}

		partial void GetEntityTextCore(ref string value);

		/// <summary>
		/// MediaType 객체를 대표하는 이름을 구한다.
		/// </summary>
		/// <returns></returns>
		public override string EntityText
		{
			get 
			{ 
				string value = null;
				GetEntityTextCore(ref value);

				if (value != null)
					return value;

				return PrimaryKeyValues; 
			}
		}

		partial void ToStringCore(ref string value);

		public override string ToString()
		{
			string value = null;
			ToStringCore(ref value);

			if (value != null)
				return value;

			return "[MediaTypeId]" + MediaTypeId + ", " + "[Name]" + Name;
		}

		/// <summary>
		/// IEditableObject.CancelEdit 구현
		/// </summary>
		public override void CancelEdit()
		{
			if (_clone != null)
				Copy(_clone, this);
		}

		public override string PrimaryKeyValues
		{
			get { return string.Join(":", MediaTypeId); }
		}

		public override string GetEntityTypeName()
		{
			return EntityTypeName;
		}
	}

	/// <summary>
	/// MediaType 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
	/// </summary>
	public enum MediaTypeColumn
	{
				MediaTypeId,
		Name
	}

	
	/// <summary>
	/// MediaType 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer<MediaType> 구현)
	/// </summary>
	public class MediaTypeEqualityComparer : IEqualityComparer<MediaType>
	{
		public bool Equals(MediaType x, MediaType y)
		{
			return x.MediaTypeId == y.MediaTypeId;
		}

		public int GetHashCode(MediaType obj)
		{
			return obj.MediaTypeId.GetHashCode();
		}
	}
	
	#endregion
	#region Playlist
    /// <summary>
	/// Playlist 엔터티
	/// </summary>
    public partial class Playlist : Entity<Playlist>, IEntity
	{
		public const string EntityTypeName = "Playlist";

		public static void Copy(Playlist source, Playlist target)
		{
						target.PlaylistId = source.PlaylistId;		
			target.Name = source.Name;
		}

		/// <summary>
		/// Playlist 객체를 복사한다.
		/// </summary>
		/// <returns></returns>
		public override Playlist Clone()
		{
			var clone = new Playlist();

			Copy(this, clone);

			return clone;
		}

		partial void GetEntityTextCore(ref string value);

		/// <summary>
		/// Playlist 객체를 대표하는 이름을 구한다.
		/// </summary>
		/// <returns></returns>
		public override string EntityText
		{
			get 
			{ 
				string value = null;
				GetEntityTextCore(ref value);

				if (value != null)
					return value;

				return PrimaryKeyValues; 
			}
		}

		partial void ToStringCore(ref string value);

		public override string ToString()
		{
			string value = null;
			ToStringCore(ref value);

			if (value != null)
				return value;

			return "[PlaylistId]" + PlaylistId + ", " + "[Name]" + Name;
		}

		/// <summary>
		/// IEditableObject.CancelEdit 구현
		/// </summary>
		public override void CancelEdit()
		{
			if (_clone != null)
				Copy(_clone, this);
		}

		public override string PrimaryKeyValues
		{
			get { return string.Join(":", PlaylistId); }
		}

		public override string GetEntityTypeName()
		{
			return EntityTypeName;
		}
	}

	/// <summary>
	/// Playlist 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
	/// </summary>
	public enum PlaylistColumn
	{
				PlaylistId,
		Name
	}

	
	/// <summary>
	/// Playlist 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer<Playlist> 구현)
	/// </summary>
	public class PlaylistEqualityComparer : IEqualityComparer<Playlist>
	{
		public bool Equals(Playlist x, Playlist y)
		{
			return x.PlaylistId == y.PlaylistId;
		}

		public int GetHashCode(Playlist obj)
		{
			return obj.PlaylistId.GetHashCode();
		}
	}
	
	#endregion
	#region PlaylistTrack
    /// <summary>
	/// PlaylistTrack 엔터티
	/// </summary>
    public partial class PlaylistTrack : Entity<PlaylistTrack>, IEntity
	{
		public const string EntityTypeName = "PlaylistTrack";

		public static void Copy(PlaylistTrack source, PlaylistTrack target)
		{
						target.PlaylistId = source.PlaylistId;		
			target.TrackId = source.TrackId;		
			target.Dummy = source.Dummy;
		}

		/// <summary>
		/// PlaylistTrack 객체를 복사한다.
		/// </summary>
		/// <returns></returns>
		public override PlaylistTrack Clone()
		{
			var clone = new PlaylistTrack();

			Copy(this, clone);

			return clone;
		}

		partial void GetEntityTextCore(ref string value);

		/// <summary>
		/// PlaylistTrack 객체를 대표하는 이름을 구한다.
		/// </summary>
		/// <returns></returns>
		public override string EntityText
		{
			get 
			{ 
				string value = null;
				GetEntityTextCore(ref value);

				if (value != null)
					return value;

				return PrimaryKeyValues; 
			}
		}

		partial void ToStringCore(ref string value);

		public override string ToString()
		{
			string value = null;
			ToStringCore(ref value);

			if (value != null)
				return value;

			return "[PlaylistId]" + PlaylistId + ", " + "[TrackId]" + TrackId + ", " + "[Dummy]" + Dummy;
		}

		/// <summary>
		/// IEditableObject.CancelEdit 구현
		/// </summary>
		public override void CancelEdit()
		{
			if (_clone != null)
				Copy(_clone, this);
		}

		public override string PrimaryKeyValues
		{
			get { return string.Join(":", PlaylistId, TrackId); }
		}

		public override string GetEntityTypeName()
		{
			return EntityTypeName;
		}
	}

	/// <summary>
	/// PlaylistTrack 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
	/// </summary>
	public enum PlaylistTrackColumn
	{
				PlaylistId,
		TrackId,
		Dummy
	}

	
	/// <summary>
	/// PlaylistTrack 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer<PlaylistTrack> 구현)
	/// </summary>
	public class PlaylistTrackEqualityComparer : IEqualityComparer<PlaylistTrack>
	{
		public bool Equals(PlaylistTrack x, PlaylistTrack y)
		{
			return x.PlaylistId == y.PlaylistId && x.TrackId == y.TrackId;
		}

		public int GetHashCode(PlaylistTrack obj)
		{
			return obj.PlaylistId.GetHashCode() ^ obj.TrackId.GetHashCode();
		}
	}
	
	#endregion
	#region Track
    /// <summary>
	/// Track 엔터티
	/// </summary>
    public partial class Track : Entity<Track>, IEntity
	{
		public const string EntityTypeName = "Track";

		public static void Copy(Track source, Track target)
		{
						target.TrackId = source.TrackId;		
			target.AlbumId = source.AlbumId;		
			target.Bytes = source.Bytes;		
			target.Composer = source.Composer;		
			target.GenreId = source.GenreId;		
			target.MediaTypeId = source.MediaTypeId;		
			target.Milliseconds = source.Milliseconds;		
			target.Name = source.Name;		
			target.UnitPrice = source.UnitPrice;
		}

		/// <summary>
		/// Track 객체를 복사한다.
		/// </summary>
		/// <returns></returns>
		public override Track Clone()
		{
			var clone = new Track();

			Copy(this, clone);

			return clone;
		}

		partial void GetEntityTextCore(ref string value);

		/// <summary>
		/// Track 객체를 대표하는 이름을 구한다.
		/// </summary>
		/// <returns></returns>
		public override string EntityText
		{
			get 
			{ 
				string value = null;
				GetEntityTextCore(ref value);

				if (value != null)
					return value;

				return PrimaryKeyValues; 
			}
		}

		partial void ToStringCore(ref string value);

		public override string ToString()
		{
			string value = null;
			ToStringCore(ref value);

			if (value != null)
				return value;

			return "[TrackId]" + TrackId + ", " + "[AlbumId]" + AlbumId + ", " + "[Bytes]" + Bytes + ", " + "[Composer]" + Composer + ", " + "[GenreId]" + GenreId + ", " + "[MediaTypeId]" + MediaTypeId + ", " + "[Milliseconds]" + Milliseconds + ", " + "[Name]" + Name + ", " + "[UnitPrice]" + UnitPrice;
		}

		/// <summary>
		/// IEditableObject.CancelEdit 구현
		/// </summary>
		public override void CancelEdit()
		{
			if (_clone != null)
				Copy(_clone, this);
		}

		public override string PrimaryKeyValues
		{
			get { return string.Join(":", TrackId); }
		}

		public override string GetEntityTypeName()
		{
			return EntityTypeName;
		}
	}

	/// <summary>
	/// Track 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
	/// </summary>
	public enum TrackColumn
	{
				TrackId,
		AlbumId,
		Bytes,
		Composer,
		GenreId,
		MediaTypeId,
		Milliseconds,
		Name,
		UnitPrice
	}

	
	/// <summary>
	/// Track 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer<Track> 구현)
	/// </summary>
	public class TrackEqualityComparer : IEqualityComparer<Track>
	{
		public bool Equals(Track x, Track y)
		{
			return x.TrackId == y.TrackId;
		}

		public int GetHashCode(Track obj)
		{
			return obj.TrackId.GetHashCode();
		}
	}
	
	#endregion

	#endregion

	#region PropertyChangedEventArgs
	/// <summary>
	/// 속성 값이 변경된 후 발생하는 이벤트의 매개변수 클래스
	/// </summary>
	/// <typeparam name="T"></typeparam>
	internal class PropertyChangedEventArgs<T> : EventArgs where T : Entity<T>, new()
	{
		/// <summary>
		/// 속성 값이 변경된 엔티티
		/// </summary>
		public T Entity { get; set; }

		public PropertyChangedEventArgs(T entity)
		{
			Entity = entity;
		}
	}

	/// <summary>
	/// 속성 값이 변경되기 전 발생하는 이벤트의 매개변수 클래스
	/// </summary>
	/// <typeparam name="T"></typeparam>
	/// <typeparam name="K"></typeparam>
	internal class PropertyChangingEventArgs<T, K> : EventArgs where T : Entity<T>, new()
	{
		/// <summary>
		/// 속성 값이 변경될 엔티티
		/// </summary>
		public T Entity { get; set; }

		/// <summary>
		/// 새로 변경 될 속성 값
		/// </summary>
		public K Value { get; set; }

		public PropertyChangingEventArgs(T entity, K value)
		{
			Entity = entity;
			Value = value;
		}
	}
	#endregion

	#region Data
	#region EntityDao<T>
	[Data]
	public abstract partial class EntityDao<T> where T : Entity<T>, new()
	{
		internal EntityDao() { }

		#region Create
		/// <summary>
		/// 엔터티를 생성한다. string형 속성은 string.Empty 값으로 채우고, DateTime형 속성은 DateTime.Today 값으로 채운다.
		/// </summary>
		/// <returns>생성된 엔터티</returns>
		public virtual T Create()
		{
			return Create(string.Empty, DateTime.Today);
		}

		/// <summary>
		/// 엔터티를 생성한다. string형 속성은 string.Empty 값으로 채우고, DateTime형 속성은 기본 DateTime 값으로 채운다.
		/// </summary>
		/// <param name="defaultDateTime">기본 DateTime 값</param>
		/// <returns>생성된 엔터티</returns>
		public virtual T Create(DateTime defaultDateTime)
		{
			return Create(string.Empty, defaultDateTime);
		}

		/// <summary>
		/// 엔터티를 생성한다. string형 속성은 기본 string 값으로 채우고, DateTime형 속성은 기본 DateTime 값으로 채운다.
		/// </summary>
		/// <param name="defaultString">기본 string 값</param>
		/// <param name="defaultDateTime">기본 DateTime 값</param>
		/// <returns>생성된 엔터티</returns>
		public virtual T Create(string defaultString, DateTime defaultDateTime)
		{
			T entity = new T();
			entity.Clear(defaultString, defaultDateTime);

			return entity;
		}
		#endregion

		#region Get
		/// <summary>
		/// 모든 엔터티를 반환한다.
		/// </summary>
		/// <returns>엔터티의 리스트</returns>
        public virtual List<T> Get()
		{
			return Get<T>(null, null, false, 0, int.MaxValue);
		}

        public virtual Task<List<T>> GetAsync() 
            => Task.Factory.StartNew(() => Get());

        /// <summary>
        /// 조건식에 맞는 엔터티들을 반환한다.
        /// </summary>
        /// <param name="where">조건식</param>
        /// <returns>엔터티의 리스트</returns>
        public virtual List<T> Get(Expression<Func<T, bool>> where)
		{
			return Get<T>(where, null, false, 0, int.MaxValue);
		}

        public virtual Task<List<T>> GetAsync(Expression<Func<T, bool>> where)
            => Task.Factory.StartNew(() => Get(where));

		/// <summary>
		/// 모든 엔터티들을 정렬식에 따라 정렬한 후 반환한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
		/// </summary>
		/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
		/// <param name="orderBy">정렬식</param>
		/// <param name="ascending">true이면 오름차순, false이면 내림차순</param>
		/// <returns>엔터티의 리스트</returns>
        public virtual List<T> Get<U>(Expression<Func<T, U>> orderBy, bool ascending)
		{
			return Get(null, orderBy, ascending, 0, int.MaxValue);
		}

        public virtual Task<List<T>> GetAsync<U>(Expression<Func<T, U>> orderBy, bool ascending)
            => Task.Factory.StartNew(() => Get(orderBy, ascending));

		/// <summary>
		/// 조건식에 맞는 엔터티들을 정렬식에 따라 정렬한 후 반환한다. 페이징을 지원한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
		/// </summary>
		/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
		/// <param name="orderBy">정렬식</param>
		/// <param name="ascending">true이면 오름차순, false이면 내림차순</param>
		/// <param name="startRowIndex">반환할 엔터티의 시작 인덱스</param>
		/// <param name="maximumRows">반환할 엔터티의 갯수</param>
		/// <returns>엔터티의 리스트</returns>
        public virtual List<T> Get<U>(Expression<Func<T, U>> orderBy, bool ascending, int startRowIndex, int maximumRows)
		{
			return Get(null, orderBy, ascending, startRowIndex, maximumRows);
		}

        public virtual Task<List<T>> GetAsync<U>(Expression<Func<T, U>> orderBy, bool ascending, int startRowIndex, int maximumRows)
            => Task.Factory.StartNew(() => Get(orderBy, ascending, startRowIndex, maximumRows));

		/// <summary>
		/// 조건식에 맞는 엔터티들을 정렬식에 따라 정렬한 후 반환한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
		/// </summary>
		/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
		/// <param name="where">조건식</param>
		/// <param name="orderBy">정렬식</param>
		/// <param name="ascending">true이면 오름차순, false이면 내림차순</param>
		/// <returns>엔터티의 리스트</returns>
        public virtual List<T> Get<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending)
		{
			return Get(where, orderBy, ascending, 0, int.MaxValue);
		}

        public virtual Task<List<T>> GetAsync<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending)
            => Task.Factory.StartNew(() => Get(where, orderBy, ascending));

		/// <summary>
		/// 조건식에 맞는 엔터티들을 정렬식에 따라 정렬한 후 반환한다. 페이징을 지원한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
		/// </summary>
		/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
		/// <param name="where">조건식</param>
		/// <param name="orderBy">정렬식</param>
		/// <param name="ascending">true이면 오름차순, false이면 내림차순</param>
		/// <param name="startRowIndex">반환할 엔터티의 시작 인덱스</param>
		/// <param name="maximumRows">반환할 엔터티의 갯수</param>
		/// <returns>엔터티의 리스트</returns>
        public virtual List<T> Get<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending, int startRowIndex, int maximumRows)
		{
            using var context = DbContextFactory.Create();

            return GetCore(where, orderBy, ascending, startRowIndex, maximumRows, context).ToList();
		}

        public virtual Task<List<T>> GetAsync<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending, int startRowIndex, int maximumRows)
            => Task.Factory.StartNew(() => Get(where, orderBy, ascending, startRowIndex, maximumRows));
		#endregion

		#region select
		/// <summary>
		///   모든 선택식의 결과를 반환한다.
		/// </summary>
		/// <typeparam name="R"> 선택 형식 </typeparam>
		/// <param name="select"> 선택식 </param>
		/// <returns> 엔터티의 리스트 </returns>
        public virtual List<R> Select<R>(Expression<Func<T, R>> select)
		{
			return Select<T, R>(null, null, false, 0, int.MaxValue, select);
		}

        public virtual Task<List<R>> SelectAsync<R>(Expression<Func<T, R>> select)
            => Task.Factory.StartNew(() => Select(select));

		/// <summary>
		///   조건식에 맞는 선택식의 결과를 반환한다.
		/// </summary>
		/// <typeparam name="R"> 선택 형식 </typeparam>
		/// <param name="where"> 조건식 </param>
		/// <param name="select"> 선택식 </param>
		/// <returns> 엔터티의 리스트 </returns>
        public virtual List<R> Select<R>(Expression<Func<T, bool>> where, Expression<Func<T, R>> select)
		{
			return Select<T, R>(where, null, false, 0, int.MaxValue, select);
		}

        public virtual Task<List<R>> SelectAsync<R>(Expression<Func<T, bool>> where, Expression<Func<T, R>> select)
            => Task.Factory.StartNew(() => Select(where, select));

		/// <summary>
		///   모든 엔터티들을 정렬식에 따라 정렬한 후 선택식의 결과를 반환한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
		/// </summary>
		/// <typeparam name="U"> 정렬 기준이 되는 속성의 형식 </typeparam>
		/// <typeparam name="R"> 선택 형식 </typeparam>
		/// <param name="orderBy"> 정렬식 </param>
		/// <param name="ascending"> true이면 오름차순, false이면 내림차순 </param>
		/// <param name="select"> 선택식 </param>
		/// <returns> 엔터티의 리스트 </returns>
        public virtual List<R> Select<U, R>(Expression<Func<T, U>> orderBy, bool ascending, Expression<Func<T, R>> select)
		{
			return Select(null, orderBy, ascending, 0, int.MaxValue, select);
		}

        public virtual Task<List<R>> SelectAsync<U, R>(Expression<Func<T, U>> orderBy, bool ascending, Expression<Func<T, R>> select)
            => Task.Factory.StartNew(() => Select(orderBy, ascending, select));

		/// <summary>
		///   조건식에 맞는 엔터티들을 정렬식에 따라 정렬한 후 선택식의 결과를 반환한다. 페이징을 지원한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
		/// </summary>
		/// <typeparam name="U"> 정렬 기준이 되는 속성의 형식 </typeparam>
		/// <typeparam name="R"> 선택 형식 </typeparam>
		/// <param name="orderBy"> 정렬식 </param>
		/// <param name="ascending"> true이면 오름차순, false이면 내림차순 </param>
		/// <param name="startRowIndex"> 반환할 엔터티의 시작 인덱스 </param>
		/// <param name="maximumRows"> 반환할 엔터티의 갯수 </param>
		/// <param name="select"> 선택식 </param>
		/// <returns> 엔터티의 리스트 </returns>
        public virtual List<R> Select<U, R>(Expression<Func<T, U>> orderBy, bool ascending, int startRowIndex, int maximumRows, Expression<Func<T, R>> select)
		{
			return Select(null, orderBy, ascending, startRowIndex, maximumRows, select);
		}

        public virtual Task<List<R>> SelectAsync<U, R>(Expression<Func<T, U>> orderBy, bool ascending, int startRowIndex, int maximumRows, Expression<Func<T, R>> select)
            => Task.Factory.StartNew(() => Select(orderBy, ascending, startRowIndex, maximumRows, select));
		

		/// <summary>
		///   조건식에 맞는 엔터티들을 정렬식에 따라 정렬한 후 선택식의 결과를 반환한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
		/// </summary>
		/// <typeparam name="U"> 정렬 기준이 되는 속성의 형식 </typeparam>
		/// <typeparam name="R"> 선택 형식 </typeparam>
		/// <param name="where"> 조건식 </param>
		/// <param name="orderBy"> 정렬식 </param>
		/// <param name="ascending"> true이면 오름차순, false이면 내림차순 </param>
		/// <param name="select"> 선택식 </param>
		/// <returns> 엔터티의 리스트 </returns>
        public virtual List<R> Select<U, R>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending, Expression<Func<T, R>> select)
		{
			return Select(where, orderBy, ascending, 0, int.MaxValue, select);
		}

        public virtual Task<List<R>> SelectAsync<U, R>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending, Expression<Func<T, R>> select)
            => Task.Factory.StartNew(() => Select(where, orderBy, ascending, select));

		/// <summary>
		///   조건식에 맞는 엔터티들을 정렬식에 따라 정렬한 후 선택식의 결과를 반환한다. 페이징과 프로젝션을을 지원한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
		/// </summary>
		/// <typeparam name="U"> 정렬 기준이 되는 속성의 형식 </typeparam>
		/// <typeparam name="R"> 선택 형식 </typeparam>
		/// <param name="where"> 조건식 </param>
		/// <param name="orderBy"> 정렬식 </param>
		/// <param name="ascending"> true이면 오름차순, false이면 내림차순 </param>
		/// <param name="startRowIndex"> 반환할 엔터티의 시작 인덱스 </param>
		/// <param name="maximumRows"> 반환할 엔터티의 갯수 </param>
		/// <param name="select"> 선택식 </param>
		/// <returns> 엔터티의 리스트 </returns>
        public virtual List<R> Select<U, R>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending, int startRowIndex, int maximumRows, Expression<Func<T, R>> select)
		{
            using var context = DbContextFactory.Create();

				var query = GetCore(where, orderBy, ascending, startRowIndex, maximumRows, context);
				return query.Select(select).ToList();
		}

        public virtual Task<List<R>> SelectAsync<U, R>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending, int startRowIndex, int maximumRows, Expression<Func<T, R>> select)
            => Task.Factory.StartNew(() => Select(where, orderBy, ascending, startRowIndex, maximumRows, select));

		private static IQueryable<T> GetCore<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending, int startRowIndex, int maximumRows, ChinookContext context)
		{
			var query = from x in context.Set<T>()
						select x;

			if (where != null)
				query = query.Where(where);

			IOrderedQueryable<T> orderedQuery = null;

			if (orderBy != null)
				orderedQuery = (ascending) ? query.OrderBy(orderBy) : query.OrderByDescending(orderBy);

			if (startRowIndex != 0 || maximumRows != int.MaxValue)
			{
				if (orderedQuery != null)
					orderedQuery = (IOrderedQueryable<T>)orderedQuery.Skip(startRowIndex).Take(maximumRows);
				else
					query = query.Skip(startRowIndex).Take(maximumRows);
			}

			return orderedQuery ?? query;
		}
		#endregion

		#region GetFirst / GetLast
		/// <summary>
		/// 모든 엔터티 중 첫번째 엔터티를 반환한다. 엔터티의 순서는 DB에 의해 결정된다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
		/// </summary>
		/// <returns>엔터티</returns>
        public virtual T GetFirst()
		{
			return GetFirst<T>(null, null);
		}

        public virtual Task<T> GetFirstAsync()
            => Task.Factory.StartNew(() => GetFirst());

		/// <summary>
		/// 조건식에 맞는 엔터티 중 첫번째 엔터티를 반환한다. 엔터티의 순서는 DB에 의해 결정된다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
		/// </summary>
		/// <param name="where">조건식</param>
		/// <returns>엔터티</returns>
        public virtual T GetFirst(Expression<Func<T, bool>> where)
		{
			return GetFirst<T>(where, null);
		}

        public virtual Task<T> GetFirstAsync(Expression<Func<T, bool>> where) 
            => Task.Factory.StartNew(() => GetFirst(where));

        /// <summary>
		/// 모든 엔터티를 정렬식에 따라 정렬했을 때 첫번째 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
		/// </summary>
		/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
		/// <param name="orderBy">정렬식</param>
		/// <returns>엔터티</returns>
        public virtual T GetFirst<U>(Expression<Func<T, U>> orderBy)
		{
			return GetFirst(null, orderBy);
		}

        public virtual Task<T> GetFirstAsync<U>(Expression<Func<T, U>> orderBy)
            => Task.Factory.StartNew(() => GetFirst(orderBy));

		/// <summary>
		/// 조건식에 맞는 엔터티를 정렬식에 따라 정렬했을 때 첫번째 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
		/// </summary>
		/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
		/// <param name="where">조건식</param>
		/// <param name="orderBy">정렬식</param>
		/// <returns>엔터티</returns>
        public virtual T GetFirst<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy)
		{
		    return GetFirstCore(where, orderBy, true);
		}

        public virtual Task<T> GetFirstAsync<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy)
		    => Task.Factory.StartNew(() => GetFirst(where, orderBy));

	    private T GetFirstCore<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending)
	    {
            using var context = DbContextFactory.Create();

	        return QueryFirst(where, orderBy, ascending, context).FirstOrDefault();
	    }

        /// <summary>
        /// 모든 엔터티를 정렬식에 따라 정렬했을 때 마지막 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
        /// </summary>
        /// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
        /// <param name="orderBy">정렬식</param>
        /// <returns>엔터티</returns>
        public virtual T GetLast<U>(Expression<Func<T, U>> orderBy)
		{
			return GetLast(null, orderBy);
		}

        public virtual Task<T> GetLastAsync<U>(Expression<Func<T, U>> orderBy)
		=> Task.Factory.StartNew(() => GetLast(orderBy));

		/// <summary>
		/// 조건식에 맞는 엔터티를 정렬식에 따라 정렬했을 때 마지막 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
		/// </summary>
		/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
		/// <param name="where">조건식</param>
		/// <param name="orderBy">정렬식</param>
		/// <returns>엔터티</returns>
		[ForAsync]
        public virtual T GetLast<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy)
		{
		    return GetFirstCore(where, orderBy, false);
        }

        public virtual Task<T> GetLastAsync<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy)
		=> Task.Factory.StartNew(() => GetLast(where, orderBy));

        private static IQueryable<T> QueryFirst<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending, ChinookContext context)
		{
			var query = from x in context.Set<T>()
						select x;

			if (where != null)
				query = query.Where(where);

            // 마지막 행은 orderby가 반드시 지정되어 있어야 함. orderby를 지정하지 않으면 skip 메서드를 사용할 수 없기 때문.
            if (orderBy != null)
			    query = @ascending ? query.OrderBy(orderBy) : query.OrderByDescending(orderBy);

            return query;
		}
		#endregion

		#region SelectFirst / SelectLast
		/// <summary>
		/// 모든 엔터티 중 첫번째 엔터티를 반환한다. 엔터티의 순서는 DB에 의해 결정된다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
		/// </summary>
		/// <param name="select">선택식</param>
		/// <returns>엔터티</returns>
        public virtual R SelectFirst<R>(Expression<Func<T, R>> select)
		{
			return SelectFirst<T, R>(null, null, select);
		}

        public virtual Task<R> SelectFirstAsync<R>(Expression<Func<T, R>> select)
		=> Task.Factory.StartNew(() => SelectFirst(select));

		/// <summary>
		/// 조건식에 맞는 엔터티 중 첫번째 엔터티를 반환한다. 엔터티의 순서는 DB에 의해 결정된다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
		/// </summary>
		/// <typeparam name="R">선택 형식</typeparam>
		/// <param name="where">조건식</param>
		/// <param name="select">선택식</param>
		/// <returns>엔터티</returns>
        public virtual R SelectFirst<R>(Expression<Func<T, bool>> where, Expression<Func<T, R>> select)
		{
			return SelectFirst<T, R>(where, null, select);
		}

        public virtual Task<R> SelectFirstAsync<R>(Expression<Func<T, bool>> where, Expression<Func<T, R>> select)
		=> Task.Factory.StartNew(() => SelectFirst(where, select));

		/// <summary>
		/// 모든 엔터티를 정렬식에 따라 정렬했을 때 첫번째 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
		/// </summary>
		/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
		/// <typeparam name="R">선택 형식</typeparam>
		/// <param name="orderBy">정렬식</param>
		/// <param name="select">선택식</param>
		/// <returns>엔터티</returns>
        public virtual R SelectFirst<U, R>(Expression<Func<T, U>> orderBy, Expression<Func<T, R>> select)
		{
			return SelectFirst(null, orderBy, select);
		}

        public virtual Task<R> SelectFirstAsync<U, R>(Expression<Func<T, U>> orderBy, Expression<Func<T, R>> select)
		=> Task.Factory.StartNew(() => SelectFirst(orderBy, select));

		/// <summary>
		/// 조건식에 맞는 엔터티를 정렬식에 따라 정렬했을 때 첫번째 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
		/// </summary>
		/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
		/// <typeparam name="R">선택 형식</typeparam>
		/// <param name="where">조건식</param>
		/// <param name="orderBy">정렬식</param>
		/// <param name="select">선택식</param>
		/// <returns>엔터티</returns>
        public virtual R SelectFirst<U, R>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, Expression<Func<T, R>> select)
		{
		    return SelectFirstCore(where, orderBy, select, true);
		}

        public virtual Task<R> SelectFirstAsync<U, R>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, Expression<Func<T, R>> select)
		=> Task.Factory.StartNew(() => SelectFirst(where, orderBy, select));

        /// <summary>
        /// 조건식에 맞는 엔터티를 정렬식에 따라 정렬했을 때 첫번째 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
        /// </summary>
        /// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
        /// <typeparam name="R">선택 형식</typeparam>
        /// <param name="where">조건식</param>
        /// <param name="orderBy">정렬식</param>
        /// <param name="select">선택식</param>
        /// <param name="ascending">true이면 오름차순, false이면 내림차순</param>
        /// <returns>엔터티</returns>
        private R SelectFirstCore<U, R>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, Expression<Func<T, R>> select, bool ascending)
		{
            using var context = DbContextFactory.Create();

			var query = QueryFirst(where, orderBy, ascending, context);
			return query.Select(select).FirstOrDefault();
		}

        /// <summary>
        /// 모든 엔터티를 정렬식에 따라 정렬했을 때 마지막 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
        /// </summary>
        /// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
        /// <typeparam name="R">선택 형식</typeparam>
        /// <param name="orderBy">정렬식</param>
        /// <param name="select">선택식</param>
        /// <returns>엔터티</returns>
        public virtual R SelectLast<U, R>(Expression<Func<T, U>> orderBy, Expression<Func<T, R>> select)
	    {
	        return SelectLast(null, orderBy, select);
	    }

        public virtual Task<R> SelectLastAsync<U, R>(Expression<Func<T, U>> orderBy, Expression<Func<T, R>> select)
		=> Task.Factory.StartNew(() => SelectLast(orderBy, select));

        /// <summary>
        /// 조건식에 맞는 엔터티를 정렬식에 따라 정렬했을 때 마지막 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
        /// </summary>
        /// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
        /// <typeparam name="R">선택 형식</typeparam>
        /// <param name="where">조건식</param>
        /// <param name="orderBy">정렬식</param>
        /// <param name="select">선택식</param>
        /// <returns>엔터티</returns>
        public virtual R SelectLast<U, R>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, Expression<Func<T, R>> select)
	    {
	        return SelectFirstCore(where, orderBy, select, false);
	    }

        public virtual Task<R> SelectLastAsync<U, R>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, Expression<Func<T, R>> select)
		=> Task.Factory.StartNew(() => SelectLast(where, orderBy, select));
        #endregion

		#region GetCount
		/// <summary>
		/// 모든 엔터티의 갯수를 구한다.
		/// </summary>
		/// <returns>엔터티의 갯수</returns>
        public virtual int GetCount()
		{
			return GetCount(null);
		}

        public virtual Task<int> GetCountAsync()
		=> Task.Factory.StartNew(() => GetCount());

		/// <summary>
		/// 조건식에 맞는 엔터티의 갯수를 구한다.
		/// </summary>
		/// <param name="where">조건식</param>
		/// <returns>엔터티의 갯수</returns>
        public virtual int GetCount(Expression<Func<T, bool>> where)
		{
            using var context = DbContextFactory.Create();

			var query = from item in context.Set<T>()
						select item;

			if (where != null)
				query = query.Where(where);

			return query.Count();
		}

        public virtual Task<int> GetCountAsync(Expression<Func<T, bool>> where)
		=> Task.Factory.StartNew(() => GetCount(where));
		#endregion

		#region Exist
		/// <summary>
		/// 조건식에 맞는 엔터티가 존재하는지 검사한다.
		/// </summary>
		/// <param name="where">조건식</param>
		/// <returns>존재 여부</returns>
        public virtual bool Exists(Expression<Func<T, bool>> where)
		{
            using var context = DbContextFactory.Create();

			var query = from item in context.Set<T>()
						select item;

			if (where != null)
				query = query.Where(where);

			return query.Any();
		}

        public virtual Task<bool> ExistsAsync(Expression<Func<T, bool>> where)
		=> Task.Factory.StartNew(() => Exists(where));
		#endregion

		#region Write log partial methods
		/// <summary>
		/// 엔티티의 로그를 기록한다.
		/// </summary>
		/// <param name="entity">엔티티</param>
		/// <param name="logType">로그 타입</param>
		partial void WriteSingleLog(T entity, LogType logType);

		/// <summary>
		/// 엔티티 컬렉션의 로그를 기록한다.
		/// </summary>
		/// <param name="entities">엔티티 컬렉션</param>
		/// <param name="logType">로그 타입</param>
		partial void WriteMultipleLog(IEnumerable<T> entities, LogType logType);
		#endregion

		#region Insert / Update / Delete
		/// <summary>
		/// 엔터티를 삽입한다.
		/// </summary>
		/// <param name="entity">삽입할 엔터티</param>
		/// <returns>삽입된 엔터티</returns>
        public virtual T Insert(T entity)
		{
            using var context = DbContextFactory.Create();

			MarkToInsert(context, entity);
			context.SaveChanges();

			WriteSingleLog(entity, LogType.Insert);

			return entity;
		}

        public virtual Task<T> InsertAsync(T entity)
		=> Task.Factory.StartNew(() => Insert(entity));

		internal virtual void MarkToInsert(ChinookContext context, T entity)
		{
			context.Set<T>().Add(entity);
		}

		/// <summary>
		/// 엔터티 컬렉션을 삽입한다.
		/// </summary>
		/// <param name="entities">삽입할 엔터티가 포함된 컬렉션</param>
		/// <returns>삽입된 엔터티의 갯수</returns>
        public virtual int InsertMany(IEnumerable<T> entities)
		{
            using var context = DbContextFactory.Create();

			MarkToInsertMany(context, entities);
			int count = context.SaveChanges();

			WriteMultipleLog(entities, LogType.Insert);

			return count;
		}

        public virtual Task<int> InsertManyAsync(IEnumerable<T> entities)
		=> Task.Factory.StartNew(() => InsertMany(entities));

		internal virtual void MarkToInsertMany(ChinookContext context, IEnumerable<T> entities)
		{
			foreach (var entity in entities)
				context.Set<T>().Add(entity);
		}

		/// <summary>
		/// 엔터티를 갱신한다.
		/// </summary>
		/// <param name="entity">갱신할 엔터티</param>
		/// <returns>갱신된 엔터티의 갯수</returns>
        public virtual int Update(T entity)
		{
            using var context = DbContextFactory.Create();

			MarkToUpdate(context, entity);
			int count = context.SaveChanges();

			WriteSingleLog(entity, LogType.Update);

			return count;
		}

        public virtual Task<int> UpdateAsync(T entity)
		=> Task.Factory.StartNew(() => Update(entity));

		internal virtual void MarkToUpdate(ChinookContext context, T entity)
		{
			context.Entry(entity).State = EntityState.Modified;
		}

		/// <summary>
		/// 엔터티 컬렉션을 갱신한다.
		/// </summary>
		/// <param name="entities">갱신할 엔터티가 포함된 컬렉션</param>
		/// <returns>갱신된 엔터티의 갯수</returns>
        public virtual int UpdateMany(IEnumerable<T> entities)
		{
            using var context = DbContextFactory.Create();

            MarkToUpdateMany(context, entities);
			int count = context.SaveChanges();

			WriteMultipleLog(entities, LogType.Update);

			return count;
		}

        public virtual Task<int> UpdateManyAsync(IEnumerable<T> entities)
		=> Task.Factory.StartNew(() => UpdateMany(entities));

		internal virtual void MarkToUpdateMany(ChinookContext context, IEnumerable<T> entities)
		{
			foreach (var entity in entities)
				context.Entry(entity).State = EntityState.Modified;
		}

		/// <summary>
		/// 엔터티를 삭제한다.
		/// </summary>
		/// <param name="entity">삭제할 엔터티</param>
		/// <returns>삭제된 엔터티의 갯수</returns>
        public virtual int Delete(T entity)
		{
            using var context = DbContextFactory.Create();

            MarkToDelete(context, entity);
			int count = context.SaveChanges();

			WriteSingleLog(entity, LogType.Delete);
			
			return count;
		}

        public virtual Task<int> DeleteAsync(T entity)
		=> Task.Factory.StartNew(() => Delete(entity));

		internal virtual void MarkToDelete(ChinookContext context, T entity)
		{
			context.Entry(entity).State = EntityState.Deleted;
		}

		/// <summary>
		/// 엔터티 컬렉션을 삭제한다.
		/// </summary>
		/// <param name="entities">삭제할 엔터티 컬렉션</param>
		/// <returns>삭제된 엔터티의 갯수</returns>
        public virtual int DeleteMany(IEnumerable<T> entities)
		{
            using var context = DbContextFactory.Create();
			
			MarkToDeleteMany(context, entities);
			int count = context.SaveChanges();

			WriteMultipleLog(entities, LogType.Delete);

			return count;
		}

        public virtual Task<int> DeleteManyAsync(IEnumerable<T> entities)
		=> Task.Factory.StartNew(() => DeleteMany(entities));

		internal virtual void MarkToDeleteMany(ChinookContext context, IEnumerable<T> entities)
		{
			foreach (var entity in entities)
				context.Entry(entity).State = EntityState.Deleted;
		}

		/// <summary>
		/// 조건식을 만족하는 엔터티들을 삭제한다.
		/// </summary>
		/// <param name="where">조건식</param>
		/// <returns>삭제된 엔터티의 갯수</returns>
        public virtual int DeleteAll(Expression<Func<T, bool>> where)
		{
            using var context = DbContextFactory.Create();

			var query = from item in context.Set<T>()
						select item;

			if (where != null)
				query = query.Where(where);

			var entities = query.ToList();

			MarkToDeleteMany(context, entities);

			int count = context.SaveChanges();

			WriteMultipleLog(entities, LogType.Delete);

			return count;
		}

        public virtual Task<int> DeleteAllAsync(Expression<Func<T, bool>> where)
		=> Task.Factory.StartNew(() => DeleteAll(where));
		#endregion
	}
	#endregion

		#region AlbumDao
	/// <summary>
	/// Album 데이터 클래스
	/// </summary>
	public partial class AlbumDao : EntityDao<Album>
	{
		internal AlbumDao() {}

		
		/// <summary>
		/// 기본키가 일치하는 엔터티를 구한다.
		/// </summary>
				/// <param name="albumId">기본키</param>
		/// <returns>기본키가 일치하는 엔터티</returns>
        public virtual Album GetByKey(int albumId)
		{
            using var context = DbContextFactory.Create();

            return context.Set<Album>().FirstOrDefault(x =>  x.AlbumId == albumId);
		}

        public virtual Task<Album> GetByKeyAsync(int albumId)
			=> Task.Factory.StartNew(() => GetByKey(albumId));

		/// <summary>
		/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
		/// </summary>
				/// <param name="albumId">기본키</param>
		/// <returns>존재 여부</returns>
        public virtual bool ExistsByKey(int albumId)
		{
            using var context = DbContextFactory.Create();

			return context.Set<Album>().Count(x =>  x.AlbumId == albumId) > 0;
		}

        public virtual Task<bool> ExistsByKeyAsync(int albumId)
		=> Task.Factory.StartNew(() => ExistsByKey(albumId));

		/// <summary>
		/// 기본키가 일치하는 엔터티를 삭제한다.
		/// </summary>
				/// <param name="albumId">기본키</param>
		/// <returns>삭제된 엔터티의 갯수</returns>
        public virtual int DeleteByKey(int albumId)
		{
            using var context = DbContextFactory.Create();

			var query = from x in context.Set<Album>()
			where x.AlbumId == albumId
			select x;

			var entity = query.FirstOrDefault();

            if (entity == null)
                return 0;

			MarkToDelete(context, entity);

			return context.SaveChanges();
		}

        public virtual Task<int> DeleteByKeyAsync(int albumId)
		=> Task.Factory.StartNew(() => DeleteByKey(albumId));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입할 엔터티</param>
		/// <returns>삽입된 엔터티</returns>
        public virtual Album InsertIfNotExist(Album entity)
	    {
            using var context = DbContextFactory.Create();

	        if (context.Set<Album>().Count(x =>  x.AlbumId == entity.AlbumId) > 0)
	            return null;

	        MarkToInsert(context, entity);
	        context.SaveChanges();

	        return entity;
	    }

        public virtual Task<Album> InsertIfNotExistAsync(Album entity)
		=> Task.Factory.StartNew(() => InsertIfNotExist(entity));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 있으면 갱신하고 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입 혹은 갱신할 엔터티</param>
		/// <returns>삽입 혹은 갱신된 엔터티</returns>
        public virtual Album InsertOrUpdate(Album entity)
	    {
            using var context = DbContextFactory.Create();
            
	        if (context.Set<Album>().Count(x =>  x.AlbumId == entity.AlbumId) > 0)
	        {
	            MarkToUpdate(context, entity);
	            context.SaveChanges();

	            return entity;

            }
            else
	        {
	            MarkToInsert(context, entity);
	            context.SaveChanges();

	            return entity;

            }
	    }

        public virtual Task<Album> InsertOrUpdateAsync(Album entity)
		=> Task.Factory.StartNew(() => InsertOrUpdate(entity));
		

				/// <summary>
		/// 외래키 ArtistId 이(가) 일치하는 엔터티 컬렉션을 구한다.
		/// </summary>
		/// <param name="artistId">외래키</param>
		/// <returns>ArtistId 이(가) 일치하는 엔터티 컬렉션</returns>
        public virtual List<Album> GetByArtistId(int artistId)
		{
            using var context = DbContextFactory.Create();

			return context.Set<Album>().Where(x => x.ArtistId == artistId).ToList();
		}

        public virtual Task<List<Album>> GetByArtistIdAsync(int artistId)
		=> Task.Factory.StartNew(() => GetByArtistId(artistId));
	}
	#endregion
	#region ArtistDao
	/// <summary>
	/// Artist 데이터 클래스
	/// </summary>
	public partial class ArtistDao : EntityDao<Artist>
	{
		internal ArtistDao() {}

		
		/// <summary>
		/// 기본키가 일치하는 엔터티를 구한다.
		/// </summary>
				/// <param name="artistId">기본키</param>
		/// <returns>기본키가 일치하는 엔터티</returns>
        public virtual Artist GetByKey(int artistId)
		{
            using var context = DbContextFactory.Create();

            return context.Set<Artist>().FirstOrDefault(x =>  x.ArtistId == artistId);
		}

        public virtual Task<Artist> GetByKeyAsync(int artistId)
			=> Task.Factory.StartNew(() => GetByKey(artistId));

		/// <summary>
		/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
		/// </summary>
				/// <param name="artistId">기본키</param>
		/// <returns>존재 여부</returns>
        public virtual bool ExistsByKey(int artistId)
		{
            using var context = DbContextFactory.Create();

			return context.Set<Artist>().Count(x =>  x.ArtistId == artistId) > 0;
		}

        public virtual Task<bool> ExistsByKeyAsync(int artistId)
		=> Task.Factory.StartNew(() => ExistsByKey(artistId));

		/// <summary>
		/// 기본키가 일치하는 엔터티를 삭제한다.
		/// </summary>
				/// <param name="artistId">기본키</param>
		/// <returns>삭제된 엔터티의 갯수</returns>
        public virtual int DeleteByKey(int artistId)
		{
            using var context = DbContextFactory.Create();

			var query = from x in context.Set<Artist>()
			where x.ArtistId == artistId
			select x;

			var entity = query.FirstOrDefault();

            if (entity == null)
                return 0;

			MarkToDelete(context, entity);

			return context.SaveChanges();
		}

        public virtual Task<int> DeleteByKeyAsync(int artistId)
		=> Task.Factory.StartNew(() => DeleteByKey(artistId));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입할 엔터티</param>
		/// <returns>삽입된 엔터티</returns>
        public virtual Artist InsertIfNotExist(Artist entity)
	    {
            using var context = DbContextFactory.Create();

	        if (context.Set<Artist>().Count(x =>  x.ArtistId == entity.ArtistId) > 0)
	            return null;

	        MarkToInsert(context, entity);
	        context.SaveChanges();

	        return entity;
	    }

        public virtual Task<Artist> InsertIfNotExistAsync(Artist entity)
		=> Task.Factory.StartNew(() => InsertIfNotExist(entity));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 있으면 갱신하고 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입 혹은 갱신할 엔터티</param>
		/// <returns>삽입 혹은 갱신된 엔터티</returns>
        public virtual Artist InsertOrUpdate(Artist entity)
	    {
            using var context = DbContextFactory.Create();
            
	        if (context.Set<Artist>().Count(x =>  x.ArtistId == entity.ArtistId) > 0)
	        {
	            MarkToUpdate(context, entity);
	            context.SaveChanges();

	            return entity;

            }
            else
	        {
	            MarkToInsert(context, entity);
	            context.SaveChanges();

	            return entity;

            }
	    }

        public virtual Task<Artist> InsertOrUpdateAsync(Artist entity)
		=> Task.Factory.StartNew(() => InsertOrUpdate(entity));
		

		
	}
	#endregion
	#region CustomerDao
	/// <summary>
	/// Customer 데이터 클래스
	/// </summary>
	public partial class CustomerDao : EntityDao<Customer>
	{
		internal CustomerDao() {}

		
		/// <summary>
		/// 기본키가 일치하는 엔터티를 구한다.
		/// </summary>
				/// <param name="customerId">기본키</param>
		/// <returns>기본키가 일치하는 엔터티</returns>
        public virtual Customer GetByKey(int customerId)
		{
            using var context = DbContextFactory.Create();

            return context.Set<Customer>().FirstOrDefault(x =>  x.CustomerId == customerId);
		}

        public virtual Task<Customer> GetByKeyAsync(int customerId)
			=> Task.Factory.StartNew(() => GetByKey(customerId));

		/// <summary>
		/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
		/// </summary>
				/// <param name="customerId">기본키</param>
		/// <returns>존재 여부</returns>
        public virtual bool ExistsByKey(int customerId)
		{
            using var context = DbContextFactory.Create();

			return context.Set<Customer>().Count(x =>  x.CustomerId == customerId) > 0;
		}

        public virtual Task<bool> ExistsByKeyAsync(int customerId)
		=> Task.Factory.StartNew(() => ExistsByKey(customerId));

		/// <summary>
		/// 기본키가 일치하는 엔터티를 삭제한다.
		/// </summary>
				/// <param name="customerId">기본키</param>
		/// <returns>삭제된 엔터티의 갯수</returns>
        public virtual int DeleteByKey(int customerId)
		{
            using var context = DbContextFactory.Create();

			var query = from x in context.Set<Customer>()
			where x.CustomerId == customerId
			select x;

			var entity = query.FirstOrDefault();

            if (entity == null)
                return 0;

			MarkToDelete(context, entity);

			return context.SaveChanges();
		}

        public virtual Task<int> DeleteByKeyAsync(int customerId)
		=> Task.Factory.StartNew(() => DeleteByKey(customerId));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입할 엔터티</param>
		/// <returns>삽입된 엔터티</returns>
        public virtual Customer InsertIfNotExist(Customer entity)
	    {
            using var context = DbContextFactory.Create();

	        if (context.Set<Customer>().Count(x =>  x.CustomerId == entity.CustomerId) > 0)
	            return null;

	        MarkToInsert(context, entity);
	        context.SaveChanges();

	        return entity;
	    }

        public virtual Task<Customer> InsertIfNotExistAsync(Customer entity)
		=> Task.Factory.StartNew(() => InsertIfNotExist(entity));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 있으면 갱신하고 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입 혹은 갱신할 엔터티</param>
		/// <returns>삽입 혹은 갱신된 엔터티</returns>
        public virtual Customer InsertOrUpdate(Customer entity)
	    {
            using var context = DbContextFactory.Create();
            
	        if (context.Set<Customer>().Count(x =>  x.CustomerId == entity.CustomerId) > 0)
	        {
	            MarkToUpdate(context, entity);
	            context.SaveChanges();

	            return entity;

            }
            else
	        {
	            MarkToInsert(context, entity);
	            context.SaveChanges();

	            return entity;

            }
	    }

        public virtual Task<Customer> InsertOrUpdateAsync(Customer entity)
		=> Task.Factory.StartNew(() => InsertOrUpdate(entity));
		

				/// <summary>
		/// 외래키 SupportRepId 이(가) 일치하는 엔터티 컬렉션을 구한다.
		/// </summary>
		/// <param name="supportRepId">외래키</param>
		/// <returns>SupportRepId 이(가) 일치하는 엔터티 컬렉션</returns>
        public virtual List<Customer> GetBySupportRepId(int? supportRepId)
		{
            using var context = DbContextFactory.Create();

			return context.Set<Customer>().Where(x => x.SupportRepId == supportRepId).ToList();
		}

        public virtual Task<List<Customer>> GetBySupportRepIdAsync(int? supportRepId)
		=> Task.Factory.StartNew(() => GetBySupportRepId(supportRepId));
	}
	#endregion
	#region EmployeeDao
	/// <summary>
	/// Employee 데이터 클래스
	/// </summary>
	public partial class EmployeeDao : EntityDao<Employee>
	{
		internal EmployeeDao() {}

		
		/// <summary>
		/// 기본키가 일치하는 엔터티를 구한다.
		/// </summary>
				/// <param name="employeeId">기본키</param>
		/// <returns>기본키가 일치하는 엔터티</returns>
        public virtual Employee GetByKey(int employeeId)
		{
            using var context = DbContextFactory.Create();

            return context.Set<Employee>().FirstOrDefault(x =>  x.EmployeeId == employeeId);
		}

        public virtual Task<Employee> GetByKeyAsync(int employeeId)
			=> Task.Factory.StartNew(() => GetByKey(employeeId));

		/// <summary>
		/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
		/// </summary>
				/// <param name="employeeId">기본키</param>
		/// <returns>존재 여부</returns>
        public virtual bool ExistsByKey(int employeeId)
		{
            using var context = DbContextFactory.Create();

			return context.Set<Employee>().Count(x =>  x.EmployeeId == employeeId) > 0;
		}

        public virtual Task<bool> ExistsByKeyAsync(int employeeId)
		=> Task.Factory.StartNew(() => ExistsByKey(employeeId));

		/// <summary>
		/// 기본키가 일치하는 엔터티를 삭제한다.
		/// </summary>
				/// <param name="employeeId">기본키</param>
		/// <returns>삭제된 엔터티의 갯수</returns>
        public virtual int DeleteByKey(int employeeId)
		{
            using var context = DbContextFactory.Create();

			var query = from x in context.Set<Employee>()
			where x.EmployeeId == employeeId
			select x;

			var entity = query.FirstOrDefault();

            if (entity == null)
                return 0;

			MarkToDelete(context, entity);

			return context.SaveChanges();
		}

        public virtual Task<int> DeleteByKeyAsync(int employeeId)
		=> Task.Factory.StartNew(() => DeleteByKey(employeeId));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입할 엔터티</param>
		/// <returns>삽입된 엔터티</returns>
        public virtual Employee InsertIfNotExist(Employee entity)
	    {
            using var context = DbContextFactory.Create();

	        if (context.Set<Employee>().Count(x =>  x.EmployeeId == entity.EmployeeId) > 0)
	            return null;

	        MarkToInsert(context, entity);
	        context.SaveChanges();

	        return entity;
	    }

        public virtual Task<Employee> InsertIfNotExistAsync(Employee entity)
		=> Task.Factory.StartNew(() => InsertIfNotExist(entity));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 있으면 갱신하고 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입 혹은 갱신할 엔터티</param>
		/// <returns>삽입 혹은 갱신된 엔터티</returns>
        public virtual Employee InsertOrUpdate(Employee entity)
	    {
            using var context = DbContextFactory.Create();
            
	        if (context.Set<Employee>().Count(x =>  x.EmployeeId == entity.EmployeeId) > 0)
	        {
	            MarkToUpdate(context, entity);
	            context.SaveChanges();

	            return entity;

            }
            else
	        {
	            MarkToInsert(context, entity);
	            context.SaveChanges();

	            return entity;

            }
	    }

        public virtual Task<Employee> InsertOrUpdateAsync(Employee entity)
		=> Task.Factory.StartNew(() => InsertOrUpdate(entity));
		

				/// <summary>
		/// 외래키 ReportsTo 이(가) 일치하는 엔터티 컬렉션을 구한다.
		/// </summary>
		/// <param name="reportsTo">외래키</param>
		/// <returns>ReportsTo 이(가) 일치하는 엔터티 컬렉션</returns>
        public virtual List<Employee> GetByReportsTo(int? reportsTo)
		{
            using var context = DbContextFactory.Create();

			return context.Set<Employee>().Where(x => x.ReportsTo == reportsTo).ToList();
		}

        public virtual Task<List<Employee>> GetByReportsToAsync(int? reportsTo)
		=> Task.Factory.StartNew(() => GetByReportsTo(reportsTo));
	}
	#endregion
	#region GenreDao
	/// <summary>
	/// Genre 데이터 클래스
	/// </summary>
	public partial class GenreDao : EntityDao<Genre>
	{
		internal GenreDao() {}

		
		/// <summary>
		/// 기본키가 일치하는 엔터티를 구한다.
		/// </summary>
				/// <param name="genreId">기본키</param>
		/// <returns>기본키가 일치하는 엔터티</returns>
        public virtual Genre GetByKey(int genreId)
		{
            using var context = DbContextFactory.Create();

            return context.Set<Genre>().FirstOrDefault(x =>  x.GenreId == genreId);
		}

        public virtual Task<Genre> GetByKeyAsync(int genreId)
			=> Task.Factory.StartNew(() => GetByKey(genreId));

		/// <summary>
		/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
		/// </summary>
				/// <param name="genreId">기본키</param>
		/// <returns>존재 여부</returns>
        public virtual bool ExistsByKey(int genreId)
		{
            using var context = DbContextFactory.Create();

			return context.Set<Genre>().Count(x =>  x.GenreId == genreId) > 0;
		}

        public virtual Task<bool> ExistsByKeyAsync(int genreId)
		=> Task.Factory.StartNew(() => ExistsByKey(genreId));

		/// <summary>
		/// 기본키가 일치하는 엔터티를 삭제한다.
		/// </summary>
				/// <param name="genreId">기본키</param>
		/// <returns>삭제된 엔터티의 갯수</returns>
        public virtual int DeleteByKey(int genreId)
		{
            using var context = DbContextFactory.Create();

			var query = from x in context.Set<Genre>()
			where x.GenreId == genreId
			select x;

			var entity = query.FirstOrDefault();

            if (entity == null)
                return 0;

			MarkToDelete(context, entity);

			return context.SaveChanges();
		}

        public virtual Task<int> DeleteByKeyAsync(int genreId)
		=> Task.Factory.StartNew(() => DeleteByKey(genreId));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입할 엔터티</param>
		/// <returns>삽입된 엔터티</returns>
        public virtual Genre InsertIfNotExist(Genre entity)
	    {
            using var context = DbContextFactory.Create();

	        if (context.Set<Genre>().Count(x =>  x.GenreId == entity.GenreId) > 0)
	            return null;

	        MarkToInsert(context, entity);
	        context.SaveChanges();

	        return entity;
	    }

        public virtual Task<Genre> InsertIfNotExistAsync(Genre entity)
		=> Task.Factory.StartNew(() => InsertIfNotExist(entity));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 있으면 갱신하고 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입 혹은 갱신할 엔터티</param>
		/// <returns>삽입 혹은 갱신된 엔터티</returns>
        public virtual Genre InsertOrUpdate(Genre entity)
	    {
            using var context = DbContextFactory.Create();
            
	        if (context.Set<Genre>().Count(x =>  x.GenreId == entity.GenreId) > 0)
	        {
	            MarkToUpdate(context, entity);
	            context.SaveChanges();

	            return entity;

            }
            else
	        {
	            MarkToInsert(context, entity);
	            context.SaveChanges();

	            return entity;

            }
	    }

        public virtual Task<Genre> InsertOrUpdateAsync(Genre entity)
		=> Task.Factory.StartNew(() => InsertOrUpdate(entity));
		

		
	}
	#endregion
	#region InvoiceDao
	/// <summary>
	/// Invoice 데이터 클래스
	/// </summary>
	public partial class InvoiceDao : EntityDao<Invoice>
	{
		internal InvoiceDao() {}

		
		/// <summary>
		/// 기본키가 일치하는 엔터티를 구한다.
		/// </summary>
				/// <param name="invoiceId">기본키</param>
		/// <returns>기본키가 일치하는 엔터티</returns>
        public virtual Invoice GetByKey(int invoiceId)
		{
            using var context = DbContextFactory.Create();

            return context.Set<Invoice>().FirstOrDefault(x =>  x.InvoiceId == invoiceId);
		}

        public virtual Task<Invoice> GetByKeyAsync(int invoiceId)
			=> Task.Factory.StartNew(() => GetByKey(invoiceId));

		/// <summary>
		/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
		/// </summary>
				/// <param name="invoiceId">기본키</param>
		/// <returns>존재 여부</returns>
        public virtual bool ExistsByKey(int invoiceId)
		{
            using var context = DbContextFactory.Create();

			return context.Set<Invoice>().Count(x =>  x.InvoiceId == invoiceId) > 0;
		}

        public virtual Task<bool> ExistsByKeyAsync(int invoiceId)
		=> Task.Factory.StartNew(() => ExistsByKey(invoiceId));

		/// <summary>
		/// 기본키가 일치하는 엔터티를 삭제한다.
		/// </summary>
				/// <param name="invoiceId">기본키</param>
		/// <returns>삭제된 엔터티의 갯수</returns>
        public virtual int DeleteByKey(int invoiceId)
		{
            using var context = DbContextFactory.Create();

			var query = from x in context.Set<Invoice>()
			where x.InvoiceId == invoiceId
			select x;

			var entity = query.FirstOrDefault();

            if (entity == null)
                return 0;

			MarkToDelete(context, entity);

			return context.SaveChanges();
		}

        public virtual Task<int> DeleteByKeyAsync(int invoiceId)
		=> Task.Factory.StartNew(() => DeleteByKey(invoiceId));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입할 엔터티</param>
		/// <returns>삽입된 엔터티</returns>
        public virtual Invoice InsertIfNotExist(Invoice entity)
	    {
            using var context = DbContextFactory.Create();

	        if (context.Set<Invoice>().Count(x =>  x.InvoiceId == entity.InvoiceId) > 0)
	            return null;

	        MarkToInsert(context, entity);
	        context.SaveChanges();

	        return entity;
	    }

        public virtual Task<Invoice> InsertIfNotExistAsync(Invoice entity)
		=> Task.Factory.StartNew(() => InsertIfNotExist(entity));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 있으면 갱신하고 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입 혹은 갱신할 엔터티</param>
		/// <returns>삽입 혹은 갱신된 엔터티</returns>
        public virtual Invoice InsertOrUpdate(Invoice entity)
	    {
            using var context = DbContextFactory.Create();
            
	        if (context.Set<Invoice>().Count(x =>  x.InvoiceId == entity.InvoiceId) > 0)
	        {
	            MarkToUpdate(context, entity);
	            context.SaveChanges();

	            return entity;

            }
            else
	        {
	            MarkToInsert(context, entity);
	            context.SaveChanges();

	            return entity;

            }
	    }

        public virtual Task<Invoice> InsertOrUpdateAsync(Invoice entity)
		=> Task.Factory.StartNew(() => InsertOrUpdate(entity));
		

				/// <summary>
		/// 외래키 CustomerId 이(가) 일치하는 엔터티 컬렉션을 구한다.
		/// </summary>
		/// <param name="customerId">외래키</param>
		/// <returns>CustomerId 이(가) 일치하는 엔터티 컬렉션</returns>
        public virtual List<Invoice> GetByCustomerId(int customerId)
		{
            using var context = DbContextFactory.Create();

			return context.Set<Invoice>().Where(x => x.CustomerId == customerId).ToList();
		}

        public virtual Task<List<Invoice>> GetByCustomerIdAsync(int customerId)
		=> Task.Factory.StartNew(() => GetByCustomerId(customerId));
	}
	#endregion
	#region InvoiceLineDao
	/// <summary>
	/// InvoiceLine 데이터 클래스
	/// </summary>
	public partial class InvoiceLineDao : EntityDao<InvoiceLine>
	{
		internal InvoiceLineDao() {}

		
		/// <summary>
		/// 기본키가 일치하는 엔터티를 구한다.
		/// </summary>
				/// <param name="invoiceLineId">기본키</param>
		/// <returns>기본키가 일치하는 엔터티</returns>
        public virtual InvoiceLine GetByKey(int invoiceLineId)
		{
            using var context = DbContextFactory.Create();

            return context.Set<InvoiceLine>().FirstOrDefault(x =>  x.InvoiceLineId == invoiceLineId);
		}

        public virtual Task<InvoiceLine> GetByKeyAsync(int invoiceLineId)
			=> Task.Factory.StartNew(() => GetByKey(invoiceLineId));

		/// <summary>
		/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
		/// </summary>
				/// <param name="invoiceLineId">기본키</param>
		/// <returns>존재 여부</returns>
        public virtual bool ExistsByKey(int invoiceLineId)
		{
            using var context = DbContextFactory.Create();

			return context.Set<InvoiceLine>().Count(x =>  x.InvoiceLineId == invoiceLineId) > 0;
		}

        public virtual Task<bool> ExistsByKeyAsync(int invoiceLineId)
		=> Task.Factory.StartNew(() => ExistsByKey(invoiceLineId));

		/// <summary>
		/// 기본키가 일치하는 엔터티를 삭제한다.
		/// </summary>
				/// <param name="invoiceLineId">기본키</param>
		/// <returns>삭제된 엔터티의 갯수</returns>
        public virtual int DeleteByKey(int invoiceLineId)
		{
            using var context = DbContextFactory.Create();

			var query = from x in context.Set<InvoiceLine>()
			where x.InvoiceLineId == invoiceLineId
			select x;

			var entity = query.FirstOrDefault();

            if (entity == null)
                return 0;

			MarkToDelete(context, entity);

			return context.SaveChanges();
		}

        public virtual Task<int> DeleteByKeyAsync(int invoiceLineId)
		=> Task.Factory.StartNew(() => DeleteByKey(invoiceLineId));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입할 엔터티</param>
		/// <returns>삽입된 엔터티</returns>
        public virtual InvoiceLine InsertIfNotExist(InvoiceLine entity)
	    {
            using var context = DbContextFactory.Create();

	        if (context.Set<InvoiceLine>().Count(x =>  x.InvoiceLineId == entity.InvoiceLineId) > 0)
	            return null;

	        MarkToInsert(context, entity);
	        context.SaveChanges();

	        return entity;
	    }

        public virtual Task<InvoiceLine> InsertIfNotExistAsync(InvoiceLine entity)
		=> Task.Factory.StartNew(() => InsertIfNotExist(entity));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 있으면 갱신하고 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입 혹은 갱신할 엔터티</param>
		/// <returns>삽입 혹은 갱신된 엔터티</returns>
        public virtual InvoiceLine InsertOrUpdate(InvoiceLine entity)
	    {
            using var context = DbContextFactory.Create();
            
	        if (context.Set<InvoiceLine>().Count(x =>  x.InvoiceLineId == entity.InvoiceLineId) > 0)
	        {
	            MarkToUpdate(context, entity);
	            context.SaveChanges();

	            return entity;

            }
            else
	        {
	            MarkToInsert(context, entity);
	            context.SaveChanges();

	            return entity;

            }
	    }

        public virtual Task<InvoiceLine> InsertOrUpdateAsync(InvoiceLine entity)
		=> Task.Factory.StartNew(() => InsertOrUpdate(entity));
		

				/// <summary>
		/// 외래키 InvoiceId 이(가) 일치하는 엔터티 컬렉션을 구한다.
		/// </summary>
		/// <param name="invoiceId">외래키</param>
		/// <returns>InvoiceId 이(가) 일치하는 엔터티 컬렉션</returns>
        public virtual List<InvoiceLine> GetByInvoiceId(int invoiceId)
		{
            using var context = DbContextFactory.Create();

			return context.Set<InvoiceLine>().Where(x => x.InvoiceId == invoiceId).ToList();
		}

        public virtual Task<List<InvoiceLine>> GetByInvoiceIdAsync(int invoiceId)
		=> Task.Factory.StartNew(() => GetByInvoiceId(invoiceId));
		/// <summary>
		/// 외래키 TrackId 이(가) 일치하는 엔터티 컬렉션을 구한다.
		/// </summary>
		/// <param name="trackId">외래키</param>
		/// <returns>TrackId 이(가) 일치하는 엔터티 컬렉션</returns>
        public virtual List<InvoiceLine> GetByTrackId(int trackId)
		{
            using var context = DbContextFactory.Create();

			return context.Set<InvoiceLine>().Where(x => x.TrackId == trackId).ToList();
		}

        public virtual Task<List<InvoiceLine>> GetByTrackIdAsync(int trackId)
		=> Task.Factory.StartNew(() => GetByTrackId(trackId));
	}
	#endregion
	#region MediaTypeDao
	/// <summary>
	/// MediaType 데이터 클래스
	/// </summary>
	public partial class MediaTypeDao : EntityDao<MediaType>
	{
		internal MediaTypeDao() {}

		
		/// <summary>
		/// 기본키가 일치하는 엔터티를 구한다.
		/// </summary>
				/// <param name="mediaTypeId">기본키</param>
		/// <returns>기본키가 일치하는 엔터티</returns>
        public virtual MediaType GetByKey(int mediaTypeId)
		{
            using var context = DbContextFactory.Create();

            return context.Set<MediaType>().FirstOrDefault(x =>  x.MediaTypeId == mediaTypeId);
		}

        public virtual Task<MediaType> GetByKeyAsync(int mediaTypeId)
			=> Task.Factory.StartNew(() => GetByKey(mediaTypeId));

		/// <summary>
		/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
		/// </summary>
				/// <param name="mediaTypeId">기본키</param>
		/// <returns>존재 여부</returns>
        public virtual bool ExistsByKey(int mediaTypeId)
		{
            using var context = DbContextFactory.Create();

			return context.Set<MediaType>().Count(x =>  x.MediaTypeId == mediaTypeId) > 0;
		}

        public virtual Task<bool> ExistsByKeyAsync(int mediaTypeId)
		=> Task.Factory.StartNew(() => ExistsByKey(mediaTypeId));

		/// <summary>
		/// 기본키가 일치하는 엔터티를 삭제한다.
		/// </summary>
				/// <param name="mediaTypeId">기본키</param>
		/// <returns>삭제된 엔터티의 갯수</returns>
        public virtual int DeleteByKey(int mediaTypeId)
		{
            using var context = DbContextFactory.Create();

			var query = from x in context.Set<MediaType>()
			where x.MediaTypeId == mediaTypeId
			select x;

			var entity = query.FirstOrDefault();

            if (entity == null)
                return 0;

			MarkToDelete(context, entity);

			return context.SaveChanges();
		}

        public virtual Task<int> DeleteByKeyAsync(int mediaTypeId)
		=> Task.Factory.StartNew(() => DeleteByKey(mediaTypeId));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입할 엔터티</param>
		/// <returns>삽입된 엔터티</returns>
        public virtual MediaType InsertIfNotExist(MediaType entity)
	    {
            using var context = DbContextFactory.Create();

	        if (context.Set<MediaType>().Count(x =>  x.MediaTypeId == entity.MediaTypeId) > 0)
	            return null;

	        MarkToInsert(context, entity);
	        context.SaveChanges();

	        return entity;
	    }

        public virtual Task<MediaType> InsertIfNotExistAsync(MediaType entity)
		=> Task.Factory.StartNew(() => InsertIfNotExist(entity));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 있으면 갱신하고 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입 혹은 갱신할 엔터티</param>
		/// <returns>삽입 혹은 갱신된 엔터티</returns>
        public virtual MediaType InsertOrUpdate(MediaType entity)
	    {
            using var context = DbContextFactory.Create();
            
	        if (context.Set<MediaType>().Count(x =>  x.MediaTypeId == entity.MediaTypeId) > 0)
	        {
	            MarkToUpdate(context, entity);
	            context.SaveChanges();

	            return entity;

            }
            else
	        {
	            MarkToInsert(context, entity);
	            context.SaveChanges();

	            return entity;

            }
	    }

        public virtual Task<MediaType> InsertOrUpdateAsync(MediaType entity)
		=> Task.Factory.StartNew(() => InsertOrUpdate(entity));
		

		
	}
	#endregion
	#region PlaylistDao
	/// <summary>
	/// Playlist 데이터 클래스
	/// </summary>
	public partial class PlaylistDao : EntityDao<Playlist>
	{
		internal PlaylistDao() {}

		
		/// <summary>
		/// 기본키가 일치하는 엔터티를 구한다.
		/// </summary>
				/// <param name="playlistId">기본키</param>
		/// <returns>기본키가 일치하는 엔터티</returns>
        public virtual Playlist GetByKey(int playlistId)
		{
            using var context = DbContextFactory.Create();

            return context.Set<Playlist>().FirstOrDefault(x =>  x.PlaylistId == playlistId);
		}

        public virtual Task<Playlist> GetByKeyAsync(int playlistId)
			=> Task.Factory.StartNew(() => GetByKey(playlistId));

		/// <summary>
		/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
		/// </summary>
				/// <param name="playlistId">기본키</param>
		/// <returns>존재 여부</returns>
        public virtual bool ExistsByKey(int playlistId)
		{
            using var context = DbContextFactory.Create();

			return context.Set<Playlist>().Count(x =>  x.PlaylistId == playlistId) > 0;
		}

        public virtual Task<bool> ExistsByKeyAsync(int playlistId)
		=> Task.Factory.StartNew(() => ExistsByKey(playlistId));

		/// <summary>
		/// 기본키가 일치하는 엔터티를 삭제한다.
		/// </summary>
				/// <param name="playlistId">기본키</param>
		/// <returns>삭제된 엔터티의 갯수</returns>
        public virtual int DeleteByKey(int playlistId)
		{
            using var context = DbContextFactory.Create();

			var query = from x in context.Set<Playlist>()
			where x.PlaylistId == playlistId
			select x;

			var entity = query.FirstOrDefault();

            if (entity == null)
                return 0;

			MarkToDelete(context, entity);

			return context.SaveChanges();
		}

        public virtual Task<int> DeleteByKeyAsync(int playlistId)
		=> Task.Factory.StartNew(() => DeleteByKey(playlistId));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입할 엔터티</param>
		/// <returns>삽입된 엔터티</returns>
        public virtual Playlist InsertIfNotExist(Playlist entity)
	    {
            using var context = DbContextFactory.Create();

	        if (context.Set<Playlist>().Count(x =>  x.PlaylistId == entity.PlaylistId) > 0)
	            return null;

	        MarkToInsert(context, entity);
	        context.SaveChanges();

	        return entity;
	    }

        public virtual Task<Playlist> InsertIfNotExistAsync(Playlist entity)
		=> Task.Factory.StartNew(() => InsertIfNotExist(entity));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 있으면 갱신하고 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입 혹은 갱신할 엔터티</param>
		/// <returns>삽입 혹은 갱신된 엔터티</returns>
        public virtual Playlist InsertOrUpdate(Playlist entity)
	    {
            using var context = DbContextFactory.Create();
            
	        if (context.Set<Playlist>().Count(x =>  x.PlaylistId == entity.PlaylistId) > 0)
	        {
	            MarkToUpdate(context, entity);
	            context.SaveChanges();

	            return entity;

            }
            else
	        {
	            MarkToInsert(context, entity);
	            context.SaveChanges();

	            return entity;

            }
	    }

        public virtual Task<Playlist> InsertOrUpdateAsync(Playlist entity)
		=> Task.Factory.StartNew(() => InsertOrUpdate(entity));
		

		
	}
	#endregion
	#region PlaylistTrackDao
	/// <summary>
	/// PlaylistTrack 데이터 클래스
	/// </summary>
	public partial class PlaylistTrackDao : EntityDao<PlaylistTrack>
	{
		internal PlaylistTrackDao() {}

		
		/// <summary>
		/// 기본키가 일치하는 엔터티를 구한다.
		/// </summary>
				/// <param name="playlistId">기본키</param>		/// <param name="trackId">기본키</param>
		/// <returns>기본키가 일치하는 엔터티</returns>
        public virtual PlaylistTrack GetByKey(int playlistId, int trackId)
		{
            using var context = DbContextFactory.Create();

            return context.Set<PlaylistTrack>().FirstOrDefault(x =>  x.PlaylistId == playlistId &&  x.TrackId == trackId);
		}

        public virtual Task<PlaylistTrack> GetByKeyAsync(int playlistId, int trackId)
			=> Task.Factory.StartNew(() => GetByKey(playlistId, trackId));

		/// <summary>
		/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
		/// </summary>
				/// <param name="playlistId">기본키</param>		/// <param name="trackId">기본키</param>
		/// <returns>존재 여부</returns>
        public virtual bool ExistsByKey(int playlistId, int trackId)
		{
            using var context = DbContextFactory.Create();

			return context.Set<PlaylistTrack>().Count(x =>  x.PlaylistId == playlistId &&  x.TrackId == trackId) > 0;
		}

        public virtual Task<bool> ExistsByKeyAsync(int playlistId, int trackId)
		=> Task.Factory.StartNew(() => ExistsByKey(playlistId, trackId));

		/// <summary>
		/// 기본키가 일치하는 엔터티를 삭제한다.
		/// </summary>
				/// <param name="playlistId">기본키</param>		/// <param name="trackId">기본키</param>
		/// <returns>삭제된 엔터티의 갯수</returns>
        public virtual int DeleteByKey(int playlistId, int trackId)
		{
            using var context = DbContextFactory.Create();

			var query = from x in context.Set<PlaylistTrack>()
			where x.PlaylistId == playlistId && x.TrackId == trackId
			select x;

			var entity = query.FirstOrDefault();

            if (entity == null)
                return 0;

			MarkToDelete(context, entity);

			return context.SaveChanges();
		}

        public virtual Task<int> DeleteByKeyAsync(int playlistId, int trackId)
		=> Task.Factory.StartNew(() => DeleteByKey(playlistId, trackId));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입할 엔터티</param>
		/// <returns>삽입된 엔터티</returns>
        public virtual PlaylistTrack InsertIfNotExist(PlaylistTrack entity)
	    {
            using var context = DbContextFactory.Create();

	        if (context.Set<PlaylistTrack>().Count(x =>  x.PlaylistId == entity.PlaylistId &&  x.TrackId == entity.TrackId) > 0)
	            return null;

	        MarkToInsert(context, entity);
	        context.SaveChanges();

	        return entity;
	    }

        public virtual Task<PlaylistTrack> InsertIfNotExistAsync(PlaylistTrack entity)
		=> Task.Factory.StartNew(() => InsertIfNotExist(entity));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 있으면 갱신하고 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입 혹은 갱신할 엔터티</param>
		/// <returns>삽입 혹은 갱신된 엔터티</returns>
        public virtual PlaylistTrack InsertOrUpdate(PlaylistTrack entity)
	    {
            using var context = DbContextFactory.Create();
            
	        if (context.Set<PlaylistTrack>().Count(x =>  x.PlaylistId == entity.PlaylistId &&  x.TrackId == entity.TrackId) > 0)
	        {
	            MarkToUpdate(context, entity);
	            context.SaveChanges();

	            return entity;

            }
            else
	        {
	            MarkToInsert(context, entity);
	            context.SaveChanges();

	            return entity;

            }
	    }

        public virtual Task<PlaylistTrack> InsertOrUpdateAsync(PlaylistTrack entity)
		=> Task.Factory.StartNew(() => InsertOrUpdate(entity));
		

				/// <summary>
		/// 외래키 PlaylistId 이(가) 일치하는 엔터티 컬렉션을 구한다.
		/// </summary>
		/// <param name="playlistId">외래키</param>
		/// <returns>PlaylistId 이(가) 일치하는 엔터티 컬렉션</returns>
        public virtual List<PlaylistTrack> GetByPlaylistId(int playlistId)
		{
            using var context = DbContextFactory.Create();

			return context.Set<PlaylistTrack>().Where(x => x.PlaylistId == playlistId).ToList();
		}

        public virtual Task<List<PlaylistTrack>> GetByPlaylistIdAsync(int playlistId)
		=> Task.Factory.StartNew(() => GetByPlaylistId(playlistId));
		/// <summary>
		/// 외래키 TrackId 이(가) 일치하는 엔터티 컬렉션을 구한다.
		/// </summary>
		/// <param name="trackId">외래키</param>
		/// <returns>TrackId 이(가) 일치하는 엔터티 컬렉션</returns>
        public virtual List<PlaylistTrack> GetByTrackId(int trackId)
		{
            using var context = DbContextFactory.Create();

			return context.Set<PlaylistTrack>().Where(x => x.TrackId == trackId).ToList();
		}

        public virtual Task<List<PlaylistTrack>> GetByTrackIdAsync(int trackId)
		=> Task.Factory.StartNew(() => GetByTrackId(trackId));
	}
	#endregion
	#region TrackDao
	/// <summary>
	/// Track 데이터 클래스
	/// </summary>
	public partial class TrackDao : EntityDao<Track>
	{
		internal TrackDao() {}

		
		/// <summary>
		/// 기본키가 일치하는 엔터티를 구한다.
		/// </summary>
				/// <param name="trackId">기본키</param>
		/// <returns>기본키가 일치하는 엔터티</returns>
        public virtual Track GetByKey(int trackId)
		{
            using var context = DbContextFactory.Create();

            return context.Set<Track>().FirstOrDefault(x =>  x.TrackId == trackId);
		}

        public virtual Task<Track> GetByKeyAsync(int trackId)
			=> Task.Factory.StartNew(() => GetByKey(trackId));

		/// <summary>
		/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
		/// </summary>
				/// <param name="trackId">기본키</param>
		/// <returns>존재 여부</returns>
        public virtual bool ExistsByKey(int trackId)
		{
            using var context = DbContextFactory.Create();

			return context.Set<Track>().Count(x =>  x.TrackId == trackId) > 0;
		}

        public virtual Task<bool> ExistsByKeyAsync(int trackId)
		=> Task.Factory.StartNew(() => ExistsByKey(trackId));

		/// <summary>
		/// 기본키가 일치하는 엔터티를 삭제한다.
		/// </summary>
				/// <param name="trackId">기본키</param>
		/// <returns>삭제된 엔터티의 갯수</returns>
        public virtual int DeleteByKey(int trackId)
		{
            using var context = DbContextFactory.Create();

			var query = from x in context.Set<Track>()
			where x.TrackId == trackId
			select x;

			var entity = query.FirstOrDefault();

            if (entity == null)
                return 0;

			MarkToDelete(context, entity);

			return context.SaveChanges();
		}

        public virtual Task<int> DeleteByKeyAsync(int trackId)
		=> Task.Factory.StartNew(() => DeleteByKey(trackId));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입할 엔터티</param>
		/// <returns>삽입된 엔터티</returns>
        public virtual Track InsertIfNotExist(Track entity)
	    {
            using var context = DbContextFactory.Create();

	        if (context.Set<Track>().Count(x =>  x.TrackId == entity.TrackId) > 0)
	            return null;

	        MarkToInsert(context, entity);
	        context.SaveChanges();

	        return entity;
	    }

        public virtual Task<Track> InsertIfNotExistAsync(Track entity)
		=> Task.Factory.StartNew(() => InsertIfNotExist(entity));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 있으면 갱신하고 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입 혹은 갱신할 엔터티</param>
		/// <returns>삽입 혹은 갱신된 엔터티</returns>
        public virtual Track InsertOrUpdate(Track entity)
	    {
            using var context = DbContextFactory.Create();
            
	        if (context.Set<Track>().Count(x =>  x.TrackId == entity.TrackId) > 0)
	        {
	            MarkToUpdate(context, entity);
	            context.SaveChanges();

	            return entity;

            }
            else
	        {
	            MarkToInsert(context, entity);
	            context.SaveChanges();

	            return entity;

            }
	    }

        public virtual Task<Track> InsertOrUpdateAsync(Track entity)
		=> Task.Factory.StartNew(() => InsertOrUpdate(entity));
		

				/// <summary>
		/// 외래키 AlbumId 이(가) 일치하는 엔터티 컬렉션을 구한다.
		/// </summary>
		/// <param name="albumId">외래키</param>
		/// <returns>AlbumId 이(가) 일치하는 엔터티 컬렉션</returns>
        public virtual List<Track> GetByAlbumId(int? albumId)
		{
            using var context = DbContextFactory.Create();

			return context.Set<Track>().Where(x => x.AlbumId == albumId).ToList();
		}

        public virtual Task<List<Track>> GetByAlbumIdAsync(int? albumId)
		=> Task.Factory.StartNew(() => GetByAlbumId(albumId));
		/// <summary>
		/// 외래키 GenreId 이(가) 일치하는 엔터티 컬렉션을 구한다.
		/// </summary>
		/// <param name="genreId">외래키</param>
		/// <returns>GenreId 이(가) 일치하는 엔터티 컬렉션</returns>
        public virtual List<Track> GetByGenreId(int? genreId)
		{
            using var context = DbContextFactory.Create();

			return context.Set<Track>().Where(x => x.GenreId == genreId).ToList();
		}

        public virtual Task<List<Track>> GetByGenreIdAsync(int? genreId)
		=> Task.Factory.StartNew(() => GetByGenreId(genreId));
		/// <summary>
		/// 외래키 MediaTypeId 이(가) 일치하는 엔터티 컬렉션을 구한다.
		/// </summary>
		/// <param name="mediaTypeId">외래키</param>
		/// <returns>MediaTypeId 이(가) 일치하는 엔터티 컬렉션</returns>
        public virtual List<Track> GetByMediaTypeId(int mediaTypeId)
		{
            using var context = DbContextFactory.Create();

			return context.Set<Track>().Where(x => x.MediaTypeId == mediaTypeId).ToList();
		}

        public virtual Task<List<Track>> GetByMediaTypeIdAsync(int mediaTypeId)
		=> Task.Factory.StartNew(() => GetByMediaTypeId(mediaTypeId));
	}
	#endregion
	#endregion

	#region Types
	/// <summary>
	/// 엔티티를 추가/수정/삭제 할 때 기록하는 로그의 종류
	/// </summary>
	internal enum LogType
	{
		/// <summary>
		/// 엔티티 삽입
		/// </summary>
		Insert,

		/// <summary>
		/// 엔티티 컬렉션 삽입
		/// </summary>
		InsertMany,

		/// <summary>
		/// 엔티티 갱신
		/// </summary>
		Update,

		/// <summary>
		/// 엔티티 컬렉션 갱신
		/// </summary>
		UpdateMany,

		/// <summary>
		/// 엔티티 삭제
		/// </summary>
		Delete,

		/// <summary>
		/// 엔티티 컬렉션 삭제
		/// </summary>
		DeleteMany
	}

	/// <summary>
	/// 데이터 액세스 레이어 클래스임을 지시
	/// </summary>
	[AttributeUsage(AttributeTargets.Class)]
	public class DataAttribute : Attribute
	{
	}

	/// <summary>
	/// 서버 캐시를 사용하도록 지시
	/// </summary>
	[AttributeUsage(AttributeTargets.Class)]
	public class ForCacheAttribute : Attribute
	{
	}

	/// <summary>
	/// 서비스 메서드를 만들 것을 지시
	/// </summary>
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method)]
	public class ForServiceAttribute : Attribute
	{
	}

	/// <summary>
	/// 비동기 호출 코드를 생성할 것을 지시
	/// </summary>
	[AttributeUsage(AttributeTargets.Method, Inherited = false)]
	public class ForAsyncAttribute : Attribute
	{
	}

	/// <summary>
	/// 비지니스 코드를 생성하지 말것을 지시
	/// </summary>
	[AttributeUsage(AttributeTargets.Method)]
	public class ForCustomBizAttribute : Attribute
	{
	}

	/// <summary>
	/// 외래키를 조건으로 하는 Get 메서드 임을 지시
	/// </summary>
	[AttributeUsage(AttributeTargets.Method)]
	public class ByFKAttribute : Attribute
	{
	}

	/// <summary>
	/// 인증이 필요하지 않은 메서드임을 표현
	/// </summary>
	[AttributeUsage(AttributeTargets.Method)]
	public class NoAuthorizationAttribute : Attribute
	{
	}
	#endregion

	#region DaoBase
	/// <summary>
	/// Dao의 부모. Dao를 확장하는 용도로 사용한다.
	/// </summary>
	public partial class DaoBase
	{
	}
	#endregion

	#region Dao
	/// <summary>
	/// 각 엔터티 데이터 객체의 모음
	/// </summary>
	public partial class Dao : DaoBase
	{
		static Dao()
		{
						Album = new AlbumDao();
			Artist = new ArtistDao();
			Customer = new CustomerDao();
			Employee = new EmployeeDao();
			Genre = new GenreDao();
			Invoice = new InvoiceDao();
			InvoiceLine = new InvoiceLineDao();
			MediaType = new MediaTypeDao();
			Playlist = new PlaylistDao();
			PlaylistTrack = new PlaylistTrackDao();
			Track = new TrackDao();
		}

		#region Data objects
				public static AlbumDao Album { get; }
		public static ArtistDao Artist { get; }
		public static CustomerDao Customer { get; }
		public static EmployeeDao Employee { get; }
		public static GenreDao Genre { get; }
		public static InvoiceDao Invoice { get; }
		public static InvoiceLineDao InvoiceLine { get; }
		public static MediaTypeDao MediaType { get; }
		public static PlaylistDao Playlist { get; }
		public static PlaylistTrackDao PlaylistTrack { get; }
		public static TrackDao Track { get; }
		#endregion
		}
	#endregion

	#region ChinookContextLoggerFactory
    /// <summary>
    /// 간단하게 사용할 수 있는 엔터티 프레임워크 코어용 로거 팩토리. Console과 Debug의 출력창 혹은 파일에 저장 할 수 있음
    /// </summary>
    internal class ChinookContextLoggerFactory : LoggerFactory
    {
        #region singleton
        private static ChinookContextLoggerFactory _instance;

        public static ChinookContextLoggerFactory GetInstance(LoggerType loggerType = LoggerType.Console)
        {
            if (_instance == null)
            {
                _loggerType = loggerType;

                _instance = new ChinookContextLoggerFactory(
                                new List<ILoggerProvider>{new LogProvider()}
                );
            }

            return _instance;
        }

        private ChinookContextLoggerFactory(List<ILoggerProvider> providers) : base(providers)
        {
        }

        private static LoggerType _loggerType;

        #endregion

        internal class LogProvider : ILoggerProvider
        {
            public void Dispose()
            {
            }

            public ILogger CreateLogger(string categoryName)
            {
                return new Logger(categoryName, _loggerType);
            }
        }

        internal class Logger : ILogger
        {
            private readonly IWriter _writer;

            private readonly string _categoryName;

            public Logger(string categoryName, LoggerType loggerType)
            {
                _categoryName = categoryName;

                _writer = loggerType switch
                {
                    LoggerType.Console => new ConsoleWriter(),
                    LoggerType.Debug => new DebugWriter(),
                    LoggerType.File => new FileWriter(),
                    _ => throw new NotImplementedException("Logger.Logger")
                };
            }

            private static int _no = 1;

            public void Log<TState>(LogLevel logLevel, EventId eventId, TState state, Exception exception, Func<TState, Exception, string> formatter)
            {
                if (_writer == null)
                    return;

                _writer.WriteLine($"[{_no++:N0}] at {DateTime.Now.ToString()}");
                _writer.WriteLine(formatter(state, exception));
                _writer.WriteLine("-------------------------");
                _writer.Save();
            }

            public bool IsEnabled(LogLevel logLevel)
            {
                return logLevel == LogLevel.Information &&
                       _categoryName == DbLoggerCategory.Database.Command.Name;
            }

            public IDisposable BeginScope<TState>(TState state)
            {
                return null;
            }
        }

        public interface IWriter
        {
            void WriteLine(string format, params object[] args);
            void Save();
        }

        internal abstract class UnsavableWriter : IWriter
        {
            public abstract void WriteLine(string format, params object[] args);

            public void Save()
            {
            }
        }

        internal class ConsoleWriter : UnsavableWriter
        {
            public override void WriteLine(string format, params object[] args)
            {
                Console.WriteLine(format, args);
            }
        }

        internal class DebugWriter : UnsavableWriter
        {
            public override void WriteLine(string format, params object[] args)
            {
                Debug.WriteLine(format, args);
            }
        }

        internal class FileWriter : IWriter
        {
            private readonly string _logFilePath;

            public FileWriter(string logFilePath = "ChinookContextContextLoggerFactory.log")
            {
                _logFilePath = logFilePath;
            }

            private readonly StringBuilder _builder = new StringBuilder();

            public void WriteLine(string format, params object[] args)
            {
                _builder.AppendFormat(format, args);
                _builder.AppendLine();
            }

            public void Save()
            {
                File.WriteAllText(_logFilePath, _builder.ToString());
            }
        }
    }

    internal enum LoggerType
    {
        /// <summary>
        /// 콘솔에 출력
        /// </summary>
        Console,
        /// <summary>
        /// 디버거 창에 출력
        /// </summary>
        Debug,
        /// <summary>
        /// 파일에 출력
        /// </summary>
        File
    }
	#endregion
}
