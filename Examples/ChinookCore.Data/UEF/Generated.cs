
/*
This file has been generated by UsingEntityFrameworkCore on 2021-05-12 오후 6:56:18.
You may not need to modify this file.
*/
#region
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
#endregion

namespace ChinookCore.Data
{
	#region Entities

    #region IEntity
    public partial interface IEntity
    {
    }
    #endregion

	#region Untyped Entity
	/// <summary>
	///   모든 엔터티 클래스의 부모 클래스
	/// </summary>
	public abstract partial class UntypedEntity : IEntity
	{
		/// <summary>
		///   부가정보를 저장하기 위한 object 객체
		/// </summary>
		[NotMapped]
		public object EntityTag { get; set; }

		/// <summary>
		///   모든 속성의 값을 초기화한다.string형 속성은 string.Empty 값으로 채우고, DateTime형 속성은 DateTime.Today 값으로 채운다.
		/// </summary>
		/// <returns> 생성된 엔터티 </returns>
		public void Clear()
		{
			Clear(string.Empty, DateTime.Today);
		}

		/// <summary>
		///   모든 속성의 값을 초기화한다. string형 속성은 string.Empty 값으로 채우고, DateTime형 속성은 기본 DateTime 값으로 채운다.
		/// </summary>
		/// <param name="defaultDateTime"> 기본 DateTime 값 </param>
		/// <returns> 생성된 엔터티 </returns>
		public void Clear(DateTime defaultDateTime)
		{
			Clear(string.Empty, defaultDateTime);
		}

		/// <summary>
		///   모든 속성의 값을 초기화한다. string형 속성은 기본 string 값으로 채우고, DateTime형 속성은 기본 DateTime 값으로 채운다.
		/// </summary>
		/// <param name="defaultString"> 기본 string 값 </param>
		/// <param name="defaultDateTime"> 기본 DateTime 값 </param>
		/// <returns> 생성된 엔터티 </returns>
		public void Clear(string defaultString, DateTime defaultDateTime)
		{
			Type type = GetType();
			PropertyInfo[] propertyInfoArray = type.GetProperties(BindingFlags.Instance | BindingFlags.Public);

			foreach (PropertyInfo propertyInfo in propertyInfoArray)
			{
				if (propertyInfo.CanWrite == false)
					continue;

				if (propertyInfo.PropertyType == typeof (string))
					propertyInfo.SetValue(this, defaultString, null);

				else if (propertyInfo.PropertyType == typeof (DateTime))
					propertyInfo.SetValue(this, defaultDateTime, null);
			}
		}

		/// <summary>
		///   기본키 값들을 구분자(":")로 연결하여 반환한다.
		/// </summary>
		/// <returns> </returns>
		public abstract string PrimaryKeyValues {get;}

		/// <summary>
		/// 엔터티를 대표하는 문자열을 구한다.
		/// </summary>
		public abstract string EntityText { get; }

		/// <summary>
		///   엔터티의 이름을 구한다.
		/// </summary>
		public abstract string GetEntityTypeName();

		partial void IsLogWritable(ref bool? logWritable);

		public virtual bool LogWritable
		{
			get
			{
			bool? logWritable = null;
			IsLogWritable(ref logWritable);

			if (logWritable.HasValue)
				return logWritable.Value;

			return false;
			}
		}

		/// <summary>
		///   EntityLog에 찍힐 문자열을 구한다. Code로 끝나는 코드 프로퍼티의 경우 대응하는 문자열 프로퍼티의 값도 추가한다.
		///   주의) EntityLog 테이블의 설계 상 최대 2000자 까지만 저장할 수 있음.
		/// </summary>
		/// <returns> </returns>
		public virtual string ToEntityLog()
		{
			const int MaxLength = 2000; // 최대 2000자 까지만 저장.

			Type type = GetType();

			var propertyInfoes = type.GetProperties();

			StringBuilder builder = new StringBuilder(ToString());

			builder.AppendLine();
			foreach (var propertyInfo in propertyInfoes)
			{
				if (propertyInfo.PropertyType != typeof (int))
					continue;

				if (propertyInfo.Name.EndsWith("Code") == false)
					continue;

				string textPropertyName = propertyInfo.Name.Substring(0, propertyInfo.Name.Length - 4) + "Text";
				string textValue = GetTextFromCodeProperty(this, type, textPropertyName);

				if (textValue != null)
					builder.AppendFormat("[{0}] {1}{2}", textPropertyName, textValue, Environment.NewLine);
			}

			if (builder.Length > MaxLength)
				return builder.ToString(0, MaxLength);
			else
				return builder.ToString();
		}

		private static string GetTextFromCodeProperty(object entity, Type objectType, string textPropertyName)
		{
			var propertyInfo = objectType.GetProperty(textPropertyName);
			object propertyValue = propertyInfo.GetValue(entity, null);

			if (propertyValue is string)
				return (string) propertyValue;
			else
				return null;
		}
	}
	#endregion

	#region Entity<T>
	/// <summary>
	/// 모든 엔터티 클래스의 형이 지정된 부모 클래스
	/// </summary>
	/// <typeparam name="T">엔터티 클래스의 형식</typeparam>
	public abstract partial class Entity<T> : UntypedEntity, IEditableObject where T : class, new()
	{
		/// <summary>
		/// 객체를 복사한다.
		/// </summary>
		/// <returns></returns>
		public abstract T Clone();

		#region Implementation of IEditableObject

		protected T _clone = null;

		/// <summary>
		/// IEditableObject.BeginEdit 구현
		/// </summary>
		public void BeginEdit()
		{
			if (_clone == null)
				_clone = Clone();
		}

		/// <summary>
		/// IEditableObject.EndEdit 구현
		/// </summary>
		public void EndEdit()
		{
			_clone = null;
		}

		public abstract void CancelEdit();

	#endregion
	}

	#endregion

		#region Album
    /// <summary>
	/// Album 엔터티
	/// </summary>
    public partial class Album : Entity<Album>, IEntity
	{
		public const string EntityTypeName = "Album";

		public static void Copy(Album source, Album target)
		{
						target.AlbumId = source.AlbumId;		
			target.ArtistId = source.ArtistId;		
			target.Title = source.Title;
		}

		/// <summary>
		/// Album 객체를 복사한다.
		/// </summary>
		/// <returns></returns>
		public override Album Clone()
		{
			var clone = new Album();

			Copy(this, clone);

			return clone;
		}

		partial void GetEntityTextCore(ref string value);

		/// <summary>
		/// Album 객체를 대표하는 이름을 구한다.
		/// </summary>
		/// <returns></returns>
		public override string EntityText
		{
			get 
			{ 
				string value = null;
				GetEntityTextCore(ref value);

				if (value != null)
					return value;

				return PrimaryKeyValues; 
			}
		}

		partial void ToStringCore(ref string value);

		public override string ToString()
		{
			string value = null;
			ToStringCore(ref value);

			if (value != null)
				return value;

			return "[AlbumId]" + AlbumId + ", " + "[ArtistId]" + ArtistId + ", " + "[Title]" + Title;
		}

		/// <summary>
		/// IEditableObject.CancelEdit 구현
		/// </summary>
		public override void CancelEdit()
		{
			if (_clone != null)
				Copy(_clone, this);
		}

		public override string PrimaryKeyValues
		{
			get { return string.Join(":", AlbumId); }
		}

		public override string GetEntityTypeName()
		{
			return EntityTypeName;
		}
	}

	/// <summary>
	/// Album 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
	/// </summary>
	public enum AlbumColumn
	{
				AlbumId,
		ArtistId,
		Title
	}

	
	/// <summary>
	/// Album 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer<Album> 구현)
	/// </summary>
	public class AlbumEqualityComparer : IEqualityComparer<Album>
	{
		public bool Equals(Album x, Album y)
		{
			return x.AlbumId == y.AlbumId;
		}

		public int GetHashCode(Album obj)
		{
			return obj.AlbumId.GetHashCode();
		}
	}
	
	#endregion
	#region Artist
    /// <summary>
	/// Artist 엔터티
	/// </summary>
    public partial class Artist : Entity<Artist>, IEntity
	{
		public const string EntityTypeName = "Artist";

		public static void Copy(Artist source, Artist target)
		{
						target.ArtistId = source.ArtistId;		
			target.Name = source.Name;
		}

		/// <summary>
		/// Artist 객체를 복사한다.
		/// </summary>
		/// <returns></returns>
		public override Artist Clone()
		{
			var clone = new Artist();

			Copy(this, clone);

			return clone;
		}

		partial void GetEntityTextCore(ref string value);

		/// <summary>
		/// Artist 객체를 대표하는 이름을 구한다.
		/// </summary>
		/// <returns></returns>
		public override string EntityText
		{
			get 
			{ 
				string value = null;
				GetEntityTextCore(ref value);

				if (value != null)
					return value;

				return PrimaryKeyValues; 
			}
		}

		partial void ToStringCore(ref string value);

		public override string ToString()
		{
			string value = null;
			ToStringCore(ref value);

			if (value != null)
				return value;

			return "[ArtistId]" + ArtistId + ", " + "[Name]" + Name;
		}

		/// <summary>
		/// IEditableObject.CancelEdit 구현
		/// </summary>
		public override void CancelEdit()
		{
			if (_clone != null)
				Copy(_clone, this);
		}

		public override string PrimaryKeyValues
		{
			get { return string.Join(":", ArtistId); }
		}

		public override string GetEntityTypeName()
		{
			return EntityTypeName;
		}
	}

	/// <summary>
	/// Artist 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
	/// </summary>
	public enum ArtistColumn
	{
				ArtistId,
		Name
	}

	
	/// <summary>
	/// Artist 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer<Artist> 구현)
	/// </summary>
	public class ArtistEqualityComparer : IEqualityComparer<Artist>
	{
		public bool Equals(Artist x, Artist y)
		{
			return x.ArtistId == y.ArtistId;
		}

		public int GetHashCode(Artist obj)
		{
			return obj.ArtistId.GetHashCode();
		}
	}
	
	#endregion
	#region Playlist
    /// <summary>
	/// Playlist 엔터티
	/// </summary>
    public partial class Playlist : Entity<Playlist>, IEntity
	{
		public const string EntityTypeName = "Playlist";

		public static void Copy(Playlist source, Playlist target)
		{
						target.PlaylistId = source.PlaylistId;		
			target.Name = source.Name;
		}

		/// <summary>
		/// Playlist 객체를 복사한다.
		/// </summary>
		/// <returns></returns>
		public override Playlist Clone()
		{
			var clone = new Playlist();

			Copy(this, clone);

			return clone;
		}

		partial void GetEntityTextCore(ref string value);

		/// <summary>
		/// Playlist 객체를 대표하는 이름을 구한다.
		/// </summary>
		/// <returns></returns>
		public override string EntityText
		{
			get 
			{ 
				string value = null;
				GetEntityTextCore(ref value);

				if (value != null)
					return value;

				return PrimaryKeyValues; 
			}
		}

		partial void ToStringCore(ref string value);

		public override string ToString()
		{
			string value = null;
			ToStringCore(ref value);

			if (value != null)
				return value;

			return "[PlaylistId]" + PlaylistId + ", " + "[Name]" + Name;
		}

		/// <summary>
		/// IEditableObject.CancelEdit 구현
		/// </summary>
		public override void CancelEdit()
		{
			if (_clone != null)
				Copy(_clone, this);
		}

		public override string PrimaryKeyValues
		{
			get { return string.Join(":", PlaylistId); }
		}

		public override string GetEntityTypeName()
		{
			return EntityTypeName;
		}
	}

	/// <summary>
	/// Playlist 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
	/// </summary>
	public enum PlaylistColumn
	{
				PlaylistId,
		Name
	}

	
	/// <summary>
	/// Playlist 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer<Playlist> 구현)
	/// </summary>
	public class PlaylistEqualityComparer : IEqualityComparer<Playlist>
	{
		public bool Equals(Playlist x, Playlist y)
		{
			return x.PlaylistId == y.PlaylistId;
		}

		public int GetHashCode(Playlist obj)
		{
			return obj.PlaylistId.GetHashCode();
		}
	}
	
	#endregion
	#region PlaylistTrack
    /// <summary>
	/// PlaylistTrack 엔터티
	/// </summary>
    public partial class PlaylistTrack : Entity<PlaylistTrack>, IEntity
	{
		public const string EntityTypeName = "PlaylistTrack";

		public static void Copy(PlaylistTrack source, PlaylistTrack target)
		{
						target.PlaylistId = source.PlaylistId;		
			target.TrackId = source.TrackId;		
			target.Dummy = source.Dummy;
		}

		/// <summary>
		/// PlaylistTrack 객체를 복사한다.
		/// </summary>
		/// <returns></returns>
		public override PlaylistTrack Clone()
		{
			var clone = new PlaylistTrack();

			Copy(this, clone);

			return clone;
		}

		partial void GetEntityTextCore(ref string value);

		/// <summary>
		/// PlaylistTrack 객체를 대표하는 이름을 구한다.
		/// </summary>
		/// <returns></returns>
		public override string EntityText
		{
			get 
			{ 
				string value = null;
				GetEntityTextCore(ref value);

				if (value != null)
					return value;

				return PrimaryKeyValues; 
			}
		}

		partial void ToStringCore(ref string value);

		public override string ToString()
		{
			string value = null;
			ToStringCore(ref value);

			if (value != null)
				return value;

			return "[PlaylistId]" + PlaylistId + ", " + "[TrackId]" + TrackId + ", " + "[Dummy]" + Dummy;
		}

		/// <summary>
		/// IEditableObject.CancelEdit 구현
		/// </summary>
		public override void CancelEdit()
		{
			if (_clone != null)
				Copy(_clone, this);
		}

		public override string PrimaryKeyValues
		{
			get { return string.Join(":", PlaylistId, TrackId); }
		}

		public override string GetEntityTypeName()
		{
			return EntityTypeName;
		}
	}

	/// <summary>
	/// PlaylistTrack 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
	/// </summary>
	public enum PlaylistTrackColumn
	{
				PlaylistId,
		TrackId,
		Dummy
	}

	
	/// <summary>
	/// PlaylistTrack 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer<PlaylistTrack> 구현)
	/// </summary>
	public class PlaylistTrackEqualityComparer : IEqualityComparer<PlaylistTrack>
	{
		public bool Equals(PlaylistTrack x, PlaylistTrack y)
		{
			return x.PlaylistId == y.PlaylistId && x.TrackId == y.TrackId;
		}

		public int GetHashCode(PlaylistTrack obj)
		{
			return obj.PlaylistId.GetHashCode() ^ obj.TrackId.GetHashCode();
		}
	}
	
	#endregion
	#region Track
    /// <summary>
	/// Track 엔터티
	/// </summary>
    public partial class Track : Entity<Track>, IEntity
	{
		public const string EntityTypeName = "Track";

		public static void Copy(Track source, Track target)
		{
						target.TrackId = source.TrackId;		
			target.AlbumId = source.AlbumId;		
			target.BigIntCol = source.BigIntCol;		
			target.BigIntColNull = source.BigIntColNull;		
			target.BinaryCol = source.BinaryCol;		
			target.BinaryColNull = source.BinaryColNull;		
			target.BitCol = source.BitCol;		
			target.BitColNull = source.BitColNull;		
			target.CharCol = source.CharCol;		
			target.CharColNull = source.CharColNull;		
			target.DateCol = source.DateCol;		
			target.DateColNull = source.DateColNull;		
			target.DateTimeCol = source.DateTimeCol;		
			target.DateTimeColNull = source.DateTimeColNull;		
			target.DecimalCol = source.DecimalCol;		
			target.DecimalColNull = source.DecimalColNull;		
			target.FloatCol = source.FloatCol;		
			target.FloatColNull = source.FloatColNull;		
			target.GuidCol = source.GuidCol;		
			target.GuidColNull = source.GuidColNull;		
			target.Name = source.Name;		
			target.NcharCol = source.NcharCol;		
			target.NcharColNull = source.NcharColNull;		
			target.NvarCharCol = source.NvarCharCol;		
			target.NvarCharColNull = source.NvarCharColNull;		
			target.RealCol = source.RealCol;		
			target.RealColNull = source.RealColNull;		
			target.SmallDateTimeCol = source.SmallDateTimeCol;		
			target.SmallDateTimeColNull = source.SmallDateTimeColNull;		
			target.SmallIntCol = source.SmallIntCol;		
			target.SmallIntColNull = source.SmallIntColNull;		
			target.SmallMoneyCol = source.SmallMoneyCol;		
			target.SmallMoneyColNull = source.SmallMoneyColNull;		
			target.TimeCol = source.TimeCol;		
			target.TimeColNull = source.TimeColNull;		
			target.TimeStampCol = source.TimeStampCol;		
			target.TinyIntCol = source.TinyIntCol;		
			target.TinyIntColNull = source.TinyIntColNull;		
			target.VarBinaryCol = source.VarBinaryCol;		
			target.VarBinaryColNull = source.VarBinaryColNull;		
			target.VarCharCol = source.VarCharCol;		
			target.VarCharColNull = source.VarCharColNull;
		}

		/// <summary>
		/// Track 객체를 복사한다.
		/// </summary>
		/// <returns></returns>
		public override Track Clone()
		{
			var clone = new Track();

			Copy(this, clone);

			return clone;
		}

		partial void GetEntityTextCore(ref string value);

		/// <summary>
		/// Track 객체를 대표하는 이름을 구한다.
		/// </summary>
		/// <returns></returns>
		public override string EntityText
		{
			get 
			{ 
				string value = null;
				GetEntityTextCore(ref value);

				if (value != null)
					return value;

				return PrimaryKeyValues; 
			}
		}

		partial void ToStringCore(ref string value);

		public override string ToString()
		{
			string value = null;
			ToStringCore(ref value);

			if (value != null)
				return value;

			return "[TrackId]" + TrackId + ", " + "[AlbumId]" + AlbumId + ", " + "[BigIntCol]" + BigIntCol + ", " + "[BigIntColNull]" + BigIntColNull + ", " + "[BinaryCol]" + BinaryCol + ", " + "[BinaryColNull]" + BinaryColNull + ", " + "[BitCol]" + BitCol + ", " + "[BitColNull]" + BitColNull + ", " + "[CharCol]" + CharCol + ", " + "[CharColNull]" + CharColNull + ", " + "[DateCol]" + DateCol + ", " + "[DateColNull]" + DateColNull + ", " + "[DateTimeCol]" + DateTimeCol + ", " + "[DateTimeColNull]" + DateTimeColNull + ", " + "[DecimalCol]" + DecimalCol + ", " + "[DecimalColNull]" + DecimalColNull + ", " + "[FloatCol]" + FloatCol + ", " + "[FloatColNull]" + FloatColNull + ", " + "[GuidCol]" + GuidCol + ", " + "[GuidColNull]" + GuidColNull + ", " + "[Name]" + Name + ", " + "[NcharCol]" + NcharCol + ", " + "[NcharColNull]" + NcharColNull + ", " + "[NvarCharCol]" + NvarCharCol + ", " + "[NvarCharColNull]" + NvarCharColNull + ", " + "[RealCol]" + RealCol + ", " + "[RealColNull]" + RealColNull + ", " + "[SmallDateTimeCol]" + SmallDateTimeCol + ", " + "[SmallDateTimeColNull]" + SmallDateTimeColNull + ", " + "[SmallIntCol]" + SmallIntCol + ", " + "[SmallIntColNull]" + SmallIntColNull + ", " + "[SmallMoneyCol]" + SmallMoneyCol + ", " + "[SmallMoneyColNull]" + SmallMoneyColNull + ", " + "[TimeCol]" + TimeCol + ", " + "[TimeColNull]" + TimeColNull + ", " + "[TimeStampCol]" + TimeStampCol + ", " + "[TinyIntCol]" + TinyIntCol + ", " + "[TinyIntColNull]" + TinyIntColNull + ", " + "[VarBinaryCol]" + VarBinaryCol + ", " + "[VarBinaryColNull]" + VarBinaryColNull + ", " + "[VarCharCol]" + VarCharCol + ", " + "[VarCharColNull]" + VarCharColNull;
		}

		/// <summary>
		/// IEditableObject.CancelEdit 구현
		/// </summary>
		public override void CancelEdit()
		{
			if (_clone != null)
				Copy(_clone, this);
		}

		public override string PrimaryKeyValues
		{
			get { return string.Join(":", TrackId); }
		}

		public override string GetEntityTypeName()
		{
			return EntityTypeName;
		}
	}

	/// <summary>
	/// Track 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
	/// </summary>
	public enum TrackColumn
	{
				TrackId,
		AlbumId,
		BigIntCol,
		BigIntColNull,
		BinaryCol,
		BinaryColNull,
		BitCol,
		BitColNull,
		CharCol,
		CharColNull,
		DateCol,
		DateColNull,
		DateTimeCol,
		DateTimeColNull,
		DecimalCol,
		DecimalColNull,
		FloatCol,
		FloatColNull,
		GuidCol,
		GuidColNull,
		Name,
		NcharCol,
		NcharColNull,
		NvarCharCol,
		NvarCharColNull,
		RealCol,
		RealColNull,
		SmallDateTimeCol,
		SmallDateTimeColNull,
		SmallIntCol,
		SmallIntColNull,
		SmallMoneyCol,
		SmallMoneyColNull,
		TimeCol,
		TimeColNull,
		TimeStampCol,
		TinyIntCol,
		TinyIntColNull,
		VarBinaryCol,
		VarBinaryColNull,
		VarCharCol,
		VarCharColNull
	}

	
	/// <summary>
	/// Track 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer<Track> 구현)
	/// </summary>
	public class TrackEqualityComparer : IEqualityComparer<Track>
	{
		public bool Equals(Track x, Track y)
		{
			return x.TrackId == y.TrackId;
		}

		public int GetHashCode(Track obj)
		{
			return obj.TrackId.GetHashCode();
		}
	}
	
	#endregion

	#endregion

	#region PropertyChangedEventArgs
	/// <summary>
	/// 속성 값이 변경된 후 발생하는 이벤트의 매개변수 클래스
	/// </summary>
	/// <typeparam name="T"></typeparam>
	internal class PropertyChangedEventArgs<T> : EventArgs where T : Entity<T>, new()
	{
		/// <summary>
		/// 속성 값이 변경된 엔티티
		/// </summary>
		public T Entity { get; set; }

		public PropertyChangedEventArgs(T entity)
		{
			Entity = entity;
		}
	}

	/// <summary>
	/// 속성 값이 변경되기 전 발생하는 이벤트의 매개변수 클래스
	/// </summary>
	/// <typeparam name="T"></typeparam>
	/// <typeparam name="K"></typeparam>
	internal class PropertyChangingEventArgs<T, K> : EventArgs where T : Entity<T>, new()
	{
		/// <summary>
		/// 속성 값이 변경될 엔티티
		/// </summary>
		public T Entity { get; set; }

		/// <summary>
		/// 새로 변경 될 속성 값
		/// </summary>
		public K Value { get; set; }

		public PropertyChangingEventArgs(T entity, K value)
		{
			Entity = entity;
			Value = value;
		}
	}
	#endregion

	#region Data
	#region EntityData<T>
	[Data]
	public abstract partial class EntityData<T> where T : Entity<T>, new()
	{
		internal EntityData() { }

		#region Create
		/// <summary>
		/// 엔터티를 생성한다. string형 속성은 string.Empty 값으로 채우고, DateTime형 속성은 DateTime.Today 값으로 채운다.
		/// </summary>
		/// <returns>생성된 엔터티</returns>
		public virtual T Create()
		{
			return Create(string.Empty, DateTime.Today);
		}

		/// <summary>
		/// 엔터티를 생성한다. string형 속성은 string.Empty 값으로 채우고, DateTime형 속성은 기본 DateTime 값으로 채운다.
		/// </summary>
		/// <param name="defaultDateTime">기본 DateTime 값</param>
		/// <returns>생성된 엔터티</returns>
		public virtual T Create(DateTime defaultDateTime)
		{
			return Create(string.Empty, defaultDateTime);
		}

		/// <summary>
		/// 엔터티를 생성한다. string형 속성은 기본 string 값으로 채우고, DateTime형 속성은 기본 DateTime 값으로 채운다.
		/// </summary>
		/// <param name="defaultString">기본 string 값</param>
		/// <param name="defaultDateTime">기본 DateTime 값</param>
		/// <returns>생성된 엔터티</returns>
		public virtual T Create(string defaultString, DateTime defaultDateTime)
		{
			T entity = new T();
			entity.Clear(defaultString, defaultDateTime);

			return entity;
		}
		#endregion

		#region Get
		/// <summary>
		/// 모든 엔터티를 반환한다.
		/// </summary>
		/// <returns>엔터티의 리스트</returns>
        public virtual List<T> Get()
		{
			return Get<T>(null, null, false, 0, int.MaxValue);
		}

        public virtual Task<List<T>> GetAsync() 
            => Task.Factory.StartNew(() => Get());

        /// <summary>
        /// 조건식에 맞는 엔터티들을 반환한다.
        /// </summary>
        /// <param name="where">조건식</param>
        /// <returns>엔터티의 리스트</returns>
        public virtual List<T> Get(Expression<Func<T, bool>> where)
		{
			return Get<T>(where, null, false, 0, int.MaxValue);
		}

        public virtual Task<List<T>> GetAsync(Expression<Func<T, bool>> where)
            => Task.Factory.StartNew(() => Get(where));

		/// <summary>
		/// 모든 엔터티들을 정렬식에 따라 정렬한 후 반환한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
		/// </summary>
		/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
		/// <param name="orderBy">정렬식</param>
		/// <param name="ascending">true이면 오름차순, false이면 내림차순</param>
		/// <returns>엔터티의 리스트</returns>
        public virtual List<T> Get<U>(Expression<Func<T, U>> orderBy, bool ascending)
		{
			return Get(null, orderBy, ascending, 0, int.MaxValue);
		}

        public virtual Task<List<T>> GetAsync<U>(Expression<Func<T, U>> orderBy, bool ascending)
            => Task.Factory.StartNew(() => Get(orderBy, ascending));

		/// <summary>
		/// 조건식에 맞는 엔터티들을 정렬식에 따라 정렬한 후 반환한다. 페이징을 지원한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
		/// </summary>
		/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
		/// <param name="orderBy">정렬식</param>
		/// <param name="ascending">true이면 오름차순, false이면 내림차순</param>
		/// <param name="startRowIndex">반환할 엔터티의 시작 인덱스</param>
		/// <param name="maximumRows">반환할 엔터티의 갯수</param>
		/// <returns>엔터티의 리스트</returns>
        public virtual List<T> Get<U>(Expression<Func<T, U>> orderBy, bool ascending, int startRowIndex, int maximumRows)
		{
			return Get(null, orderBy, ascending, startRowIndex, maximumRows);
		}

        public virtual Task<List<T>> GetAsync<U>(Expression<Func<T, U>> orderBy, bool ascending, int startRowIndex, int maximumRows)
            => Task.Factory.StartNew(() => Get(orderBy, ascending, startRowIndex, maximumRows));

		/// <summary>
		/// 조건식에 맞는 엔터티들을 정렬식에 따라 정렬한 후 반환한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
		/// </summary>
		/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
		/// <param name="where">조건식</param>
		/// <param name="orderBy">정렬식</param>
		/// <param name="ascending">true이면 오름차순, false이면 내림차순</param>
		/// <returns>엔터티의 리스트</returns>
        public virtual List<T> Get<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending)
		{
			return Get(where, orderBy, ascending, 0, int.MaxValue);
		}

        public virtual Task<List<T>> GetAsync<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending)
            => Task.Factory.StartNew(() => Get(where, orderBy, ascending));

		/// <summary>
		/// 조건식에 맞는 엔터티들을 정렬식에 따라 정렬한 후 반환한다. 페이징을 지원한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
		/// </summary>
		/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
		/// <param name="where">조건식</param>
		/// <param name="orderBy">정렬식</param>
		/// <param name="ascending">true이면 오름차순, false이면 내림차순</param>
		/// <param name="startRowIndex">반환할 엔터티의 시작 인덱스</param>
		/// <param name="maximumRows">반환할 엔터티의 갯수</param>
		/// <returns>엔터티의 리스트</returns>
        public virtual List<T> Get<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending, int startRowIndex, int maximumRows)
		{
            using var context = ChinookContext.Create();

            return GetCore(where, orderBy, ascending, startRowIndex, maximumRows, context).ToList();
		}

        public virtual Task<List<T>> GetAsync<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending, int startRowIndex, int maximumRows)
            => Task.Factory.StartNew(() => Get(where, orderBy, ascending, startRowIndex, maximumRows));
		#endregion

		#region select
		/// <summary>
		///   모든 선택식의 결과를 반환한다.
		/// </summary>
		/// <typeparam name="R"> 선택 형식 </typeparam>
		/// <param name="select"> 선택식 </param>
		/// <returns> 엔터티의 리스트 </returns>
        public virtual List<R> Select<R>(Expression<Func<T, R>> select)
		{
			return Select<T, R>(null, null, false, 0, int.MaxValue, select);
		}

        public virtual Task<List<R>> SelectAsync<R>(Expression<Func<T, R>> select)
            => Task.Factory.StartNew(() => Select(select));

		/// <summary>
		///   조건식에 맞는 선택식의 결과를 반환한다.
		/// </summary>
		/// <typeparam name="R"> 선택 형식 </typeparam>
		/// <param name="where"> 조건식 </param>
		/// <param name="select"> 선택식 </param>
		/// <returns> 엔터티의 리스트 </returns>
        public virtual List<R> Select<R>(Expression<Func<T, bool>> where, Expression<Func<T, R>> select)
		{
			return Select<T, R>(where, null, false, 0, int.MaxValue, select);
		}

        public virtual Task<List<R>> SelectAsync<R>(Expression<Func<T, bool>> where, Expression<Func<T, R>> select)
            => Task.Factory.StartNew(() => Select(where, select));

		/// <summary>
		///   모든 엔터티들을 정렬식에 따라 정렬한 후 선택식의 결과를 반환한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
		/// </summary>
		/// <typeparam name="U"> 정렬 기준이 되는 속성의 형식 </typeparam>
		/// <typeparam name="R"> 선택 형식 </typeparam>
		/// <param name="orderBy"> 정렬식 </param>
		/// <param name="ascending"> true이면 오름차순, false이면 내림차순 </param>
		/// <param name="select"> 선택식 </param>
		/// <returns> 엔터티의 리스트 </returns>
        public virtual List<R> Select<U, R>(Expression<Func<T, U>> orderBy, bool ascending, Expression<Func<T, R>> select)
		{
			return Select(null, orderBy, ascending, 0, int.MaxValue, select);
		}

        public virtual Task<List<R>> SelectAsync<U, R>(Expression<Func<T, U>> orderBy, bool ascending, Expression<Func<T, R>> select)
            => Task.Factory.StartNew(() => Select(orderBy, ascending, select));

		/// <summary>
		///   조건식에 맞는 엔터티들을 정렬식에 따라 정렬한 후 선택식의 결과를 반환한다. 페이징을 지원한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
		/// </summary>
		/// <typeparam name="U"> 정렬 기준이 되는 속성의 형식 </typeparam>
		/// <typeparam name="R"> 선택 형식 </typeparam>
		/// <param name="orderBy"> 정렬식 </param>
		/// <param name="ascending"> true이면 오름차순, false이면 내림차순 </param>
		/// <param name="startRowIndex"> 반환할 엔터티의 시작 인덱스 </param>
		/// <param name="maximumRows"> 반환할 엔터티의 갯수 </param>
		/// <param name="select"> 선택식 </param>
		/// <returns> 엔터티의 리스트 </returns>
        public virtual List<R> Select<U, R>(Expression<Func<T, U>> orderBy, bool ascending, int startRowIndex, int maximumRows, Expression<Func<T, R>> select)
		{
			return Select(null, orderBy, ascending, startRowIndex, maximumRows, select);
		}

        public virtual Task<List<R>> SelectAsync<U, R>(Expression<Func<T, U>> orderBy, bool ascending, int startRowIndex, int maximumRows, Expression<Func<T, R>> select)
            => Task.Factory.StartNew(() => Select(orderBy, ascending, startRowIndex, maximumRows, select));
		

		/// <summary>
		///   조건식에 맞는 엔터티들을 정렬식에 따라 정렬한 후 선택식의 결과를 반환한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
		/// </summary>
		/// <typeparam name="U"> 정렬 기준이 되는 속성의 형식 </typeparam>
		/// <typeparam name="R"> 선택 형식 </typeparam>
		/// <param name="where"> 조건식 </param>
		/// <param name="orderBy"> 정렬식 </param>
		/// <param name="ascending"> true이면 오름차순, false이면 내림차순 </param>
		/// <param name="select"> 선택식 </param>
		/// <returns> 엔터티의 리스트 </returns>
        public virtual List<R> Select<U, R>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending, Expression<Func<T, R>> select)
		{
			return Select(where, orderBy, ascending, 0, int.MaxValue, select);
		}

        public virtual Task<List<R>> SelectAsync<U, R>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending, Expression<Func<T, R>> select)
            => Task.Factory.StartNew(() => Select(where, orderBy, ascending, select));

		/// <summary>
		///   조건식에 맞는 엔터티들을 정렬식에 따라 정렬한 후 선택식의 결과를 반환한다. 페이징과 프로젝션을을 지원한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
		/// </summary>
		/// <typeparam name="U"> 정렬 기준이 되는 속성의 형식 </typeparam>
		/// <typeparam name="R"> 선택 형식 </typeparam>
		/// <param name="where"> 조건식 </param>
		/// <param name="orderBy"> 정렬식 </param>
		/// <param name="ascending"> true이면 오름차순, false이면 내림차순 </param>
		/// <param name="startRowIndex"> 반환할 엔터티의 시작 인덱스 </param>
		/// <param name="maximumRows"> 반환할 엔터티의 갯수 </param>
		/// <param name="select"> 선택식 </param>
		/// <returns> 엔터티의 리스트 </returns>
        public virtual List<R> Select<U, R>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending, int startRowIndex, int maximumRows, Expression<Func<T, R>> select)
		{
            using var context = ChinookContext.Create();

				var query = GetCore(where, orderBy, ascending, startRowIndex, maximumRows, context);
				return query.Select(select).ToList();
		}

        public virtual Task<List<R>> SelectAsync<U, R>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending, int startRowIndex, int maximumRows, Expression<Func<T, R>> select)
            => Task.Factory.StartNew(() => Select(where, orderBy, ascending, startRowIndex, maximumRows, select));

		private static IQueryable<T> GetCore<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending, int startRowIndex, int maximumRows, ChinookContext context)
		{
			var query = from x in context.Set<T>()
						select x;

			if (where != null)
				query = query.Where(where);

			IOrderedQueryable<T> orderedQuery = null;

			if (orderBy != null)
				orderedQuery = (ascending) ? query.OrderBy(orderBy) : query.OrderByDescending(orderBy);

			if (startRowIndex != 0 || maximumRows != int.MaxValue)
			{
				if (orderedQuery != null)
					orderedQuery = (IOrderedQueryable<T>)orderedQuery.Skip(startRowIndex).Take(maximumRows);
				else
					query = query.Skip(startRowIndex).Take(maximumRows);
			}

			return orderedQuery ?? query;
		}
		#endregion

		#region GetFirst / GetLast
		/// <summary>
		/// 모든 엔터티 중 첫번째 엔터티를 반환한다. 엔터티의 순서는 DB에 의해 결정된다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
		/// </summary>
		/// <returns>엔터티</returns>
        public virtual T GetFirst()
		{
			return GetFirst<T>(null, null);
		}

        public virtual Task<T> GetFirstAsync()
            => Task.Factory.StartNew(() => GetFirst());

		/// <summary>
		/// 조건식에 맞는 엔터티 중 첫번째 엔터티를 반환한다. 엔터티의 순서는 DB에 의해 결정된다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
		/// </summary>
		/// <param name="where">조건식</param>
		/// <returns>엔터티</returns>
        public virtual T GetFirst(Expression<Func<T, bool>> where)
		{
			return GetFirst<T>(where, null);
		}

        public virtual Task<T> GetFirstAsync(Expression<Func<T, bool>> where) 
            => Task.Factory.StartNew(() => GetFirst(where));

        /// <summary>
		/// 모든 엔터티를 정렬식에 따라 정렬했을 때 첫번째 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
		/// </summary>
		/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
		/// <param name="orderBy">정렬식</param>
		/// <returns>엔터티</returns>
        public virtual T GetFirst<U>(Expression<Func<T, U>> orderBy)
		{
			return GetFirst(null, orderBy);
		}

        public virtual Task<T> GetFirstAsync<U>(Expression<Func<T, U>> orderBy)
            => Task.Factory.StartNew(() => GetFirst(orderBy));

		/// <summary>
		/// 조건식에 맞는 엔터티를 정렬식에 따라 정렬했을 때 첫번째 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
		/// </summary>
		/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
		/// <param name="where">조건식</param>
		/// <param name="orderBy">정렬식</param>
		/// <returns>엔터티</returns>
        public virtual T GetFirst<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy)
		{
		    return GetFirstCore(where, orderBy, true);
		}

        public virtual Task<T> GetFirstAsync<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy)
		    => Task.Factory.StartNew(() => GetFirst(where, orderBy));

	    private T GetFirstCore<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending)
	    {
            using var context = ChinookContext.Create();

	        return QueryFirst(where, orderBy, ascending, context).FirstOrDefault();
	    }

        /// <summary>
        /// 모든 엔터티를 정렬식에 따라 정렬했을 때 마지막 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
        /// </summary>
        /// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
        /// <param name="orderBy">정렬식</param>
        /// <returns>엔터티</returns>
        public virtual T GetLast<U>(Expression<Func<T, U>> orderBy)
		{
			return GetLast(null, orderBy);
		}

        public virtual Task<T> GetLastAsync<U>(Expression<Func<T, U>> orderBy)
		=> Task.Factory.StartNew(() => GetLast(orderBy));

		/// <summary>
		/// 조건식에 맞는 엔터티를 정렬식에 따라 정렬했을 때 마지막 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
		/// </summary>
		/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
		/// <param name="where">조건식</param>
		/// <param name="orderBy">정렬식</param>
		/// <returns>엔터티</returns>
		[ForAsync]
        public virtual T GetLast<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy)
		{
		    return GetFirstCore(where, orderBy, false);
        }

        public virtual Task<T> GetLastAsync<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy)
		=> Task.Factory.StartNew(() => GetLast(where, orderBy));

        private static IQueryable<T> QueryFirst<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending, ChinookContext context)
		{
			var query = from x in context.Set<T>()
						select x;

			if (where != null)
				query = query.Where(where);

            // 마지막 행은 orderby가 반드시 지정되어 있어야 함. orderby를 지정하지 않으면 skip 메서드를 사용할 수 없기 때문.
            if (orderBy != null)
			    query = @ascending ? query.OrderBy(orderBy) : query.OrderByDescending(orderBy);

            return query;
		}
		#endregion

		#region SelectFirst / SelectLast
		/// <summary>
		/// 모든 엔터티 중 첫번째 엔터티를 반환한다. 엔터티의 순서는 DB에 의해 결정된다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
		/// </summary>
		/// <param name="select">선택식</param>
		/// <returns>엔터티</returns>
        public virtual R SelectFirst<R>(Expression<Func<T, R>> select)
		{
			return SelectFirst<T, R>(null, null, select);
		}

        public virtual Task<R> SelectFirstAsync<R>(Expression<Func<T, R>> select)
		=> Task.Factory.StartNew(() => SelectFirst(select));

		/// <summary>
		/// 조건식에 맞는 엔터티 중 첫번째 엔터티를 반환한다. 엔터티의 순서는 DB에 의해 결정된다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
		/// </summary>
		/// <typeparam name="R">선택 형식</typeparam>
		/// <param name="where">조건식</param>
		/// <param name="select">선택식</param>
		/// <returns>엔터티</returns>
        public virtual R SelectFirst<R>(Expression<Func<T, bool>> where, Expression<Func<T, R>> select)
		{
			return SelectFirst<T, R>(where, null, select);
		}

        public virtual Task<R> SelectFirstAsync<R>(Expression<Func<T, bool>> where, Expression<Func<T, R>> select)
		=> Task.Factory.StartNew(() => SelectFirst(where, select));

		/// <summary>
		/// 모든 엔터티를 정렬식에 따라 정렬했을 때 첫번째 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
		/// </summary>
		/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
		/// <typeparam name="R">선택 형식</typeparam>
		/// <param name="orderBy">정렬식</param>
		/// <param name="select">선택식</param>
		/// <returns>엔터티</returns>
        public virtual R SelectFirst<U, R>(Expression<Func<T, U>> orderBy, Expression<Func<T, R>> select)
		{
			return SelectFirst(null, orderBy, select);
		}

        public virtual Task<R> SelectFirstAsync<U, R>(Expression<Func<T, U>> orderBy, Expression<Func<T, R>> select)
		=> Task.Factory.StartNew(() => SelectFirst(orderBy, select));

		/// <summary>
		/// 조건식에 맞는 엔터티를 정렬식에 따라 정렬했을 때 첫번째 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
		/// </summary>
		/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
		/// <typeparam name="R">선택 형식</typeparam>
		/// <param name="where">조건식</param>
		/// <param name="orderBy">정렬식</param>
		/// <param name="select">선택식</param>
		/// <returns>엔터티</returns>
        public virtual R SelectFirst<U, R>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, Expression<Func<T, R>> select)
		{
		    return SelectFirstCore(where, orderBy, select, true);
		}

        public virtual Task<R> SelectFirstAsync<U, R>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, Expression<Func<T, R>> select)
		=> Task.Factory.StartNew(() => SelectFirst(where, orderBy, select));

        /// <summary>
        /// 조건식에 맞는 엔터티를 정렬식에 따라 정렬했을 때 첫번째 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
        /// </summary>
        /// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
        /// <typeparam name="R">선택 형식</typeparam>
        /// <param name="where">조건식</param>
        /// <param name="orderBy">정렬식</param>
        /// <param name="select">선택식</param>
        /// <param name="ascending">true이면 오름차순, false이면 내림차순</param>
        /// <returns>엔터티</returns>
        private R SelectFirstCore<U, R>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, Expression<Func<T, R>> select, bool ascending)
		{
            using var context = ChinookContext.Create();

			var query = QueryFirst(where, orderBy, ascending, context);
			return query.Select(select).FirstOrDefault();
		}

        /// <summary>
        /// 모든 엔터티를 정렬식에 따라 정렬했을 때 마지막 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
        /// </summary>
        /// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
        /// <typeparam name="R">선택 형식</typeparam>
        /// <param name="orderBy">정렬식</param>
        /// <param name="select">선택식</param>
        /// <returns>엔터티</returns>
        public virtual R SelectLast<U, R>(Expression<Func<T, U>> orderBy, Expression<Func<T, R>> select)
	    {
	        return SelectLast(null, orderBy, select);
	    }

        public virtual Task<R> SelectLastAsync<U, R>(Expression<Func<T, U>> orderBy, Expression<Func<T, R>> select)
		=> Task.Factory.StartNew(() => SelectLast(orderBy, select));

        /// <summary>
        /// 조건식에 맞는 엔터티를 정렬식에 따라 정렬했을 때 마지막 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
        /// </summary>
        /// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
        /// <typeparam name="R">선택 형식</typeparam>
        /// <param name="where">조건식</param>
        /// <param name="orderBy">정렬식</param>
        /// <param name="select">선택식</param>
        /// <returns>엔터티</returns>
        public virtual R SelectLast<U, R>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, Expression<Func<T, R>> select)
	    {
	        return SelectFirstCore(where, orderBy, select, false);
	    }

        public virtual Task<R> SelectLastAsync<U, R>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, Expression<Func<T, R>> select)
		=> Task.Factory.StartNew(() => SelectLast(where, orderBy, select));
        #endregion

		#region GetCount
		/// <summary>
		/// 모든 엔터티의 갯수를 구한다.
		/// </summary>
		/// <returns>엔터티의 갯수</returns>
        public virtual int GetCount()
		{
			return GetCount(null);
		}

        public virtual Task<int> GetCountAsync()
		=> Task.Factory.StartNew(() => GetCount());

		/// <summary>
		/// 조건식에 맞는 엔터티의 갯수를 구한다.
		/// </summary>
		/// <param name="where">조건식</param>
		/// <returns>엔터티의 갯수</returns>
        public virtual int GetCount(Expression<Func<T, bool>> where)
		{
            using var context = ChinookContext.Create();

			var query = from item in context.Set<T>()
						select item;

			if (where != null)
				query = query.Where(where);

			return query.Count();
		}

        public virtual Task<int> GetCountAsync(Expression<Func<T, bool>> where)
		=> Task.Factory.StartNew(() => GetCount(where));
		#endregion

		#region Exist
		/// <summary>
		/// 조건식에 맞는 엔터티가 존재하는지 검사한다.
		/// </summary>
		/// <param name="where">조건식</param>
		/// <returns>존재 여부</returns>
        public virtual bool Exists(Expression<Func<T, bool>> where)
		{
            using var context = ChinookContext.Create();

			var query = from item in context.Set<T>()
						select item;

			if (where != null)
				query = query.Where(where);

			return query.Any();
		}

        public virtual Task<bool> ExistsAsync(Expression<Func<T, bool>> where)
		=> Task.Factory.StartNew(() => Exists(where));
		#endregion

		#region Write log partial methods
		/// <summary>
		/// 엔티티의 로그를 기록한다.
		/// </summary>
		/// <param name="entity">엔티티</param>
		/// <param name="logType">로그 타입</param>
		partial void WriteSingleLog(T entity, LogType logType);

		/// <summary>
		/// 엔티티 컬렉션의 로그를 기록한다.
		/// </summary>
		/// <param name="entities">엔티티 컬렉션</param>
		/// <param name="logType">로그 타입</param>
		partial void WriteMultipleLog(IEnumerable<T> entities, LogType logType);
		#endregion

		#region Insert / Update / Delete
		/// <summary>
		/// 엔터티를 삽입한다.
		/// </summary>
		/// <param name="entity">삽입할 엔터티</param>
		/// <returns>삽입된 엔터티</returns>
        public virtual T Insert(T entity)
		{
            using var context = ChinookContext.Create();

			MarkToInsert(context, entity);
			context.SaveChanges();

			WriteSingleLog(entity, LogType.Insert);

			return entity;
		}

        public virtual Task<T> InsertAsync(T entity)
		=> Task.Factory.StartNew(() => Insert(entity));

		internal virtual void MarkToInsert(ChinookContext context, T entity)
		{
			context.Set<T>().Add(entity);
		}

		/// <summary>
		/// 엔터티 컬렉션을 삽입한다.
		/// </summary>
		/// <param name="entities">삽입할 엔터티가 포함된 컬렉션</param>
		/// <returns>삽입된 엔터티의 갯수</returns>
        public virtual int InsertMany(IEnumerable<T> entities)
		{
            using var context = ChinookContext.Create();

			MarkToInsertMany(context, entities);
			int count = context.SaveChanges();

			WriteMultipleLog(entities, LogType.Insert);

			return count;
		}

        public virtual Task<int> InsertManyAsync(IEnumerable<T> entities)
		=> Task.Factory.StartNew(() => InsertMany(entities));

		internal virtual void MarkToInsertMany(ChinookContext context, IEnumerable<T> entities)
		{
			foreach (var entity in entities)
				context.Set<T>().Add(entity);
		}

		/// <summary>
		/// 엔터티를 갱신한다.
		/// </summary>
		/// <param name="entity">갱신할 엔터티</param>
		/// <returns>갱신된 엔터티의 갯수</returns>
        public virtual int Update(T entity)
		{
            using var context = ChinookContext.Create();

			MarkToUpdate(context, entity);
			int count = context.SaveChanges();

			WriteSingleLog(entity, LogType.Update);

			return count;
		}

        public virtual Task<int> UpdateAsync(T entity)
		=> Task.Factory.StartNew(() => Update(entity));

		internal virtual void MarkToUpdate(ChinookContext context, T entity)
		{
			context.Entry(entity).State = EntityState.Modified;
		}

		/// <summary>
		/// 엔터티 컬렉션을 갱신한다.
		/// </summary>
		/// <param name="entities">갱신할 엔터티가 포함된 컬렉션</param>
		/// <returns>갱신된 엔터티의 갯수</returns>
        public virtual int UpdateMany(IEnumerable<T> entities)
		{
            using var context = ChinookContext.Create();

            MarkToUpdateMany(context, entities);
			int count = context.SaveChanges();

			WriteMultipleLog(entities, LogType.Update);

			return count;
		}

        public virtual Task<int> UpdateManyAsync(IEnumerable<T> entities)
		=> Task.Factory.StartNew(() => UpdateMany(entities));

		internal virtual void MarkToUpdateMany(ChinookContext context, IEnumerable<T> entities)
		{
			foreach (var entity in entities)
				context.Entry(entity).State = EntityState.Modified;
		}

		/// <summary>
		/// 엔터티를 삭제한다.
		/// </summary>
		/// <param name="entity">삭제할 엔터티</param>
		/// <returns>삭제된 엔터티의 갯수</returns>
        public virtual int Delete(T entity)
		{
            using var context = ChinookContext.Create();

            MarkToDelete(context, entity);
			int count = context.SaveChanges();

			WriteSingleLog(entity, LogType.Delete);
			
			return count;
		}

        public virtual Task<int> DeleteAsync(T entity)
		=> Task.Factory.StartNew(() => Delete(entity));

		internal virtual void MarkToDelete(ChinookContext context, T entity)
		{
			context.Entry(entity).State = EntityState.Deleted;
		}

		/// <summary>
		/// 엔터티 컬렉션을 삭제한다.
		/// </summary>
		/// <param name="entities">삭제할 엔터티 컬렉션</param>
		/// <returns>삭제된 엔터티의 갯수</returns>
        public virtual int DeleteMany(IEnumerable<T> entities)
		{
            using var context = ChinookContext.Create();
			
			MarkToDeleteMany(context, entities);
			int count = context.SaveChanges();

			WriteMultipleLog(entities, LogType.Delete);

			return count;
		}

        public virtual Task<int> DeleteManyAsync(IEnumerable<T> entities)
		=> Task.Factory.StartNew(() => DeleteMany(entities));

		internal virtual void MarkToDeleteMany(ChinookContext context, IEnumerable<T> entities)
		{
			foreach (var entity in entities)
				context.Entry(entity).State = EntityState.Deleted;
		}

		/// <summary>
		/// 조건식을 만족하는 엔터티들을 삭제한다.
		/// </summary>
		/// <param name="where">조건식</param>
		/// <returns>삭제된 엔터티의 갯수</returns>
        public virtual int DeleteAll(Expression<Func<T, bool>> where)
		{
            using var context = ChinookContext.Create();

			var query = from item in context.Set<T>()
						select item;

			if (where != null)
				query = query.Where(where);

			var entities = query.ToList();

			MarkToDeleteMany(context, entities);

			int count = context.SaveChanges();

			WriteMultipleLog(entities, LogType.Delete);

			return count;
		}

        public virtual Task<int> DeleteAllAsync(Expression<Func<T, bool>> where)
		=> Task.Factory.StartNew(() => DeleteAll(where));
		#endregion
	}
	#endregion

		#region AlbumDao
	/// <summary>
	/// Album 데이터 클래스
	/// </summary>
	public partial class AlbumDao : EntityData<Album>
	{
		internal AlbumDao() {}

		
		/// <summary>
		/// 기본키가 일치하는 엔터티를 구한다.
		/// </summary>
				/// <param name="albumId">기본키</param>
		/// <returns>기본키가 일치하는 엔터티</returns>
        public virtual Album GetByKey(int albumId)
		{
            using var context = ChinookContext.Create();

            return context.Set<Album>().FirstOrDefault(x =>  x.AlbumId == albumId);
		}

        public virtual Task<Album> GetByKeyAsync(int albumId)
			=> Task.Factory.StartNew(() => GetByKey(albumId));

		/// <summary>
		/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
		/// </summary>
				/// <param name="albumId">기본키</param>
		/// <returns>존재 여부</returns>
        public virtual bool ExistsByKey(int albumId)
		{
            using var context = ChinookContext.Create();

			return context.Set<Album>().Count(x =>  x.AlbumId == albumId) > 0;
		}

        public virtual Task<bool> ExistsByKeyAsync(int albumId)
		=> Task.Factory.StartNew(() => ExistsByKey(albumId));

		/// <summary>
		/// 기본키가 일치하는 엔터티를 삭제한다.
		/// </summary>
				/// <param name="albumId">기본키</param>
		/// <returns>삭제된 엔터티의 갯수</returns>
        public virtual int DeleteByKey(int albumId)
		{
            using var context = ChinookContext.Create();

			var query = from x in context.Set<Album>()
			where x.AlbumId == albumId
			select x;

			var entity = query.FirstOrDefault();

            if (entity == null)
                return 0;

			MarkToDelete(context, entity);

			return context.SaveChanges();
		}

        public virtual Task<int> DeleteByKeyAsync(int albumId)
		=> Task.Factory.StartNew(() => DeleteByKey(albumId));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입할 엔터티</param>
		/// <returns>삽입된 엔터티</returns>
        public virtual Album InsertIfNotExist(Album entity)
	    {
            using var context = ChinookContext.Create();

	        if (context.Set<Album>().Count(x =>  x.AlbumId == entity.AlbumId) > 0)
	            return null;

	        MarkToInsert(context, entity);
	        context.SaveChanges();

	        return entity;
	    }

        public virtual Task<Album> InsertIfNotExistAsync(Album entity)
		=> Task.Factory.StartNew(() => InsertIfNotExist(entity));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 있으면 갱신하고 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입 혹은 갱신할 엔터티</param>
		/// <returns>삽입 혹은 갱신된 엔터티</returns>
        public virtual Album InsertOrUpdate(Album entity)
	    {
            using var context = ChinookContext.Create();
            
	        if (context.Set<Album>().Count(x =>  x.AlbumId == entity.AlbumId) > 0)
	        {
	            MarkToUpdate(context, entity);
	            context.SaveChanges();

	            return entity;

            }
            else
	        {
	            MarkToInsert(context, entity);
	            context.SaveChanges();

	            return entity;

            }
	    }

        public virtual Task<Album> InsertOrUpdateAsync(Album entity)
		=> Task.Factory.StartNew(() => InsertOrUpdate(entity));
		

				/// <summary>
		/// 외래키 ArtistId 이(가) 일치하는 엔터티 컬렉션을 구한다.
		/// </summary>
		/// <param name="artistId">외래키</param>
		/// <returns>ArtistId 이(가) 일치하는 엔터티 컬렉션</returns>
        public virtual List<Album> GetByArtistId(int artistId)
		{
            using var context = ChinookContext.Create();

			return context.Set<Album>().Where(x => x.ArtistId == artistId).ToList();
		}

        public virtual Task<List<Album>> GetByArtistIdAsync(int artistId)
		=> Task.Factory.StartNew(() => GetByArtistId(artistId));
	}
	#endregion
	#region ArtistDao
	/// <summary>
	/// Artist 데이터 클래스
	/// </summary>
	public partial class ArtistDao : EntityData<Artist>
	{
		internal ArtistDao() {}

		
		/// <summary>
		/// 기본키가 일치하는 엔터티를 구한다.
		/// </summary>
				/// <param name="artistId">기본키</param>
		/// <returns>기본키가 일치하는 엔터티</returns>
        public virtual Artist GetByKey(int artistId)
		{
            using var context = ChinookContext.Create();

            return context.Set<Artist>().FirstOrDefault(x =>  x.ArtistId == artistId);
		}

        public virtual Task<Artist> GetByKeyAsync(int artistId)
			=> Task.Factory.StartNew(() => GetByKey(artistId));

		/// <summary>
		/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
		/// </summary>
				/// <param name="artistId">기본키</param>
		/// <returns>존재 여부</returns>
        public virtual bool ExistsByKey(int artistId)
		{
            using var context = ChinookContext.Create();

			return context.Set<Artist>().Count(x =>  x.ArtistId == artistId) > 0;
		}

        public virtual Task<bool> ExistsByKeyAsync(int artistId)
		=> Task.Factory.StartNew(() => ExistsByKey(artistId));

		/// <summary>
		/// 기본키가 일치하는 엔터티를 삭제한다.
		/// </summary>
				/// <param name="artistId">기본키</param>
		/// <returns>삭제된 엔터티의 갯수</returns>
        public virtual int DeleteByKey(int artistId)
		{
            using var context = ChinookContext.Create();

			var query = from x in context.Set<Artist>()
			where x.ArtistId == artistId
			select x;

			var entity = query.FirstOrDefault();

            if (entity == null)
                return 0;

			MarkToDelete(context, entity);

			return context.SaveChanges();
		}

        public virtual Task<int> DeleteByKeyAsync(int artistId)
		=> Task.Factory.StartNew(() => DeleteByKey(artistId));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입할 엔터티</param>
		/// <returns>삽입된 엔터티</returns>
        public virtual Artist InsertIfNotExist(Artist entity)
	    {
            using var context = ChinookContext.Create();

	        if (context.Set<Artist>().Count(x =>  x.ArtistId == entity.ArtistId) > 0)
	            return null;

	        MarkToInsert(context, entity);
	        context.SaveChanges();

	        return entity;
	    }

        public virtual Task<Artist> InsertIfNotExistAsync(Artist entity)
		=> Task.Factory.StartNew(() => InsertIfNotExist(entity));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 있으면 갱신하고 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입 혹은 갱신할 엔터티</param>
		/// <returns>삽입 혹은 갱신된 엔터티</returns>
        public virtual Artist InsertOrUpdate(Artist entity)
	    {
            using var context = ChinookContext.Create();
            
	        if (context.Set<Artist>().Count(x =>  x.ArtistId == entity.ArtistId) > 0)
	        {
	            MarkToUpdate(context, entity);
	            context.SaveChanges();

	            return entity;

            }
            else
	        {
	            MarkToInsert(context, entity);
	            context.SaveChanges();

	            return entity;

            }
	    }

        public virtual Task<Artist> InsertOrUpdateAsync(Artist entity)
		=> Task.Factory.StartNew(() => InsertOrUpdate(entity));
		

		
	}
	#endregion
	#region PlaylistDao
	/// <summary>
	/// Playlist 데이터 클래스
	/// </summary>
	public partial class PlaylistDao : EntityData<Playlist>
	{
		internal PlaylistDao() {}

		
		/// <summary>
		/// 기본키가 일치하는 엔터티를 구한다.
		/// </summary>
				/// <param name="playlistId">기본키</param>
		/// <returns>기본키가 일치하는 엔터티</returns>
        public virtual Playlist GetByKey(int playlistId)
		{
            using var context = ChinookContext.Create();

            return context.Set<Playlist>().FirstOrDefault(x =>  x.PlaylistId == playlistId);
		}

        public virtual Task<Playlist> GetByKeyAsync(int playlistId)
			=> Task.Factory.StartNew(() => GetByKey(playlistId));

		/// <summary>
		/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
		/// </summary>
				/// <param name="playlistId">기본키</param>
		/// <returns>존재 여부</returns>
        public virtual bool ExistsByKey(int playlistId)
		{
            using var context = ChinookContext.Create();

			return context.Set<Playlist>().Count(x =>  x.PlaylistId == playlistId) > 0;
		}

        public virtual Task<bool> ExistsByKeyAsync(int playlistId)
		=> Task.Factory.StartNew(() => ExistsByKey(playlistId));

		/// <summary>
		/// 기본키가 일치하는 엔터티를 삭제한다.
		/// </summary>
				/// <param name="playlistId">기본키</param>
		/// <returns>삭제된 엔터티의 갯수</returns>
        public virtual int DeleteByKey(int playlistId)
		{
            using var context = ChinookContext.Create();

			var query = from x in context.Set<Playlist>()
			where x.PlaylistId == playlistId
			select x;

			var entity = query.FirstOrDefault();

            if (entity == null)
                return 0;

			MarkToDelete(context, entity);

			return context.SaveChanges();
		}

        public virtual Task<int> DeleteByKeyAsync(int playlistId)
		=> Task.Factory.StartNew(() => DeleteByKey(playlistId));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입할 엔터티</param>
		/// <returns>삽입된 엔터티</returns>
        public virtual Playlist InsertIfNotExist(Playlist entity)
	    {
            using var context = ChinookContext.Create();

	        if (context.Set<Playlist>().Count(x =>  x.PlaylistId == entity.PlaylistId) > 0)
	            return null;

	        MarkToInsert(context, entity);
	        context.SaveChanges();

	        return entity;
	    }

        public virtual Task<Playlist> InsertIfNotExistAsync(Playlist entity)
		=> Task.Factory.StartNew(() => InsertIfNotExist(entity));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 있으면 갱신하고 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입 혹은 갱신할 엔터티</param>
		/// <returns>삽입 혹은 갱신된 엔터티</returns>
        public virtual Playlist InsertOrUpdate(Playlist entity)
	    {
            using var context = ChinookContext.Create();
            
	        if (context.Set<Playlist>().Count(x =>  x.PlaylistId == entity.PlaylistId) > 0)
	        {
	            MarkToUpdate(context, entity);
	            context.SaveChanges();

	            return entity;

            }
            else
	        {
	            MarkToInsert(context, entity);
	            context.SaveChanges();

	            return entity;

            }
	    }

        public virtual Task<Playlist> InsertOrUpdateAsync(Playlist entity)
		=> Task.Factory.StartNew(() => InsertOrUpdate(entity));
		

		
	}
	#endregion
	#region PlaylistTrackDao
	/// <summary>
	/// PlaylistTrack 데이터 클래스
	/// </summary>
	public partial class PlaylistTrackDao : EntityData<PlaylistTrack>
	{
		internal PlaylistTrackDao() {}

		
		/// <summary>
		/// 기본키가 일치하는 엔터티를 구한다.
		/// </summary>
				/// <param name="playlistId">기본키</param>		/// <param name="trackId">기본키</param>
		/// <returns>기본키가 일치하는 엔터티</returns>
        public virtual PlaylistTrack GetByKey(int playlistId, int trackId)
		{
            using var context = ChinookContext.Create();

            return context.Set<PlaylistTrack>().FirstOrDefault(x =>  x.PlaylistId == playlistId &&  x.TrackId == trackId);
		}

        public virtual Task<PlaylistTrack> GetByKeyAsync(int playlistId, int trackId)
			=> Task.Factory.StartNew(() => GetByKey(playlistId, trackId));

		/// <summary>
		/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
		/// </summary>
				/// <param name="playlistId">기본키</param>		/// <param name="trackId">기본키</param>
		/// <returns>존재 여부</returns>
        public virtual bool ExistsByKey(int playlistId, int trackId)
		{
            using var context = ChinookContext.Create();

			return context.Set<PlaylistTrack>().Count(x =>  x.PlaylistId == playlistId &&  x.TrackId == trackId) > 0;
		}

        public virtual Task<bool> ExistsByKeyAsync(int playlistId, int trackId)
		=> Task.Factory.StartNew(() => ExistsByKey(playlistId, trackId));

		/// <summary>
		/// 기본키가 일치하는 엔터티를 삭제한다.
		/// </summary>
				/// <param name="playlistId">기본키</param>		/// <param name="trackId">기본키</param>
		/// <returns>삭제된 엔터티의 갯수</returns>
        public virtual int DeleteByKey(int playlistId, int trackId)
		{
            using var context = ChinookContext.Create();

			var query = from x in context.Set<PlaylistTrack>()
			where x.PlaylistId == playlistId && x.TrackId == trackId
			select x;

			var entity = query.FirstOrDefault();

            if (entity == null)
                return 0;

			MarkToDelete(context, entity);

			return context.SaveChanges();
		}

        public virtual Task<int> DeleteByKeyAsync(int playlistId, int trackId)
		=> Task.Factory.StartNew(() => DeleteByKey(playlistId, trackId));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입할 엔터티</param>
		/// <returns>삽입된 엔터티</returns>
        public virtual PlaylistTrack InsertIfNotExist(PlaylistTrack entity)
	    {
            using var context = ChinookContext.Create();

	        if (context.Set<PlaylistTrack>().Count(x =>  x.PlaylistId == entity.PlaylistId &&  x.TrackId == entity.TrackId) > 0)
	            return null;

	        MarkToInsert(context, entity);
	        context.SaveChanges();

	        return entity;
	    }

        public virtual Task<PlaylistTrack> InsertIfNotExistAsync(PlaylistTrack entity)
		=> Task.Factory.StartNew(() => InsertIfNotExist(entity));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 있으면 갱신하고 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입 혹은 갱신할 엔터티</param>
		/// <returns>삽입 혹은 갱신된 엔터티</returns>
        public virtual PlaylistTrack InsertOrUpdate(PlaylistTrack entity)
	    {
            using var context = ChinookContext.Create();
            
	        if (context.Set<PlaylistTrack>().Count(x =>  x.PlaylistId == entity.PlaylistId &&  x.TrackId == entity.TrackId) > 0)
	        {
	            MarkToUpdate(context, entity);
	            context.SaveChanges();

	            return entity;

            }
            else
	        {
	            MarkToInsert(context, entity);
	            context.SaveChanges();

	            return entity;

            }
	    }

        public virtual Task<PlaylistTrack> InsertOrUpdateAsync(PlaylistTrack entity)
		=> Task.Factory.StartNew(() => InsertOrUpdate(entity));
		

				/// <summary>
		/// 외래키 PlaylistId 이(가) 일치하는 엔터티 컬렉션을 구한다.
		/// </summary>
		/// <param name="playlistId">외래키</param>
		/// <returns>PlaylistId 이(가) 일치하는 엔터티 컬렉션</returns>
        public virtual List<PlaylistTrack> GetByPlaylistId(int playlistId)
		{
            using var context = ChinookContext.Create();

			return context.Set<PlaylistTrack>().Where(x => x.PlaylistId == playlistId).ToList();
		}

        public virtual Task<List<PlaylistTrack>> GetByPlaylistIdAsync(int playlistId)
		=> Task.Factory.StartNew(() => GetByPlaylistId(playlistId));
		/// <summary>
		/// 외래키 TrackId 이(가) 일치하는 엔터티 컬렉션을 구한다.
		/// </summary>
		/// <param name="trackId">외래키</param>
		/// <returns>TrackId 이(가) 일치하는 엔터티 컬렉션</returns>
        public virtual List<PlaylistTrack> GetByTrackId(int trackId)
		{
            using var context = ChinookContext.Create();

			return context.Set<PlaylistTrack>().Where(x => x.TrackId == trackId).ToList();
		}

        public virtual Task<List<PlaylistTrack>> GetByTrackIdAsync(int trackId)
		=> Task.Factory.StartNew(() => GetByTrackId(trackId));
	}
	#endregion
	#region TrackDao
	/// <summary>
	/// Track 데이터 클래스
	/// </summary>
	public partial class TrackDao : EntityData<Track>
	{
		internal TrackDao() {}

		
		/// <summary>
		/// 기본키가 일치하는 엔터티를 구한다.
		/// </summary>
				/// <param name="trackId">기본키</param>
		/// <returns>기본키가 일치하는 엔터티</returns>
        public virtual Track GetByKey(int trackId)
		{
            using var context = ChinookContext.Create();

            return context.Set<Track>().FirstOrDefault(x =>  x.TrackId == trackId);
		}

        public virtual Task<Track> GetByKeyAsync(int trackId)
			=> Task.Factory.StartNew(() => GetByKey(trackId));

		/// <summary>
		/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
		/// </summary>
				/// <param name="trackId">기본키</param>
		/// <returns>존재 여부</returns>
        public virtual bool ExistsByKey(int trackId)
		{
            using var context = ChinookContext.Create();

			return context.Set<Track>().Count(x =>  x.TrackId == trackId) > 0;
		}

        public virtual Task<bool> ExistsByKeyAsync(int trackId)
		=> Task.Factory.StartNew(() => ExistsByKey(trackId));

		/// <summary>
		/// 기본키가 일치하는 엔터티를 삭제한다.
		/// </summary>
				/// <param name="trackId">기본키</param>
		/// <returns>삭제된 엔터티의 갯수</returns>
        public virtual int DeleteByKey(int trackId)
		{
            using var context = ChinookContext.Create();

			var query = from x in context.Set<Track>()
			where x.TrackId == trackId
			select x;

			var entity = query.FirstOrDefault();

            if (entity == null)
                return 0;

			MarkToDelete(context, entity);

			return context.SaveChanges();
		}

        public virtual Task<int> DeleteByKeyAsync(int trackId)
		=> Task.Factory.StartNew(() => DeleteByKey(trackId));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입할 엔터티</param>
		/// <returns>삽입된 엔터티</returns>
        public virtual Track InsertIfNotExist(Track entity)
	    {
            using var context = ChinookContext.Create();

	        if (context.Set<Track>().Count(x =>  x.TrackId == entity.TrackId) > 0)
	            return null;

	        MarkToInsert(context, entity);
	        context.SaveChanges();

	        return entity;
	    }

        public virtual Task<Track> InsertIfNotExistAsync(Track entity)
		=> Task.Factory.StartNew(() => InsertIfNotExist(entity));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 있으면 갱신하고 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입 혹은 갱신할 엔터티</param>
		/// <returns>삽입 혹은 갱신된 엔터티</returns>
        public virtual Track InsertOrUpdate(Track entity)
	    {
            using var context = ChinookContext.Create();
            
	        if (context.Set<Track>().Count(x =>  x.TrackId == entity.TrackId) > 0)
	        {
	            MarkToUpdate(context, entity);
	            context.SaveChanges();

	            return entity;

            }
            else
	        {
	            MarkToInsert(context, entity);
	            context.SaveChanges();

	            return entity;

            }
	    }

        public virtual Task<Track> InsertOrUpdateAsync(Track entity)
		=> Task.Factory.StartNew(() => InsertOrUpdate(entity));
		

				/// <summary>
		/// 외래키 AlbumId 이(가) 일치하는 엔터티 컬렉션을 구한다.
		/// </summary>
		/// <param name="albumId">외래키</param>
		/// <returns>AlbumId 이(가) 일치하는 엔터티 컬렉션</returns>
        public virtual List<Track> GetByAlbumId(int? albumId)
		{
            using var context = ChinookContext.Create();

			return context.Set<Track>().Where(x => x.AlbumId == albumId).ToList();
		}

        public virtual Task<List<Track>> GetByAlbumIdAsync(int? albumId)
		=> Task.Factory.StartNew(() => GetByAlbumId(albumId));
	}
	#endregion
	#endregion

	#region Types
	/// <summary>
	/// 엔티티를 추가/수정/삭제 할 때 기록하는 로그의 종류
	/// </summary>
	internal enum LogType
	{
		/// <summary>
		/// 엔티티 삽입
		/// </summary>
		Insert,

		/// <summary>
		/// 엔티티 컬렉션 삽입
		/// </summary>
		InsertMany,

		/// <summary>
		/// 엔티티 갱신
		/// </summary>
		Update,

		/// <summary>
		/// 엔티티 컬렉션 갱신
		/// </summary>
		UpdateMany,

		/// <summary>
		/// 엔티티 삭제
		/// </summary>
		Delete,

		/// <summary>
		/// 엔티티 컬렉션 삭제
		/// </summary>
		DeleteMany
	}

	/// <summary>
	/// 데이터 액세스 레이어 클래스임을 지시
	/// </summary>
	[AttributeUsage(AttributeTargets.Class)]
	public class DataAttribute : Attribute
	{
	}

	/// <summary>
	/// 서버 캐시를 사용하도록 지시
	/// </summary>
	[AttributeUsage(AttributeTargets.Class)]
	public class ForCacheAttribute : Attribute
	{
	}

	/// <summary>
	/// 서비스 메서드를 만들 것을 지시
	/// </summary>
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method)]
	public class ForServiceAttribute : Attribute
	{
	}

	/// <summary>
	/// 비동기 호출 코드를 생성할 것을 지시
	/// </summary>
	[AttributeUsage(AttributeTargets.Method, Inherited = false)]
	public class ForAsyncAttribute : Attribute
	{
	}

	/// <summary>
	/// 비지니스 코드를 생성하지 말것을 지시
	/// </summary>
	[AttributeUsage(AttributeTargets.Method)]
	public class ForCustomBizAttribute : Attribute
	{
	}

	/// <summary>
	/// 외래키를 조건으로 하는 Get 메서드 임을 지시
	/// </summary>
	[AttributeUsage(AttributeTargets.Method)]
	public class ByFKAttribute : Attribute
	{
	}

	/// <summary>
	/// 인증이 필요하지 않은 메서드임을 표현
	/// </summary>
	[AttributeUsage(AttributeTargets.Method)]
	public class NoAuthorizationAttribute : Attribute
	{
	}
	#endregion

	#region DaoBase
	/// <summary>
	/// Dao의 부모. Dao를 확장하는 용도로 사용한다.
	/// </summary>
	public partial class DaoBase
	{
	}
	#endregion

	#region Dao
	/// <summary>
	/// 각 엔터티 데이터 객체의 모음
	/// </summary>
	public partial class Dao : DaoBase
	{
		static Dao()
		{
						Album = new AlbumDao();
			Artist = new ArtistDao();
			Playlist = new PlaylistDao();
			PlaylistTrack = new PlaylistTrackDao();
			Track = new TrackDao();
		}

		#region Data objects
				public static AlbumDao Album { get; }
		public static ArtistDao Artist { get; }
		public static PlaylistDao Playlist { get; }
		public static PlaylistTrackDao PlaylistTrack { get; }
		public static TrackDao Track { get; }
		#endregion
		}
	#endregion

	#region ChinookContextLoggerFactory
    /// <summary>
    /// 간단하게 사용할 수 있는 엔터티 프레임워크 코어용 로거 팩토리. Console과 Debug의 출력창 혹은 파일에 저장 할 수 있음
    /// </summary>
    internal class ChinookContextLoggerFactory : LoggerFactory
    {
        #region singleton
        private static ChinookContextLoggerFactory _instance;

        public static ChinookContextLoggerFactory GetInstance(LoggerType loggerType = LoggerType.Console)
        {
            if (_instance == null)
            {
                _loggerType = loggerType;

                _instance = new ChinookContextLoggerFactory(
                                new List<ILoggerProvider>{new LogProvider()}
                );
            }

            return _instance;
        }

        private ChinookContextLoggerFactory(List<ILoggerProvider> providers) : base(providers)
        {
        }

        private static LoggerType _loggerType;

        #endregion

        internal class LogProvider : ILoggerProvider
        {
            public void Dispose()
            {
            }

            public ILogger CreateLogger(string categoryName)
            {
                return new Logger(categoryName, _loggerType);
            }
        }

        internal class Logger : ILogger
        {
            private readonly IWriter _writer;

            private readonly string _categoryName;

            public Logger(string categoryName, LoggerType loggerType)
            {
                _categoryName = categoryName;

                _writer = loggerType switch
                {
                    LoggerType.Console => new ConsoleWriter(),
                    LoggerType.Debug => new DebugWriter(),
                    LoggerType.File => new FileWriter(),
                    _ => throw new NotImplementedException("Logger.Logger")
                };
            }

            private static int _no = 1;

            public void Log<TState>(LogLevel logLevel, EventId eventId, TState state, Exception exception, Func<TState, Exception, string> formatter)
            {
                if (_writer == null)
                    return;

                _writer.WriteLine($"[{_no++:N0}] at {DateTime.Now.ToString()}");
                _writer.WriteLine(formatter(state, exception));
                _writer.WriteLine("-------------------------");
                _writer.Save();
            }

            public bool IsEnabled(LogLevel logLevel)
            {
                return logLevel == LogLevel.Information &&
                       _categoryName == DbLoggerCategory.Database.Command.Name;
            }

            public IDisposable BeginScope<TState>(TState state)
            {
                return null;
            }
        }

        public interface IWriter
        {
            void WriteLine(string format, params object[] args);
            void Save();
        }

        internal abstract class UnsavableWriter : IWriter
        {
            public abstract void WriteLine(string format, params object[] args);

            public void Save()
            {
            }
        }

        internal class ConsoleWriter : UnsavableWriter
        {
            public override void WriteLine(string format, params object[] args)
            {
                Console.WriteLine(format, args);
            }
        }

        internal class DebugWriter : UnsavableWriter
        {
            public override void WriteLine(string format, params object[] args)
            {
                Debug.WriteLine(format, args);
            }
        }

        internal class FileWriter : IWriter
        {
            private readonly string _logFilePath;

            public FileWriter(string logFilePath = "ChinookContextContextLoggerFactory.log")
            {
                _logFilePath = logFilePath;
            }

            private readonly StringBuilder _builder = new StringBuilder();

            public void WriteLine(string format, params object[] args)
            {
                _builder.AppendFormat(format, args);
                _builder.AppendLine();
            }

            public void Save()
            {
                File.WriteAllText(_logFilePath, _builder.ToString());
            }
        }
    }

    internal enum LoggerType
    {
        /// <summary>
        /// 콘솔에 출력
        /// </summary>
        Console,
        /// <summary>
        /// 디버거 창에 출력
        /// </summary>
        Debug,
        /// <summary>
        /// 파일에 출력
        /// </summary>
        File
    }
	#endregion
}
