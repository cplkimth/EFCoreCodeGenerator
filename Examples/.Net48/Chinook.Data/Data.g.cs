
/*
This file has been generated by Midnight Peach on 2023-01-08 오전 3:46:48.
You may not need to modify this file.
*/

#region using
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Data.Entity;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
#endregion

namespace Chinook.Data
{
	#region Entities

    #region IEntity
    public partial interface IEntity
    {
    }
    #endregion

	#region Untyped Entity
	/// <summary>
	///   모든 엔터티 클래스의 부모 클래스
	/// </summary>
	public abstract partial class UntypedEntity : IEntity
	{
		/// <summary>
		///   부가정보를 저장하기 위한 object 객체
		/// </summary>
		[NotMapped]
		public object EntityTag { get; set; }

		/// <summary>
		///   모든 속성의 값을 초기화한다.string형 속성은 string.Empty 값으로 채우고, DateTime형 속성은 DateTime.Today 값으로 채운다.
		/// </summary>
		/// <returns> 생성된 엔터티 </returns>
		public void Clear()
		{
			Clear(string.Empty, DateTime.Today);
		}

		/// <summary>
		///   모든 속성의 값을 초기화한다. string형 속성은 string.Empty 값으로 채우고, DateTime형 속성은 기본 DateTime 값으로 채운다.
		/// </summary>
		/// <param name="defaultDateTime"> 기본 DateTime 값 </param>
		/// <returns> 생성된 엔터티 </returns>
		public void Clear(DateTime defaultDateTime)
		{
			Clear(string.Empty, defaultDateTime);
		}

		/// <summary>
		///   모든 속성의 값을 초기화한다. string형 속성은 기본 string 값으로 채우고, DateTime형 속성은 기본 DateTime 값으로 채운다.
		/// </summary>
		/// <param name="defaultString"> 기본 string 값 </param>
		/// <param name="defaultDateTime"> 기본 DateTime 값 </param>
		/// <returns> 생성된 엔터티 </returns>
		public void Clear(string defaultString, DateTime defaultDateTime)
		{
			Type type = GetType();
			PropertyInfo[] propertyInfoArray = type.GetProperties(BindingFlags.Instance | BindingFlags.Public);

			foreach (PropertyInfo propertyInfo in propertyInfoArray)
			{
				if (propertyInfo.CanWrite == false)
					continue;

				if (propertyInfo.PropertyType == typeof (string))
					propertyInfo.SetValue(this, defaultString, null);

				else if (propertyInfo.PropertyType == typeof (DateTime))
					propertyInfo.SetValue(this, defaultDateTime, null);
			}
		}

		/// <summary>
		///   기본키 값들을 구분자(":")로 연결하여 반환한다.
		/// </summary>
		/// <returns> </returns>
		public abstract string PrimaryKeyValues {get;}

		/// <summary>
		/// 엔터티를 대표하는 문자열을 구한다.
		/// </summary>
		public abstract string EntityText { get; }

		/// <summary>
		///   엔터티의 이름을 구한다.
		/// </summary>
		public abstract string GetEntityTypeName();

		partial void IsLogWritable(ref bool? logWritable);

		public virtual bool LogWritable
		{
			get
			{
			bool? logWritable = null;
			IsLogWritable(ref logWritable);

			if (logWritable.HasValue)
				return logWritable.Value;

			return false;
			}
		}

		/// <summary>
		///   EntityLog에 찍힐 문자열을 구한다. Code로 끝나는 코드 프로퍼티의 경우 대응하는 문자열 프로퍼티의 값도 추가한다.
		///   주의) EntityLog 테이블의 설계 상 최대 2000자 까지만 저장할 수 있음.
		/// </summary>
		/// <returns> </returns>
		public virtual string ToEntityLog()
		{
			const int MaxLength = 2000; // 최대 2000자 까지만 저장.

			Type type = GetType();

			var propertyInfoes = type.GetProperties();

			StringBuilder builder = new StringBuilder(ToString());

			builder.AppendLine();
			foreach (var propertyInfo in propertyInfoes)
			{
				if (propertyInfo.PropertyType != typeof (int))
					continue;

				if (propertyInfo.Name.EndsWith("Code") == false)
					continue;

				string textPropertyName = propertyInfo.Name.Substring(0, propertyInfo.Name.Length - 4) + "Text";
				string textValue = GetTextFromCodeProperty(this, type, textPropertyName);

				if (textValue != null)
					builder.AppendFormat("[{0}] {1}{2}", textPropertyName, textValue, Environment.NewLine);
			}

			if (builder.Length > MaxLength)
				return builder.ToString(0, MaxLength);
			else
				return builder.ToString();
		}

		private static string GetTextFromCodeProperty(object entity, Type objectType, string textPropertyName)
		{
			var propertyInfo = objectType.GetProperty(textPropertyName);
			object propertyValue = propertyInfo.GetValue(entity, null);

			if (propertyValue is string value)
				return value;
			else
				return null;
		}
	}
	#endregion

	#region Entity<T>
	/// <summary>
	/// 모든 엔터티 클래스의 형이 지정된 부모 클래스
	/// </summary>
	/// <typeparam name="T">엔터티 클래스의 형식</typeparam>
	public abstract partial class Entity<T> : UntypedEntity, IEditableObject where T : class, new()
	{
		/// <summary>
		/// 객체를 복사한다.
		/// </summary>
		/// <returns></returns>
		public abstract T Clone();

		#region Implementation of IEditableObject

		protected T _clone = null;

		/// <summary>
		/// IEditableObject.BeginEdit 구현
		/// </summary>
		public void BeginEdit()
		{
			if (_clone == null)
				_clone = Clone();
		}

		/// <summary>
		/// IEditableObject.EndEdit 구현
		/// </summary>
		public void EndEdit()
		{
			_clone = null;
		}

		public abstract void CancelEdit();

		#endregion

	    /// <summary>
	    /// 객체에 감사정보를 기입한다. 보통 ModifiedAt, ModifiedBy 등의 속성을 기록함.
	    /// </summary>
        public partial void WriteAuditInfo();
	}

	#endregion

		#region Album
    /// <summary>
	/// Album 엔터티
	/// </summary>
    public partial class Album : Entity<Album>, IEntity
	{
		public const string EntityTypeName = "Album";

		public static void Copy(Album source, Album target)
		{
						target.AlbumId = source.AlbumId;		
			target.Title = source.Title;		
			target.ArtistId = source.ArtistId;
		}

		/// <summary>
		/// Album 객체를 복사한다.
		/// </summary>
		/// <returns></returns>
		public override Album Clone()
		{
			var clone = new Album();

			Copy(this, clone);

			return clone;
		}

		partial void GetEntityTextCore(ref string value);

		/// <summary>
		/// Album 객체를 대표하는 이름을 구한다.
		/// </summary>
		/// <returns></returns>
		public override string EntityText
		{
			get 
			{ 
				string value = null;
				GetEntityTextCore(ref value);

				if (value != null)
					return value;

				return PrimaryKeyValues; 
			}
		}

		partial void ToStringCore(ref string value);

		public override string ToString()
		{
			string value = null;
			ToStringCore(ref value);

			if (value != null)
				return value;

			return "[AlbumId]" + AlbumId + ", " + "[Title]" + Title + ", " + "[ArtistId]" + ArtistId;
		}

		/// <summary>
		/// IEditableObject.CancelEdit 구현
		/// </summary>
		public override void CancelEdit()
		{
			if (_clone != null)
				Copy(_clone, this);
		}

		public override string PrimaryKeyValues
		{
			get { return string.Join(":", AlbumId); }
		}

		public override string GetEntityTypeName()
		{
			return EntityTypeName;
		}
	}

	/// <summary>
	/// Album 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
	/// </summary>
	public enum AlbumColumn
	{
				AlbumId,
		Title,
		ArtistId
	}

	
	/// <summary>
	/// Album 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer<Album> 구현)
	/// </summary>
	public class AlbumEqualityComparer : IEqualityComparer<Album>
	{
		public bool Equals(Album x, Album y)
		{
			return x.AlbumId == y.AlbumId;
		}

		public int GetHashCode(Album obj)
		{
			return obj.AlbumId.GetHashCode();
		}
	}
	
	#endregion
	#region Artist
    /// <summary>
	/// Artist 엔터티
	/// </summary>
    public partial class Artist : Entity<Artist>, IEntity
	{
		public const string EntityTypeName = "Artist";

		public static void Copy(Artist source, Artist target)
		{
						target.ArtistId = source.ArtistId;		
			target.Name = source.Name;		
			target.CompanyId = source.CompanyId;
		}

		/// <summary>
		/// Artist 객체를 복사한다.
		/// </summary>
		/// <returns></returns>
		public override Artist Clone()
		{
			var clone = new Artist();

			Copy(this, clone);

			return clone;
		}

		partial void GetEntityTextCore(ref string value);

		/// <summary>
		/// Artist 객체를 대표하는 이름을 구한다.
		/// </summary>
		/// <returns></returns>
		public override string EntityText
		{
			get 
			{ 
				string value = null;
				GetEntityTextCore(ref value);

				if (value != null)
					return value;

				return PrimaryKeyValues; 
			}
		}

		partial void ToStringCore(ref string value);

		public override string ToString()
		{
			string value = null;
			ToStringCore(ref value);

			if (value != null)
				return value;

			return "[ArtistId]" + ArtistId + ", " + "[Name]" + Name + ", " + "[CompanyId]" + CompanyId;
		}

		/// <summary>
		/// IEditableObject.CancelEdit 구현
		/// </summary>
		public override void CancelEdit()
		{
			if (_clone != null)
				Copy(_clone, this);
		}

		public override string PrimaryKeyValues
		{
			get { return string.Join(":", ArtistId); }
		}

		public override string GetEntityTypeName()
		{
			return EntityTypeName;
		}
	}

	/// <summary>
	/// Artist 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
	/// </summary>
	public enum ArtistColumn
	{
				ArtistId,
		Name,
		CompanyId
	}

	
	/// <summary>
	/// Artist 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer<Artist> 구현)
	/// </summary>
	public class ArtistEqualityComparer : IEqualityComparer<Artist>
	{
		public bool Equals(Artist x, Artist y)
		{
			return x.ArtistId == y.ArtistId;
		}

		public int GetHashCode(Artist obj)
		{
			return obj.ArtistId.GetHashCode();
		}
	}
	
	#endregion
	#region Company
    /// <summary>
	/// Company 엔터티
	/// </summary>
    public partial class Company : Entity<Company>, IEntity
	{
		public const string EntityTypeName = "Company";

		public static void Copy(Company source, Company target)
		{
						target.CompanyId = source.CompanyId;		
			target.Name = source.Name;
		}

		/// <summary>
		/// Company 객체를 복사한다.
		/// </summary>
		/// <returns></returns>
		public override Company Clone()
		{
			var clone = new Company();

			Copy(this, clone);

			return clone;
		}

		partial void GetEntityTextCore(ref string value);

		/// <summary>
		/// Company 객체를 대표하는 이름을 구한다.
		/// </summary>
		/// <returns></returns>
		public override string EntityText
		{
			get 
			{ 
				string value = null;
				GetEntityTextCore(ref value);

				if (value != null)
					return value;

				return PrimaryKeyValues; 
			}
		}

		partial void ToStringCore(ref string value);

		public override string ToString()
		{
			string value = null;
			ToStringCore(ref value);

			if (value != null)
				return value;

			return "[CompanyId]" + CompanyId + ", " + "[Name]" + Name;
		}

		/// <summary>
		/// IEditableObject.CancelEdit 구현
		/// </summary>
		public override void CancelEdit()
		{
			if (_clone != null)
				Copy(_clone, this);
		}

		public override string PrimaryKeyValues
		{
			get { return string.Join(":", CompanyId); }
		}

		public override string GetEntityTypeName()
		{
			return EntityTypeName;
		}
	}

	/// <summary>
	/// Company 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
	/// </summary>
	public enum CompanyColumn
	{
				CompanyId,
		Name
	}

	
	/// <summary>
	/// Company 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer<Company> 구현)
	/// </summary>
	public class CompanyEqualityComparer : IEqualityComparer<Company>
	{
		public bool Equals(Company x, Company y)
		{
			return x.CompanyId == y.CompanyId;
		}

		public int GetHashCode(Company obj)
		{
			return obj.CompanyId.GetHashCode();
		}
	}
	
	#endregion
	#region Playlist
    /// <summary>
	/// Playlist 엔터티
	/// </summary>
    public partial class Playlist : Entity<Playlist>, IEntity
	{
		public const string EntityTypeName = "Playlist";

		public static void Copy(Playlist source, Playlist target)
		{
						target.PlaylistId = source.PlaylistId;		
			target.Name = source.Name;
		}

		/// <summary>
		/// Playlist 객체를 복사한다.
		/// </summary>
		/// <returns></returns>
		public override Playlist Clone()
		{
			var clone = new Playlist();

			Copy(this, clone);

			return clone;
		}

		partial void GetEntityTextCore(ref string value);

		/// <summary>
		/// Playlist 객체를 대표하는 이름을 구한다.
		/// </summary>
		/// <returns></returns>
		public override string EntityText
		{
			get 
			{ 
				string value = null;
				GetEntityTextCore(ref value);

				if (value != null)
					return value;

				return PrimaryKeyValues; 
			}
		}

		partial void ToStringCore(ref string value);

		public override string ToString()
		{
			string value = null;
			ToStringCore(ref value);

			if (value != null)
				return value;

			return "[PlaylistId]" + PlaylistId + ", " + "[Name]" + Name;
		}

		/// <summary>
		/// IEditableObject.CancelEdit 구현
		/// </summary>
		public override void CancelEdit()
		{
			if (_clone != null)
				Copy(_clone, this);
		}

		public override string PrimaryKeyValues
		{
			get { return string.Join(":", PlaylistId); }
		}

		public override string GetEntityTypeName()
		{
			return EntityTypeName;
		}
	}

	/// <summary>
	/// Playlist 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
	/// </summary>
	public enum PlaylistColumn
	{
				PlaylistId,
		Name
	}

	
	/// <summary>
	/// Playlist 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer<Playlist> 구현)
	/// </summary>
	public class PlaylistEqualityComparer : IEqualityComparer<Playlist>
	{
		public bool Equals(Playlist x, Playlist y)
		{
			return x.PlaylistId == y.PlaylistId;
		}

		public int GetHashCode(Playlist obj)
		{
			return obj.PlaylistId.GetHashCode();
		}
	}
	
	#endregion
	#region PlaylistTrack
    /// <summary>
	/// PlaylistTrack 엔터티
	/// </summary>
    public partial class PlaylistTrack : Entity<PlaylistTrack>, IEntity
	{
		public const string EntityTypeName = "PlaylistTrack";

		public static void Copy(PlaylistTrack source, PlaylistTrack target)
		{
						target.PlaylistId = source.PlaylistId;		
			target.TrackId = source.TrackId;		
			target.Dummy = source.Dummy;
		}

		/// <summary>
		/// PlaylistTrack 객체를 복사한다.
		/// </summary>
		/// <returns></returns>
		public override PlaylistTrack Clone()
		{
			var clone = new PlaylistTrack();

			Copy(this, clone);

			return clone;
		}

		partial void GetEntityTextCore(ref string value);

		/// <summary>
		/// PlaylistTrack 객체를 대표하는 이름을 구한다.
		/// </summary>
		/// <returns></returns>
		public override string EntityText
		{
			get 
			{ 
				string value = null;
				GetEntityTextCore(ref value);

				if (value != null)
					return value;

				return PrimaryKeyValues; 
			}
		}

		partial void ToStringCore(ref string value);

		public override string ToString()
		{
			string value = null;
			ToStringCore(ref value);

			if (value != null)
				return value;

			return "[PlaylistId]" + PlaylistId + ", " + "[TrackId]" + TrackId + ", " + "[Dummy]" + Dummy;
		}

		/// <summary>
		/// IEditableObject.CancelEdit 구현
		/// </summary>
		public override void CancelEdit()
		{
			if (_clone != null)
				Copy(_clone, this);
		}

		public override string PrimaryKeyValues
		{
			get { return string.Join(":", PlaylistId, TrackId); }
		}

		public override string GetEntityTypeName()
		{
			return EntityTypeName;
		}
	}

	/// <summary>
	/// PlaylistTrack 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
	/// </summary>
	public enum PlaylistTrackColumn
	{
				PlaylistId,
		TrackId,
		Dummy
	}

	
	/// <summary>
	/// PlaylistTrack 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer<PlaylistTrack> 구현)
	/// </summary>
	public class PlaylistTrackEqualityComparer : IEqualityComparer<PlaylistTrack>
	{
		public bool Equals(PlaylistTrack x, PlaylistTrack y)
		{
			return x.PlaylistId == y.PlaylistId && x.TrackId == y.TrackId;
		}

		public int GetHashCode(PlaylistTrack obj)
		{
			return obj.PlaylistId.GetHashCode() ^ obj.TrackId.GetHashCode();
		}
	}
	
	#endregion
	#region PlaylistTrackHistory
    /// <summary>
	/// PlaylistTrackHistory 엔터티
	/// </summary>
    public partial class PlaylistTrackHistory : Entity<PlaylistTrackHistory>, IEntity
	{
		public const string EntityTypeName = "PlaylistTrackHistory";

		public static void Copy(PlaylistTrackHistory source, PlaylistTrackHistory target)
		{
						target.PlaylistId = source.PlaylistId;		
			target.TrackId = source.TrackId;		
			target.WrittenAt = source.WrittenAt;
		}

		/// <summary>
		/// PlaylistTrackHistory 객체를 복사한다.
		/// </summary>
		/// <returns></returns>
		public override PlaylistTrackHistory Clone()
		{
			var clone = new PlaylistTrackHistory();

			Copy(this, clone);

			return clone;
		}

		partial void GetEntityTextCore(ref string value);

		/// <summary>
		/// PlaylistTrackHistory 객체를 대표하는 이름을 구한다.
		/// </summary>
		/// <returns></returns>
		public override string EntityText
		{
			get 
			{ 
				string value = null;
				GetEntityTextCore(ref value);

				if (value != null)
					return value;

				return PrimaryKeyValues; 
			}
		}

		partial void ToStringCore(ref string value);

		public override string ToString()
		{
			string value = null;
			ToStringCore(ref value);

			if (value != null)
				return value;

			return "[PlaylistId]" + PlaylistId + ", " + "[TrackId]" + TrackId + ", " + "[WrittenAt]" + WrittenAt;
		}

		/// <summary>
		/// IEditableObject.CancelEdit 구현
		/// </summary>
		public override void CancelEdit()
		{
			if (_clone != null)
				Copy(_clone, this);
		}

		public override string PrimaryKeyValues
		{
			get { return string.Join(":", PlaylistId, TrackId, WrittenAt); }
		}

		public override string GetEntityTypeName()
		{
			return EntityTypeName;
		}
	}

	/// <summary>
	/// PlaylistTrackHistory 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
	/// </summary>
	public enum PlaylistTrackHistoryColumn
	{
				PlaylistId,
		TrackId,
		WrittenAt
	}

	
	/// <summary>
	/// PlaylistTrackHistory 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer<PlaylistTrackHistory> 구현)
	/// </summary>
	public class PlaylistTrackHistoryEqualityComparer : IEqualityComparer<PlaylistTrackHistory>
	{
		public bool Equals(PlaylistTrackHistory x, PlaylistTrackHistory y)
		{
			return x.PlaylistId == y.PlaylistId && x.TrackId == y.TrackId && x.WrittenAt == y.WrittenAt;
		}

		public int GetHashCode(PlaylistTrackHistory obj)
		{
			return obj.PlaylistId.GetHashCode() ^ obj.TrackId.GetHashCode() ^ obj.WrittenAt.GetHashCode();
		}
	}
	
	#endregion
	#region Track
    /// <summary>
	/// Track 엔터티
	/// </summary>
    public partial class Track : Entity<Track>, IEntity
	{
		public const string EntityTypeName = "Track";

		public static void Copy(Track source, Track target)
		{
						target.TrackId = source.TrackId;		
			target.Name = source.Name;		
			target.AlbumId = source.AlbumId;		
			target.BitCol = source.BitCol;		
			target.BitColNull = source.BitColNull;		
			target.TinyIntCol = source.TinyIntCol;		
			target.TinyIntColNull = source.TinyIntColNull;		
			target.SmallIntCol = source.SmallIntCol;		
			target.SmallIntColNull = source.SmallIntColNull;		
			target.BigIntCol = source.BigIntCol;		
			target.BigIntColNull = source.BigIntColNull;		
			target.CharCol = source.CharCol;		
			target.CharColNull = source.CharColNull;		
			target.VarCharCol = source.VarCharCol;		
			target.VarCharColNull = source.VarCharColNull;		
			target.NcharCol = source.NcharCol;		
			target.NcharColNull = source.NcharColNull;		
			target.NvarCharCol = source.NvarCharCol;		
			target.NvarCharColNull = source.NvarCharColNull;		
			target.BinaryCol = source.BinaryCol;		
			target.BinaryColNull = source.BinaryColNull;		
			target.DateCol = source.DateCol;		
			target.DateColNull = source.DateColNull;		
			target.DateTimeCol = source.DateTimeCol;		
			target.DateTimeColNull = source.DateTimeColNull;		
			target.SmallDateTimeCol = source.SmallDateTimeCol;		
			target.SmallDateTimeColNull = source.SmallDateTimeColNull;		
			target.DecimalCol = source.DecimalCol;		
			target.DecimalColNull = source.DecimalColNull;		
			target.FloatCol = source.FloatCol;		
			target.FloatColNull = source.FloatColNull;		
			target.RealCol = source.RealCol;		
			target.RealColNull = source.RealColNull;		
			target.SmallMoneyCol = source.SmallMoneyCol;		
			target.SmallMoneyColNull = source.SmallMoneyColNull;		
			target.TimeStampCol = source.TimeStampCol;		
			target.TimeCol = source.TimeCol;		
			target.TimeColNull = source.TimeColNull;		
			target.GuidCol = source.GuidCol;		
			target.GuidColNull = source.GuidColNull;		
			target.VarBinaryCol = source.VarBinaryCol;		
			target.VarBinaryColNull = source.VarBinaryColNull;
		}

		/// <summary>
		/// Track 객체를 복사한다.
		/// </summary>
		/// <returns></returns>
		public override Track Clone()
		{
			var clone = new Track();

			Copy(this, clone);

			return clone;
		}

		partial void GetEntityTextCore(ref string value);

		/// <summary>
		/// Track 객체를 대표하는 이름을 구한다.
		/// </summary>
		/// <returns></returns>
		public override string EntityText
		{
			get 
			{ 
				string value = null;
				GetEntityTextCore(ref value);

				if (value != null)
					return value;

				return PrimaryKeyValues; 
			}
		}

		partial void ToStringCore(ref string value);

		public override string ToString()
		{
			string value = null;
			ToStringCore(ref value);

			if (value != null)
				return value;

			return "[TrackId]" + TrackId + ", " + "[Name]" + Name + ", " + "[AlbumId]" + AlbumId + ", " + "[BitCol]" + BitCol + ", " + "[BitColNull]" + BitColNull + ", " + "[TinyIntCol]" + TinyIntCol + ", " + "[TinyIntColNull]" + TinyIntColNull + ", " + "[SmallIntCol]" + SmallIntCol + ", " + "[SmallIntColNull]" + SmallIntColNull + ", " + "[BigIntCol]" + BigIntCol + ", " + "[BigIntColNull]" + BigIntColNull + ", " + "[CharCol]" + CharCol + ", " + "[CharColNull]" + CharColNull + ", " + "[VarCharCol]" + VarCharCol + ", " + "[VarCharColNull]" + VarCharColNull + ", " + "[NcharCol]" + NcharCol + ", " + "[NcharColNull]" + NcharColNull + ", " + "[NvarCharCol]" + NvarCharCol + ", " + "[NvarCharColNull]" + NvarCharColNull + ", " + "[BinaryCol]" + BinaryCol + ", " + "[BinaryColNull]" + BinaryColNull + ", " + "[DateCol]" + DateCol + ", " + "[DateColNull]" + DateColNull + ", " + "[DateTimeCol]" + DateTimeCol + ", " + "[DateTimeColNull]" + DateTimeColNull + ", " + "[SmallDateTimeCol]" + SmallDateTimeCol + ", " + "[SmallDateTimeColNull]" + SmallDateTimeColNull + ", " + "[DecimalCol]" + DecimalCol + ", " + "[DecimalColNull]" + DecimalColNull + ", " + "[FloatCol]" + FloatCol + ", " + "[FloatColNull]" + FloatColNull + ", " + "[RealCol]" + RealCol + ", " + "[RealColNull]" + RealColNull + ", " + "[SmallMoneyCol]" + SmallMoneyCol + ", " + "[SmallMoneyColNull]" + SmallMoneyColNull + ", " + "[TimeStampCol]" + TimeStampCol + ", " + "[TimeCol]" + TimeCol + ", " + "[TimeColNull]" + TimeColNull + ", " + "[GuidCol]" + GuidCol + ", " + "[GuidColNull]" + GuidColNull + ", " + "[VarBinaryCol]" + VarBinaryCol + ", " + "[VarBinaryColNull]" + VarBinaryColNull;
		}

		/// <summary>
		/// IEditableObject.CancelEdit 구현
		/// </summary>
		public override void CancelEdit()
		{
			if (_clone != null)
				Copy(_clone, this);
		}

		public override string PrimaryKeyValues
		{
			get { return string.Join(":", TrackId); }
		}

		public override string GetEntityTypeName()
		{
			return EntityTypeName;
		}
	}

	/// <summary>
	/// Track 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
	/// </summary>
	public enum TrackColumn
	{
				TrackId,
		Name,
		AlbumId,
		BitCol,
		BitColNull,
		TinyIntCol,
		TinyIntColNull,
		SmallIntCol,
		SmallIntColNull,
		BigIntCol,
		BigIntColNull,
		CharCol,
		CharColNull,
		VarCharCol,
		VarCharColNull,
		NcharCol,
		NcharColNull,
		NvarCharCol,
		NvarCharColNull,
		BinaryCol,
		BinaryColNull,
		DateCol,
		DateColNull,
		DateTimeCol,
		DateTimeColNull,
		SmallDateTimeCol,
		SmallDateTimeColNull,
		DecimalCol,
		DecimalColNull,
		FloatCol,
		FloatColNull,
		RealCol,
		RealColNull,
		SmallMoneyCol,
		SmallMoneyColNull,
		TimeStampCol,
		TimeCol,
		TimeColNull,
		GuidCol,
		GuidColNull,
		VarBinaryCol,
		VarBinaryColNull
	}

	
	/// <summary>
	/// Track 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer<Track> 구현)
	/// </summary>
	public class TrackEqualityComparer : IEqualityComparer<Track>
	{
		public bool Equals(Track x, Track y)
		{
			return x.TrackId == y.TrackId;
		}

		public int GetHashCode(Track obj)
		{
			return obj.TrackId.GetHashCode();
		}
	}
	
	#endregion

	#endregion

	#region PropertyChangedEventArgs
	/// <summary>
	/// 속성 값이 변경된 후 발생하는 이벤트의 매개변수 클래스
	/// </summary>
	/// <typeparam name="T"></typeparam>
	internal class PropertyChangedEventArgs<T> : EventArgs where T : Entity<T>, new()
	{
		/// <summary>
		/// 속성 값이 변경된 엔티티
		/// </summary>
		public T Entity { get; set; }

		public PropertyChangedEventArgs(T entity)
		{
			Entity = entity;
		}
	}

	/// <summary>
	/// 속성 값이 변경되기 전 발생하는 이벤트의 매개변수 클래스
	/// </summary>
	/// <typeparam name="T"></typeparam>
	/// <typeparam name="K"></typeparam>
	internal class PropertyChangingEventArgs<T, K> : EventArgs where T : Entity<T>, new()
	{
		/// <summary>
		/// 속성 값이 변경될 엔티티
		/// </summary>
		public T Entity { get; set; }

		/// <summary>
		/// 새로 변경 될 속성 값
		/// </summary>
		public K Value { get; set; }

		public PropertyChangingEventArgs(T entity, K value)
		{
			Entity = entity;
			Value = value;
		}
	}
	#endregion

	#region Data
	#region EntityDao<T>
	public abstract partial class EntityDao<T> where T : Entity<T>, new()
	{
		internal EntityDao() { }

		#region Create
		/// <summary>
		/// 엔터티를 생성한다. string형 속성은 string.Empty 값으로 채우고, DateTime형 속성은 DateTime.Today 값으로 채운다.
		/// </summary>
		/// <returns>생성된 엔터티</returns>
		public virtual T Create()
		{
			return Create(string.Empty, DateTime.Today);
		}

		/// <summary>
		/// 엔터티를 생성한다. string형 속성은 string.Empty 값으로 채우고, DateTime형 속성은 기본 DateTime 값으로 채운다.
		/// </summary>
		/// <param name="defaultDateTime">기본 DateTime 값</param>
		/// <returns>생성된 엔터티</returns>
		public virtual T Create(DateTime defaultDateTime)
		{
			return Create(string.Empty, defaultDateTime);
		}

		/// <summary>
		/// 엔터티를 생성한다. string형 속성은 기본 string 값으로 채우고, DateTime형 속성은 기본 DateTime 값으로 채운다.
		/// </summary>
		/// <param name="defaultString">기본 string 값</param>
		/// <param name="defaultDateTime">기본 DateTime 값</param>
		/// <returns>생성된 엔터티</returns>
		public virtual T Create(string defaultString, DateTime defaultDateTime)
		{
			T entity = new T();
			entity.Clear(defaultString, defaultDateTime);

			return entity;
		}
		#endregion

		#region Get
		/// <summary>
		/// 모든 엔터티를 반환한다.
		/// </summary>
		/// <returns>엔터티의 리스트</returns>
        public virtual List<T> Get()
		{
			return Get<T>(null, null, false, 0, int.MaxValue);
		}

        public virtual Task<List<T>> GetAsync() 
            => Task.Run(() => Get());

        /// <summary>
        /// 조건식에 맞는 엔터티들을 반환한다.
        /// </summary>
        /// <param name="where">조건식</param>
        /// <returns>엔터티의 리스트</returns>
        public virtual List<T> Get(Expression<Func<T, bool>> where)
		{
			return Get<T>(where, null, false, 0, int.MaxValue);
		}

        public virtual Task<List<T>> GetAsync(Expression<Func<T, bool>> where)
            => Task.Run(() => Get(where));

		/// <summary>
		/// 모든 엔터티들을 정렬식에 따라 정렬한 후 반환한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
		/// </summary>
		/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
		/// <param name="orderBy">정렬식</param>
		/// <param name="ascending">true이면 오름차순, false이면 내림차순</param>
		/// <returns>엔터티의 리스트</returns>
        public virtual List<T> Get<U>(Expression<Func<T, U>> orderBy, bool ascending)
		{
			return Get(null, orderBy, ascending, 0, int.MaxValue);
		}

        public virtual Task<List<T>> GetAsync<U>(Expression<Func<T, U>> orderBy, bool ascending)
            => Task.Run(() => Get(orderBy, ascending));

		/// <summary>
		/// 조건식에 맞는 엔터티들을 정렬식에 따라 정렬한 후 반환한다. 페이징을 지원한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
		/// </summary>
		/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
		/// <param name="orderBy">정렬식</param>
		/// <param name="ascending">true이면 오름차순, false이면 내림차순</param>
		/// <param name="startRowIndex">반환할 엔터티의 시작 인덱스</param>
		/// <param name="maximumRows">반환할 엔터티의 갯수</param>
		/// <returns>엔터티의 리스트</returns>
        public virtual List<T> Get<U>(Expression<Func<T, U>> orderBy, bool ascending, int startRowIndex, int maximumRows)
		{
			return Get(null, orderBy, ascending, startRowIndex, maximumRows);
		}

        public virtual Task<List<T>> GetAsync<U>(Expression<Func<T, U>> orderBy, bool ascending, int startRowIndex, int maximumRows)
            => Task.Run(() => Get(orderBy, ascending, startRowIndex, maximumRows));

		/// <summary>
		/// 조건식에 맞는 엔터티들을 정렬식에 따라 정렬한 후 반환한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
		/// </summary>
		/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
		/// <param name="where">조건식</param>
		/// <param name="orderBy">정렬식</param>
		/// <param name="ascending">true이면 오름차순, false이면 내림차순</param>
		/// <returns>엔터티의 리스트</returns>
        public virtual List<T> Get<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending)
		{
			return Get(where, orderBy, ascending, 0, int.MaxValue);
		}

        public virtual Task<List<T>> GetAsync<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending)
            => Task.Run(() => Get(where, orderBy, ascending));

		/// <summary>
		/// 조건식에 맞는 엔터티들을 정렬식에 따라 정렬한 후 반환한다. 페이징을 지원한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
		/// </summary>
		/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
		/// <param name="where">조건식</param>
		/// <param name="orderBy">정렬식</param>
		/// <param name="ascending">true이면 오름차순, false이면 내림차순</param>
		/// <param name="startRowIndex">반환할 엔터티의 시작 인덱스</param>
		/// <param name="maximumRows">반환할 엔터티의 갯수</param>
		/// <returns>엔터티의 리스트</returns>
        public virtual List<T> Get<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending, int startRowIndex, int maximumRows)
		{
            using var context = DbContextFactory.Create();

            return GetCore(where, orderBy, ascending, startRowIndex, maximumRows, context).ToList();
		}

        public virtual Task<List<T>> GetAsync<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending, int startRowIndex, int maximumRows)
            => Task.Run(() => Get(where, orderBy, ascending, startRowIndex, maximumRows));
		#endregion

		#region select
		/// <summary>
		///   모든 선택식의 결과를 반환한다.
		/// </summary>
		/// <typeparam name="R"> 선택 형식 </typeparam>
		/// <param name="select"> 선택식 </param>
		/// <returns> 엔터티의 리스트 </returns>
        public virtual List<R> Select<R>(Expression<Func<T, R>> select)
		{
			return Select<T, R>(null, null, false, 0, int.MaxValue, select);
		}

        public virtual Task<List<R>> SelectAsync<R>(Expression<Func<T, R>> select)
            => Task.Run(() => Select(select));

		/// <summary>
		///   조건식에 맞는 선택식의 결과를 반환한다.
		/// </summary>
		/// <typeparam name="R"> 선택 형식 </typeparam>
		/// <param name="where"> 조건식 </param>
		/// <param name="select"> 선택식 </param>
		/// <returns> 엔터티의 리스트 </returns>
        public virtual List<R> Select<R>(Expression<Func<T, bool>> where, Expression<Func<T, R>> select)
		{
			return Select<T, R>(where, null, false, 0, int.MaxValue, select);
		}

        public virtual Task<List<R>> SelectAsync<R>(Expression<Func<T, bool>> where, Expression<Func<T, R>> select)
            => Task.Run(() => Select(where, select));

		/// <summary>
		///   모든 엔터티들을 정렬식에 따라 정렬한 후 선택식의 결과를 반환한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
		/// </summary>
		/// <typeparam name="U"> 정렬 기준이 되는 속성의 형식 </typeparam>
		/// <typeparam name="R"> 선택 형식 </typeparam>
		/// <param name="orderBy"> 정렬식 </param>
		/// <param name="ascending"> true이면 오름차순, false이면 내림차순 </param>
		/// <param name="select"> 선택식 </param>
		/// <returns> 엔터티의 리스트 </returns>
        public virtual List<R> Select<U, R>(Expression<Func<T, U>> orderBy, bool ascending, Expression<Func<T, R>> select)
		{
			return Select(null, orderBy, ascending, 0, int.MaxValue, select);
		}

        public virtual Task<List<R>> SelectAsync<U, R>(Expression<Func<T, U>> orderBy, bool ascending, Expression<Func<T, R>> select)
            => Task.Run(() => Select(orderBy, ascending, select));

		/// <summary>
		///   조건식에 맞는 엔터티들을 정렬식에 따라 정렬한 후 선택식의 결과를 반환한다. 페이징을 지원한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
		/// </summary>
		/// <typeparam name="U"> 정렬 기준이 되는 속성의 형식 </typeparam>
		/// <typeparam name="R"> 선택 형식 </typeparam>
		/// <param name="orderBy"> 정렬식 </param>
		/// <param name="ascending"> true이면 오름차순, false이면 내림차순 </param>
		/// <param name="startRowIndex"> 반환할 엔터티의 시작 인덱스 </param>
		/// <param name="maximumRows"> 반환할 엔터티의 갯수 </param>
		/// <param name="select"> 선택식 </param>
		/// <returns> 엔터티의 리스트 </returns>
        public virtual List<R> Select<U, R>(Expression<Func<T, U>> orderBy, bool ascending, int startRowIndex, int maximumRows, Expression<Func<T, R>> select)
		{
			return Select(null, orderBy, ascending, startRowIndex, maximumRows, select);
		}

        public virtual Task<List<R>> SelectAsync<U, R>(Expression<Func<T, U>> orderBy, bool ascending, int startRowIndex, int maximumRows, Expression<Func<T, R>> select)
            => Task.Run(() => Select(orderBy, ascending, startRowIndex, maximumRows, select));
		

		/// <summary>
		///   조건식에 맞는 엔터티들을 정렬식에 따라 정렬한 후 선택식의 결과를 반환한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
		/// </summary>
		/// <typeparam name="U"> 정렬 기준이 되는 속성의 형식 </typeparam>
		/// <typeparam name="R"> 선택 형식 </typeparam>
		/// <param name="where"> 조건식 </param>
		/// <param name="orderBy"> 정렬식 </param>
		/// <param name="ascending"> true이면 오름차순, false이면 내림차순 </param>
		/// <param name="select"> 선택식 </param>
		/// <returns> 엔터티의 리스트 </returns>
        public virtual List<R> Select<U, R>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending, Expression<Func<T, R>> select)
		{
			return Select(where, orderBy, ascending, 0, int.MaxValue, select);
		}

        public virtual Task<List<R>> SelectAsync<U, R>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending, Expression<Func<T, R>> select)
            => Task.Run(() => Select(where, orderBy, ascending, select));

		/// <summary>
		///   조건식에 맞는 엔터티들을 정렬식에 따라 정렬한 후 선택식의 결과를 반환한다. 페이징과 프로젝션을을 지원한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
		/// </summary>
		/// <typeparam name="U"> 정렬 기준이 되는 속성의 형식 </typeparam>
		/// <typeparam name="R"> 선택 형식 </typeparam>
		/// <param name="where"> 조건식 </param>
		/// <param name="orderBy"> 정렬식 </param>
		/// <param name="ascending"> true이면 오름차순, false이면 내림차순 </param>
		/// <param name="startRowIndex"> 반환할 엔터티의 시작 인덱스 </param>
		/// <param name="maximumRows"> 반환할 엔터티의 갯수 </param>
		/// <param name="select"> 선택식 </param>
		/// <returns> 엔터티의 리스트 </returns>
        public virtual List<R> Select<U, R>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending, int startRowIndex, int maximumRows, Expression<Func<T, R>> select)
		{
            using var context = DbContextFactory.Create();

				var query = GetCore(where, orderBy, ascending, startRowIndex, maximumRows, context);
				return query.Select(select).ToList();
		}

        public virtual Task<List<R>> SelectAsync<U, R>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending, int startRowIndex, int maximumRows, Expression<Func<T, R>> select)
            => Task.Run(() => Select(where, orderBy, ascending, startRowIndex, maximumRows, select));

		private static IQueryable<T> GetCore<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending, int startRowIndex, int maximumRows, ChinookEntities context)
		{
			var query = from x in context.Set<T>()
						select x;

			if (where != null)
				query = query.Where(where);

			IOrderedQueryable<T> orderedQuery = null;

			if (orderBy != null)
				orderedQuery = (ascending) ? query.OrderBy(orderBy) : query.OrderByDescending(orderBy);

			if (startRowIndex != 0 || maximumRows != int.MaxValue)
			{
				if (orderedQuery != null)
					orderedQuery = (IOrderedQueryable<T>)orderedQuery.Skip(startRowIndex).Take(maximumRows);
				else
					query = query.Skip(startRowIndex).Take(maximumRows);
			}

			return orderedQuery ?? query;
		}
		#endregion

		#region GetFirst / GetLast
		/// <summary>
		/// 모든 엔터티 중 첫번째 엔터티를 반환한다. 엔터티의 순서는 DB에 의해 결정된다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
		/// </summary>
		/// <returns>엔터티</returns>
        public virtual T GetFirst()
		{
			return GetFirst<T>(null, null);
		}

        public virtual Task<T> GetFirstAsync()
            => Task.Run(() => GetFirst());

		/// <summary>
		/// 조건식에 맞는 엔터티 중 첫번째 엔터티를 반환한다. 엔터티의 순서는 DB에 의해 결정된다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
		/// </summary>
		/// <param name="where">조건식</param>
		/// <returns>엔터티</returns>
        public virtual T GetFirst(Expression<Func<T, bool>> where)
		{
			return GetFirst<T>(where, null);
		}

        public virtual Task<T> GetFirstAsync(Expression<Func<T, bool>> where) 
            => Task.Run(() => GetFirst(where));

        /// <summary>
		/// 모든 엔터티를 정렬식에 따라 정렬했을 때 첫번째 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
		/// </summary>
		/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
		/// <param name="orderBy">정렬식</param>
		/// <returns>엔터티</returns>
        public virtual T GetFirst<U>(Expression<Func<T, U>> orderBy)
		{
			return GetFirst(null, orderBy);
		}

        public virtual Task<T> GetFirstAsync<U>(Expression<Func<T, U>> orderBy)
            => Task.Run(() => GetFirst(orderBy));

		/// <summary>
		/// 조건식에 맞는 엔터티를 정렬식에 따라 정렬했을 때 첫번째 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
		/// </summary>
		/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
		/// <param name="where">조건식</param>
		/// <param name="orderBy">정렬식</param>
		/// <returns>엔터티</returns>
        public virtual T GetFirst<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy)
		{
		    return GetFirstCore(where, orderBy, true);
		}

        public virtual Task<T> GetFirstAsync<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy)
		    => Task.Run(() => GetFirst(where, orderBy));

	    private T GetFirstCore<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending)
	    {
            using var context = DbContextFactory.Create();

	        return QueryFirst(where, orderBy, ascending, context).FirstOrDefault();
	    }

        /// <summary>
        /// 모든 엔터티를 정렬식에 따라 정렬했을 때 마지막 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
        /// </summary>
        /// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
        /// <param name="orderBy">정렬식</param>
        /// <returns>엔터티</returns>
        public virtual T GetLast<U>(Expression<Func<T, U>> orderBy)
		{
			return GetLast(null, orderBy);
		}

        public virtual Task<T> GetLastAsync<U>(Expression<Func<T, U>> orderBy)
		=> Task.Run(() => GetLast(orderBy));

		/// <summary>
		/// 조건식에 맞는 엔터티를 정렬식에 따라 정렬했을 때 마지막 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
		/// </summary>
		/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
		/// <param name="where">조건식</param>
		/// <param name="orderBy">정렬식</param>
		/// <returns>엔터티</returns>
		public virtual T GetLast<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy)
		{
		    return GetFirstCore(where, orderBy, false);
        }

        public virtual Task<T> GetLastAsync<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy)
		=> Task.Run(() => GetLast(where, orderBy));

        private static IQueryable<T> QueryFirst<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending, ChinookEntities context)
		{
			var query = from x in context.Set<T>()
						select x;

			if (where != null)
				query = query.Where(where);

            // 마지막 행은 orderby가 반드시 지정되어 있어야 함. orderby를 지정하지 않으면 skip 메서드를 사용할 수 없기 때문.
            if (orderBy != null)
			    query = @ascending ? query.OrderBy(orderBy) : query.OrderByDescending(orderBy);

            return query;
		}
		#endregion

		#region SelectFirst / SelectLast
		/// <summary>
		/// 모든 엔터티 중 첫번째 엔터티를 반환한다. 엔터티의 순서는 DB에 의해 결정된다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
		/// </summary>
		/// <param name="select">선택식</param>
		/// <returns>엔터티</returns>
        public virtual R SelectFirst<R>(Expression<Func<T, R>> select)
		{
			return SelectFirst<T, R>(null, null, select);
		}

        public virtual Task<R> SelectFirstAsync<R>(Expression<Func<T, R>> select)
		=> Task.Run(() => SelectFirst(select));

		/// <summary>
		/// 조건식에 맞는 엔터티 중 첫번째 엔터티를 반환한다. 엔터티의 순서는 DB에 의해 결정된다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
		/// </summary>
		/// <typeparam name="R">선택 형식</typeparam>
		/// <param name="where">조건식</param>
		/// <param name="select">선택식</param>
		/// <returns>엔터티</returns>
        public virtual R SelectFirst<R>(Expression<Func<T, bool>> where, Expression<Func<T, R>> select)
		{
			return SelectFirst<T, R>(where, null, select);
		}

        public virtual Task<R> SelectFirstAsync<R>(Expression<Func<T, bool>> where, Expression<Func<T, R>> select)
		=> Task.Run(() => SelectFirst(where, select));

		/// <summary>
		/// 모든 엔터티를 정렬식에 따라 정렬했을 때 첫번째 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
		/// </summary>
		/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
		/// <typeparam name="R">선택 형식</typeparam>
		/// <param name="orderBy">정렬식</param>
		/// <param name="select">선택식</param>
		/// <returns>엔터티</returns>
        public virtual R SelectFirst<U, R>(Expression<Func<T, U>> orderBy, Expression<Func<T, R>> select)
		{
			return SelectFirst(null, orderBy, select);
		}

        public virtual Task<R> SelectFirstAsync<U, R>(Expression<Func<T, U>> orderBy, Expression<Func<T, R>> select)
		=> Task.Run(() => SelectFirst(orderBy, select));

		/// <summary>
		/// 조건식에 맞는 엔터티를 정렬식에 따라 정렬했을 때 첫번째 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
		/// </summary>
		/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
		/// <typeparam name="R">선택 형식</typeparam>
		/// <param name="where">조건식</param>
		/// <param name="orderBy">정렬식</param>
		/// <param name="select">선택식</param>
		/// <returns>엔터티</returns>
        public virtual R SelectFirst<U, R>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, Expression<Func<T, R>> select)
		{
		    return SelectFirstCore(where, orderBy, select, true);
		}

        public virtual Task<R> SelectFirstAsync<U, R>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, Expression<Func<T, R>> select)
		=> Task.Run(() => SelectFirst(where, orderBy, select));

        /// <summary>
        /// 조건식에 맞는 엔터티를 정렬식에 따라 정렬했을 때 첫번째 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
        /// </summary>
        /// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
        /// <typeparam name="R">선택 형식</typeparam>
        /// <param name="where">조건식</param>
        /// <param name="orderBy">정렬식</param>
        /// <param name="select">선택식</param>
        /// <param name="ascending">true이면 오름차순, false이면 내림차순</param>
        /// <returns>엔터티</returns>
        private R SelectFirstCore<U, R>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, Expression<Func<T, R>> select, bool ascending)
		{
            using var context = DbContextFactory.Create();

			var query = QueryFirst(where, orderBy, ascending, context);
			return query.Select(select).FirstOrDefault();
		}

        /// <summary>
        /// 모든 엔터티를 정렬식에 따라 정렬했을 때 마지막 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
        /// </summary>
        /// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
        /// <typeparam name="R">선택 형식</typeparam>
        /// <param name="orderBy">정렬식</param>
        /// <param name="select">선택식</param>
        /// <returns>엔터티</returns>
        public virtual R SelectLast<U, R>(Expression<Func<T, U>> orderBy, Expression<Func<T, R>> select)
	    {
	        return SelectLast(null, orderBy, select);
	    }

        public virtual Task<R> SelectLastAsync<U, R>(Expression<Func<T, U>> orderBy, Expression<Func<T, R>> select)
		=> Task.Run(() => SelectLast(orderBy, select));

        /// <summary>
        /// 조건식에 맞는 엔터티를 정렬식에 따라 정렬했을 때 마지막 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
        /// </summary>
        /// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
        /// <typeparam name="R">선택 형식</typeparam>
        /// <param name="where">조건식</param>
        /// <param name="orderBy">정렬식</param>
        /// <param name="select">선택식</param>
        /// <returns>엔터티</returns>
        public virtual R SelectLast<U, R>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, Expression<Func<T, R>> select)
	    {
	        return SelectFirstCore(where, orderBy, select, false);
	    }

        public virtual Task<R> SelectLastAsync<U, R>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, Expression<Func<T, R>> select)
		=> Task.Run(() => SelectLast(where, orderBy, select));
        #endregion

		#region GetCount
		/// <summary>
		/// 모든 엔터티의 갯수를 구한다.
		/// </summary>
		/// <returns>엔터티의 갯수</returns>
        public virtual int GetCount()
		{
			return GetCount(null);
		}

        public virtual Task<int> GetCountAsync()
		=> Task.Run(() => GetCount());

		/// <summary>
		/// 조건식에 맞는 엔터티의 갯수를 구한다.
		/// </summary>
		/// <param name="where">조건식</param>
		/// <returns>엔터티의 갯수</returns>
        public virtual int GetCount(Expression<Func<T, bool>> where)
		{
            using var context = DbContextFactory.Create();

			var query = from item in context.Set<T>()
						select item;

			if (where != null)
				query = query.Where(where);

			return query.Count();
		}

        public virtual Task<int> GetCountAsync(Expression<Func<T, bool>> where)
		=> Task.Run(() => GetCount(where));
		#endregion

		#region Exist
		/// <summary>
		/// 조건식에 맞는 엔터티가 존재하는지 검사한다.
		/// </summary>
		/// <param name="where">조건식</param>
		/// <returns>존재 여부</returns>
        public virtual bool Exists(Expression<Func<T, bool>> where)
		{
            using var context = DbContextFactory.Create();

			var query = from item in context.Set<T>()
						select item;

			if (where != null)
				query = query.Where(where);

			return query.Any();
		}

        public virtual Task<bool> ExistsAsync(Expression<Func<T, bool>> where)
		=> Task.Run(() => Exists(where));
		#endregion

		#region Write log partial methods
		/// <summary>
		/// 엔티티의 로그를 기록한다.
		/// </summary>
		/// <param name="entity">엔티티</param>
		/// <param name="logType">로그 타입</param>
		partial void WriteSingleLog(T entity, LogType logType);

		/// <summary>
		/// 엔티티 컬렉션의 로그를 기록한다.
		/// </summary>
		/// <param name="entities">엔티티 컬렉션</param>
		/// <param name="logType">로그 타입</param>
		partial void WriteMultipleLog(IEnumerable<T> entities, LogType logType);
		#endregion

		#region Insert / Update / Delete
		/// <summary>
		/// 엔터티를 삽입한다.
		/// </summary>
		/// <param name="entity">삽입할 엔터티</param>
		/// <param name="withAudit">감사정보(수정자, 수정일)를 기록한다.</param>
        /// <returns>삽입된 엔터티</returns>
        public virtual T Insert(T entity, bool withAudit = false)
		{
            using var context = DbContextFactory.Create();

			MarkToInsert(context, entity);
			
			if (withAudit)
                entity.WriteAuditInfo();

			context.SaveChanges();

			WriteSingleLog(entity, LogType.Insert);

			return entity;
		}

        public virtual Task<T> InsertAsync(T entity, bool withAudit = false)
		=> Task.Run(() => Insert(entity, withAudit));

		internal virtual void MarkToInsert(ChinookEntities context, T entity)
		{
			context.Set<T>().Add(entity);
		}

		/// <summary>
		/// 엔터티 컬렉션을 삽입한다.
		/// </summary>
		/// <param name="entities">삽입할 엔터티가 포함된 컬렉션</param>
		/// <param name="withAudit">감사정보(수정자, 수정일)를 기록한다.</param>
		/// <returns>삽입된 엔터티의 갯수</returns>
        public virtual int InsertMany(IEnumerable<T> entities, bool withAudit = false)
		{
            using var context = DbContextFactory.Create();

            foreach (var entity in entities)
            {
                MarkToInsert(context, entity);
				
				if (withAudit)
		            entity.WriteAuditInfo();
            }

			int count = context.SaveChanges();

			WriteMultipleLog(entities, LogType.Insert);

			return count;
		}

        public virtual Task<int> InsertManyAsync(IEnumerable<T> entities, bool withAudit = false)
		=> Task.Run(() => InsertMany(entities, withAudit));

		/// <summary>
		/// 엔터티를 갱신한다.
		/// </summary>
		/// <param name="entity">갱신할 엔터티</param>
		/// <param name="withAudit">감사정보(수정자, 수정일)를 기록한다.</param>
		/// <returns>갱신된 엔터티의 갯수</returns>
        public virtual int Update(T entity, bool withAudit = false)
		{
            using var context = DbContextFactory.Create();

			MarkToUpdate(context, entity);
			
			if (withAudit)
                entity.WriteAuditInfo();

			int count = context.SaveChanges();

			WriteSingleLog(entity, LogType.Update);

			return count;
		}

        public virtual Task<int> UpdateAsync(T entity, bool withAudit = false)
		=> Task.Run(() => Update(entity, withAudit));

		internal virtual void MarkToUpdate(ChinookEntities context, T entity)
		{
			context.Entry(entity).State = EntityState.Modified;
		}

		/// <summary>
		/// 엔터티 컬렉션을 갱신한다.
		/// </summary>
		/// <param name="entities">갱신할 엔터티가 포함된 컬렉션</param>
		/// <param name="withAudit">감사정보(수정자, 수정일)를 기록한다.</param>
		/// <returns>갱신된 엔터티의 갯수</returns>
        public virtual int UpdateMany(IEnumerable<T> entities, bool withAudit = false)
		{
            using var context = DbContextFactory.Create();

            foreach (var entity in entities)
            {
                MarkToUpdate(context, entity);

				if (withAudit)
					entity.WriteAuditInfo();
            }

			int count = context.SaveChanges();

			WriteMultipleLog(entities, LogType.Update);

			return count;
		}

        public virtual Task<int> UpdateManyAsync(IEnumerable<T> entities, bool withAudit = false)
		=> Task.Run(() => UpdateMany(entities, withAudit));

		/// <summary>
		/// 엔터티를 삭제한다.
		/// </summary>
		/// <param name="entity">삭제할 엔터티</param>
		/// <returns>삭제된 엔터티의 갯수</returns>
        public virtual int Delete(T entity)
		{
            using var context = DbContextFactory.Create();

            MarkToDelete(context, entity);
			int count = context.SaveChanges();

			WriteSingleLog(entity, LogType.Delete);
			
			return count;
		}

        public virtual Task<int> DeleteAsync(T entity)
		=> Task.Run(() => Delete(entity));

		internal virtual void MarkToDelete(ChinookEntities context, T entity)
		{
			context.Entry(entity).State = EntityState.Deleted;
		}

		/// <summary>
		/// 엔터티 컬렉션을 삭제한다.
		/// </summary>
		/// <param name="entities">삭제할 엔터티 컬렉션</param>
		/// <returns>삭제된 엔터티의 갯수</returns>
        public virtual int DeleteMany(IEnumerable<T> entities)
		{
            using var context = DbContextFactory.Create();
			
			MarkToDeleteMany(context, entities);
			int count = context.SaveChanges();

			WriteMultipleLog(entities, LogType.Delete);

			return count;
		}

        public virtual Task<int> DeleteManyAsync(IEnumerable<T> entities)
		=> Task.Run(() => DeleteMany(entities));

		internal virtual void MarkToDeleteMany(ChinookEntities context, IEnumerable<T> entities)
		{
			foreach (var entity in entities)
				MarkToDelete(context, entity);
		}

		/// <summary>
		/// 조건식을 만족하는 엔터티들을 삭제한다.
		/// </summary>
		/// <param name="where">조건식</param>
		/// <returns>삭제된 엔터티의 갯수</returns>
        public virtual int DeleteAll(Expression<Func<T, bool>> where)
		{
            using var context = DbContextFactory.Create();

			var query = from item in context.Set<T>()
						select item;

			if (where != null)
				query = query.Where(where);

			var entities = query.ToList();

			MarkToDeleteMany(context, entities);

			int count = context.SaveChanges();

			WriteMultipleLog(entities, LogType.Delete);

			return count;
		}

        public virtual Task<int> DeleteAllAsync(Expression<Func<T, bool>> where)
		=> Task.Run(() => DeleteAll(where));
		#endregion
	}
	#endregion

		#region AlbumDao
	/// <summary>
	/// Album 데이터 클래스
	/// </summary>
	public partial class AlbumDao : EntityDao<Album>
	{
		internal AlbumDao() {}

		
		/// <summary>
		/// 기본키가 일치하는 엔터티를 구한다.
		/// </summary>
				/// <param name="albumId">기본키</param>
		/// <returns>기본키가 일치하는 엔터티</returns>
        public virtual Album GetByKey(Int32 albumId)
		{
            using var context = DbContextFactory.Create();

            return context.Set<Album>().FirstOrDefault(x =>  x.AlbumId == albumId);
		}

        public virtual Task<Album> GetByKeyAsync(Int32 albumId)
			=> Task.Run(() => GetByKey(albumId));

		/// <summary>
		/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
		/// </summary>
				/// <param name="albumId">기본키</param>
		/// <returns>존재 여부</returns>
        public virtual bool ExistsByKey(Int32 albumId)
		{
            using var context = DbContextFactory.Create();

			return context.Set<Album>().Count(x =>  x.AlbumId == albumId) > 0;
		}

        public virtual Task<bool> ExistsByKeyAsync(Int32 albumId)
		=> Task.Run(() => ExistsByKey(albumId));

		/// <summary>
		/// 기본키가 일치하는 엔터티를 삭제한다.
		/// </summary>
				/// <param name="albumId">기본키</param>
		/// <returns>삭제된 엔터티의 갯수</returns>
        public virtual int DeleteByKey(Int32 albumId)
		{
            using var context = DbContextFactory.Create();

			var query = from x in context.Set<Album>()
			where x.AlbumId == albumId
			select x;

			var entity = query.FirstOrDefault();

            if (entity == null)
                return 0;

			MarkToDelete(context, entity);

			return context.SaveChanges();
		}

        public virtual Task<int> DeleteByKeyAsync(Int32 albumId)
		=> Task.Run(() => DeleteByKey(albumId));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입할 엔터티</param>
		/// <param name="withAudit">감사정보(수정자, 수정일)를 기록한다.</param>
		/// <returns>삽입된 엔터티</returns>
        public virtual Album InsertIfNotExist(Album entity, bool withAudit = false)
	    {
            using var context = DbContextFactory.Create();

	        if (context.Set<Album>().Count(x =>  x.AlbumId == entity.AlbumId) > 0)
	            return null;

	        MarkToInsert(context, entity);

			if (withAudit)
                entity.WriteAuditInfo();

			context.SaveChanges();

	        return entity;
	    }

        public virtual Task<Album> InsertIfNotExistAsync(Album entity)
		=> Task.Run(() => InsertIfNotExist(entity));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 있으면 갱신하고 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입 혹은 갱신할 엔터티</param>
		/// <param name="withAudit">감사정보(수정자, 수정일)를 기록한다.</param>
		/// <returns>삽입했으면 true, 갱신했으면 false</returns>
        public virtual bool InsertOrUpdate(Album entity, bool withAudit = false)
	    {
            using var context = DbContextFactory.Create();

			if (withAudit)
                entity.WriteAuditInfo();
            
	        if (context.Set<Album>().Count(x =>  x.AlbumId == entity.AlbumId) > 0)
	        {
	            MarkToUpdate(context, entity);
	            
				context.SaveChanges();

	            return false;
            }
            else
	        {
	            MarkToInsert(context, entity);
	            
				context.SaveChanges();

	            return true;
            }
	    }

        public virtual Task<bool> InsertOrUpdateAsync(Album entity, bool withAudit = false)
		=> Task.Run(() => InsertOrUpdate(entity, withAudit));
		
				/// <summary>
		/// 외래키 ArtistId 이(가) 일치하는 엔터티 컬렉션을 구한다.
		/// </summary>
		/// <param name="artistId">외래키</param>
		/// <returns>ArtistId 이(가) 일치하는 엔터티 컬렉션</returns>
        public virtual List<Album> GetByArtistId(Int32 artistId)
		{
            using var context = DbContextFactory.Create();

			return context.Set<Album>().Where(x => x.ArtistId == artistId).ToList();
		}

        public virtual Task<List<Album>> GetByArtistIdAsync(Int32 artistId)
		=> Task.Run(() => GetByArtistId(artistId));
	}
	#endregion
	#region ArtistDao
	/// <summary>
	/// Artist 데이터 클래스
	/// </summary>
	public partial class ArtistDao : EntityDao<Artist>
	{
		internal ArtistDao() {}

		
		/// <summary>
		/// 기본키가 일치하는 엔터티를 구한다.
		/// </summary>
				/// <param name="artistId">기본키</param>
		/// <returns>기본키가 일치하는 엔터티</returns>
        public virtual Artist GetByKey(Int32 artistId)
		{
            using var context = DbContextFactory.Create();

            return context.Set<Artist>().FirstOrDefault(x =>  x.ArtistId == artistId);
		}

        public virtual Task<Artist> GetByKeyAsync(Int32 artistId)
			=> Task.Run(() => GetByKey(artistId));

		/// <summary>
		/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
		/// </summary>
				/// <param name="artistId">기본키</param>
		/// <returns>존재 여부</returns>
        public virtual bool ExistsByKey(Int32 artistId)
		{
            using var context = DbContextFactory.Create();

			return context.Set<Artist>().Count(x =>  x.ArtistId == artistId) > 0;
		}

        public virtual Task<bool> ExistsByKeyAsync(Int32 artistId)
		=> Task.Run(() => ExistsByKey(artistId));

		/// <summary>
		/// 기본키가 일치하는 엔터티를 삭제한다.
		/// </summary>
				/// <param name="artistId">기본키</param>
		/// <returns>삭제된 엔터티의 갯수</returns>
        public virtual int DeleteByKey(Int32 artistId)
		{
            using var context = DbContextFactory.Create();

			var query = from x in context.Set<Artist>()
			where x.ArtistId == artistId
			select x;

			var entity = query.FirstOrDefault();

            if (entity == null)
                return 0;

			MarkToDelete(context, entity);

			return context.SaveChanges();
		}

        public virtual Task<int> DeleteByKeyAsync(Int32 artistId)
		=> Task.Run(() => DeleteByKey(artistId));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입할 엔터티</param>
		/// <param name="withAudit">감사정보(수정자, 수정일)를 기록한다.</param>
		/// <returns>삽입된 엔터티</returns>
        public virtual Artist InsertIfNotExist(Artist entity, bool withAudit = false)
	    {
            using var context = DbContextFactory.Create();

	        if (context.Set<Artist>().Count(x =>  x.ArtistId == entity.ArtistId) > 0)
	            return null;

	        MarkToInsert(context, entity);

			if (withAudit)
                entity.WriteAuditInfo();

			context.SaveChanges();

	        return entity;
	    }

        public virtual Task<Artist> InsertIfNotExistAsync(Artist entity)
		=> Task.Run(() => InsertIfNotExist(entity));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 있으면 갱신하고 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입 혹은 갱신할 엔터티</param>
		/// <param name="withAudit">감사정보(수정자, 수정일)를 기록한다.</param>
		/// <returns>삽입했으면 true, 갱신했으면 false</returns>
        public virtual bool InsertOrUpdate(Artist entity, bool withAudit = false)
	    {
            using var context = DbContextFactory.Create();

			if (withAudit)
                entity.WriteAuditInfo();
            
	        if (context.Set<Artist>().Count(x =>  x.ArtistId == entity.ArtistId) > 0)
	        {
	            MarkToUpdate(context, entity);
	            
				context.SaveChanges();

	            return false;
            }
            else
	        {
	            MarkToInsert(context, entity);
	            
				context.SaveChanges();

	            return true;
            }
	    }

        public virtual Task<bool> InsertOrUpdateAsync(Artist entity, bool withAudit = false)
		=> Task.Run(() => InsertOrUpdate(entity, withAudit));
		
				/// <summary>
		/// 외래키 CompanyId 이(가) 일치하는 엔터티 컬렉션을 구한다.
		/// </summary>
		/// <param name="companyId">외래키</param>
		/// <returns>CompanyId 이(가) 일치하는 엔터티 컬렉션</returns>
        public virtual List<Artist> GetByCompanyId(Int32? companyId)
		{
            using var context = DbContextFactory.Create();

			return context.Set<Artist>().Where(x => x.CompanyId == companyId).ToList();
		}

        public virtual Task<List<Artist>> GetByCompanyIdAsync(Int32? companyId)
		=> Task.Run(() => GetByCompanyId(companyId));
	}
	#endregion
	#region CompanyDao
	/// <summary>
	/// Company 데이터 클래스
	/// </summary>
	public partial class CompanyDao : EntityDao<Company>
	{
		internal CompanyDao() {}

		
		/// <summary>
		/// 기본키가 일치하는 엔터티를 구한다.
		/// </summary>
				/// <param name="companyId">기본키</param>
		/// <returns>기본키가 일치하는 엔터티</returns>
        public virtual Company GetByKey(Int32 companyId)
		{
            using var context = DbContextFactory.Create();

            return context.Set<Company>().FirstOrDefault(x =>  x.CompanyId == companyId);
		}

        public virtual Task<Company> GetByKeyAsync(Int32 companyId)
			=> Task.Run(() => GetByKey(companyId));

		/// <summary>
		/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
		/// </summary>
				/// <param name="companyId">기본키</param>
		/// <returns>존재 여부</returns>
        public virtual bool ExistsByKey(Int32 companyId)
		{
            using var context = DbContextFactory.Create();

			return context.Set<Company>().Count(x =>  x.CompanyId == companyId) > 0;
		}

        public virtual Task<bool> ExistsByKeyAsync(Int32 companyId)
		=> Task.Run(() => ExistsByKey(companyId));

		/// <summary>
		/// 기본키가 일치하는 엔터티를 삭제한다.
		/// </summary>
				/// <param name="companyId">기본키</param>
		/// <returns>삭제된 엔터티의 갯수</returns>
        public virtual int DeleteByKey(Int32 companyId)
		{
            using var context = DbContextFactory.Create();

			var query = from x in context.Set<Company>()
			where x.CompanyId == companyId
			select x;

			var entity = query.FirstOrDefault();

            if (entity == null)
                return 0;

			MarkToDelete(context, entity);

			return context.SaveChanges();
		}

        public virtual Task<int> DeleteByKeyAsync(Int32 companyId)
		=> Task.Run(() => DeleteByKey(companyId));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입할 엔터티</param>
		/// <param name="withAudit">감사정보(수정자, 수정일)를 기록한다.</param>
		/// <returns>삽입된 엔터티</returns>
        public virtual Company InsertIfNotExist(Company entity, bool withAudit = false)
	    {
            using var context = DbContextFactory.Create();

	        if (context.Set<Company>().Count(x =>  x.CompanyId == entity.CompanyId) > 0)
	            return null;

	        MarkToInsert(context, entity);

			if (withAudit)
                entity.WriteAuditInfo();

			context.SaveChanges();

	        return entity;
	    }

        public virtual Task<Company> InsertIfNotExistAsync(Company entity)
		=> Task.Run(() => InsertIfNotExist(entity));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 있으면 갱신하고 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입 혹은 갱신할 엔터티</param>
		/// <param name="withAudit">감사정보(수정자, 수정일)를 기록한다.</param>
		/// <returns>삽입했으면 true, 갱신했으면 false</returns>
        public virtual bool InsertOrUpdate(Company entity, bool withAudit = false)
	    {
            using var context = DbContextFactory.Create();

			if (withAudit)
                entity.WriteAuditInfo();
            
	        if (context.Set<Company>().Count(x =>  x.CompanyId == entity.CompanyId) > 0)
	        {
	            MarkToUpdate(context, entity);
	            
				context.SaveChanges();

	            return false;
            }
            else
	        {
	            MarkToInsert(context, entity);
	            
				context.SaveChanges();

	            return true;
            }
	    }

        public virtual Task<bool> InsertOrUpdateAsync(Company entity, bool withAudit = false)
		=> Task.Run(() => InsertOrUpdate(entity, withAudit));
		
		
	}
	#endregion
	#region PlaylistDao
	/// <summary>
	/// Playlist 데이터 클래스
	/// </summary>
	public partial class PlaylistDao : EntityDao<Playlist>
	{
		internal PlaylistDao() {}

		
		/// <summary>
		/// 기본키가 일치하는 엔터티를 구한다.
		/// </summary>
				/// <param name="playlistId">기본키</param>
		/// <returns>기본키가 일치하는 엔터티</returns>
        public virtual Playlist GetByKey(Int32 playlistId)
		{
            using var context = DbContextFactory.Create();

            return context.Set<Playlist>().FirstOrDefault(x =>  x.PlaylistId == playlistId);
		}

        public virtual Task<Playlist> GetByKeyAsync(Int32 playlistId)
			=> Task.Run(() => GetByKey(playlistId));

		/// <summary>
		/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
		/// </summary>
				/// <param name="playlistId">기본키</param>
		/// <returns>존재 여부</returns>
        public virtual bool ExistsByKey(Int32 playlistId)
		{
            using var context = DbContextFactory.Create();

			return context.Set<Playlist>().Count(x =>  x.PlaylistId == playlistId) > 0;
		}

        public virtual Task<bool> ExistsByKeyAsync(Int32 playlistId)
		=> Task.Run(() => ExistsByKey(playlistId));

		/// <summary>
		/// 기본키가 일치하는 엔터티를 삭제한다.
		/// </summary>
				/// <param name="playlistId">기본키</param>
		/// <returns>삭제된 엔터티의 갯수</returns>
        public virtual int DeleteByKey(Int32 playlistId)
		{
            using var context = DbContextFactory.Create();

			var query = from x in context.Set<Playlist>()
			where x.PlaylistId == playlistId
			select x;

			var entity = query.FirstOrDefault();

            if (entity == null)
                return 0;

			MarkToDelete(context, entity);

			return context.SaveChanges();
		}

        public virtual Task<int> DeleteByKeyAsync(Int32 playlistId)
		=> Task.Run(() => DeleteByKey(playlistId));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입할 엔터티</param>
		/// <param name="withAudit">감사정보(수정자, 수정일)를 기록한다.</param>
		/// <returns>삽입된 엔터티</returns>
        public virtual Playlist InsertIfNotExist(Playlist entity, bool withAudit = false)
	    {
            using var context = DbContextFactory.Create();

	        if (context.Set<Playlist>().Count(x =>  x.PlaylistId == entity.PlaylistId) > 0)
	            return null;

	        MarkToInsert(context, entity);

			if (withAudit)
                entity.WriteAuditInfo();

			context.SaveChanges();

	        return entity;
	    }

        public virtual Task<Playlist> InsertIfNotExistAsync(Playlist entity)
		=> Task.Run(() => InsertIfNotExist(entity));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 있으면 갱신하고 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입 혹은 갱신할 엔터티</param>
		/// <param name="withAudit">감사정보(수정자, 수정일)를 기록한다.</param>
		/// <returns>삽입했으면 true, 갱신했으면 false</returns>
        public virtual bool InsertOrUpdate(Playlist entity, bool withAudit = false)
	    {
            using var context = DbContextFactory.Create();

			if (withAudit)
                entity.WriteAuditInfo();
            
	        if (context.Set<Playlist>().Count(x =>  x.PlaylistId == entity.PlaylistId) > 0)
	        {
	            MarkToUpdate(context, entity);
	            
				context.SaveChanges();

	            return false;
            }
            else
	        {
	            MarkToInsert(context, entity);
	            
				context.SaveChanges();

	            return true;
            }
	    }

        public virtual Task<bool> InsertOrUpdateAsync(Playlist entity, bool withAudit = false)
		=> Task.Run(() => InsertOrUpdate(entity, withAudit));
		
		
	}
	#endregion
	#region PlaylistTrackDao
	/// <summary>
	/// PlaylistTrack 데이터 클래스
	/// </summary>
	public partial class PlaylistTrackDao : EntityDao<PlaylistTrack>
	{
		internal PlaylistTrackDao() {}

		
		/// <summary>
		/// 기본키가 일치하는 엔터티를 구한다.
		/// </summary>
				/// <param name="playlistId">기본키</param>		/// <param name="trackId">기본키</param>
		/// <returns>기본키가 일치하는 엔터티</returns>
        public virtual PlaylistTrack GetByKey(Int32 playlistId, Int32 trackId)
		{
            using var context = DbContextFactory.Create();

            return context.Set<PlaylistTrack>().FirstOrDefault(x =>  x.PlaylistId == playlistId &&  x.TrackId == trackId);
		}

        public virtual Task<PlaylistTrack> GetByKeyAsync(Int32 playlistId, Int32 trackId)
			=> Task.Run(() => GetByKey(playlistId, trackId));

		/// <summary>
		/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
		/// </summary>
				/// <param name="playlistId">기본키</param>		/// <param name="trackId">기본키</param>
		/// <returns>존재 여부</returns>
        public virtual bool ExistsByKey(Int32 playlistId, Int32 trackId)
		{
            using var context = DbContextFactory.Create();

			return context.Set<PlaylistTrack>().Count(x =>  x.PlaylistId == playlistId &&  x.TrackId == trackId) > 0;
		}

        public virtual Task<bool> ExistsByKeyAsync(Int32 playlistId, Int32 trackId)
		=> Task.Run(() => ExistsByKey(playlistId, trackId));

		/// <summary>
		/// 기본키가 일치하는 엔터티를 삭제한다.
		/// </summary>
				/// <param name="playlistId">기본키</param>		/// <param name="trackId">기본키</param>
		/// <returns>삭제된 엔터티의 갯수</returns>
        public virtual int DeleteByKey(Int32 playlistId, Int32 trackId)
		{
            using var context = DbContextFactory.Create();

			var query = from x in context.Set<PlaylistTrack>()
			where x.PlaylistId == playlistId && x.TrackId == trackId
			select x;

			var entity = query.FirstOrDefault();

            if (entity == null)
                return 0;

			MarkToDelete(context, entity);

			return context.SaveChanges();
		}

        public virtual Task<int> DeleteByKeyAsync(Int32 playlistId, Int32 trackId)
		=> Task.Run(() => DeleteByKey(playlistId, trackId));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입할 엔터티</param>
		/// <param name="withAudit">감사정보(수정자, 수정일)를 기록한다.</param>
		/// <returns>삽입된 엔터티</returns>
        public virtual PlaylistTrack InsertIfNotExist(PlaylistTrack entity, bool withAudit = false)
	    {
            using var context = DbContextFactory.Create();

	        if (context.Set<PlaylistTrack>().Count(x =>  x.PlaylistId == entity.PlaylistId &&  x.TrackId == entity.TrackId) > 0)
	            return null;

	        MarkToInsert(context, entity);

			if (withAudit)
                entity.WriteAuditInfo();

			context.SaveChanges();

	        return entity;
	    }

        public virtual Task<PlaylistTrack> InsertIfNotExistAsync(PlaylistTrack entity)
		=> Task.Run(() => InsertIfNotExist(entity));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 있으면 갱신하고 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입 혹은 갱신할 엔터티</param>
		/// <param name="withAudit">감사정보(수정자, 수정일)를 기록한다.</param>
		/// <returns>삽입했으면 true, 갱신했으면 false</returns>
        public virtual bool InsertOrUpdate(PlaylistTrack entity, bool withAudit = false)
	    {
            using var context = DbContextFactory.Create();

			if (withAudit)
                entity.WriteAuditInfo();
            
	        if (context.Set<PlaylistTrack>().Count(x =>  x.PlaylistId == entity.PlaylistId &&  x.TrackId == entity.TrackId) > 0)
	        {
	            MarkToUpdate(context, entity);
	            
				context.SaveChanges();

	            return false;
            }
            else
	        {
	            MarkToInsert(context, entity);
	            
				context.SaveChanges();

	            return true;
            }
	    }

        public virtual Task<bool> InsertOrUpdateAsync(PlaylistTrack entity, bool withAudit = false)
		=> Task.Run(() => InsertOrUpdate(entity, withAudit));
		
				/// <summary>
		/// 외래키 PlaylistId 이(가) 일치하는 엔터티 컬렉션을 구한다.
		/// </summary>
		/// <param name="playlistId">외래키</param>
		/// <returns>PlaylistId 이(가) 일치하는 엔터티 컬렉션</returns>
        public virtual List<PlaylistTrack> GetByPlaylistId(Int32 playlistId)
		{
            using var context = DbContextFactory.Create();

			return context.Set<PlaylistTrack>().Where(x => x.PlaylistId == playlistId).ToList();
		}

        public virtual Task<List<PlaylistTrack>> GetByPlaylistIdAsync(Int32 playlistId)
		=> Task.Run(() => GetByPlaylistId(playlistId));
		/// <summary>
		/// 외래키 TrackId 이(가) 일치하는 엔터티 컬렉션을 구한다.
		/// </summary>
		/// <param name="trackId">외래키</param>
		/// <returns>TrackId 이(가) 일치하는 엔터티 컬렉션</returns>
        public virtual List<PlaylistTrack> GetByTrackId(Int32 trackId)
		{
            using var context = DbContextFactory.Create();

			return context.Set<PlaylistTrack>().Where(x => x.TrackId == trackId).ToList();
		}

        public virtual Task<List<PlaylistTrack>> GetByTrackIdAsync(Int32 trackId)
		=> Task.Run(() => GetByTrackId(trackId));
	}
	#endregion
	#region PlaylistTrackHistoryDao
	/// <summary>
	/// PlaylistTrackHistory 데이터 클래스
	/// </summary>
	public partial class PlaylistTrackHistoryDao : EntityDao<PlaylistTrackHistory>
	{
		internal PlaylistTrackHistoryDao() {}

		
		/// <summary>
		/// 기본키가 일치하는 엔터티를 구한다.
		/// </summary>
				/// <param name="playlistId">기본키</param>		/// <param name="trackId">기본키</param>		/// <param name="writtenAt">기본키</param>
		/// <returns>기본키가 일치하는 엔터티</returns>
        public virtual PlaylistTrackHistory GetByKey(Int32 playlistId, Int32 trackId, DateTime writtenAt)
		{
            using var context = DbContextFactory.Create();

            return context.Set<PlaylistTrackHistory>().FirstOrDefault(x =>  x.PlaylistId == playlistId &&  x.TrackId == trackId &&  x.WrittenAt == writtenAt);
		}

        public virtual Task<PlaylistTrackHistory> GetByKeyAsync(Int32 playlistId, Int32 trackId, DateTime writtenAt)
			=> Task.Run(() => GetByKey(playlistId, trackId, writtenAt));

		/// <summary>
		/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
		/// </summary>
				/// <param name="playlistId">기본키</param>		/// <param name="trackId">기본키</param>		/// <param name="writtenAt">기본키</param>
		/// <returns>존재 여부</returns>
        public virtual bool ExistsByKey(Int32 playlistId, Int32 trackId, DateTime writtenAt)
		{
            using var context = DbContextFactory.Create();

			return context.Set<PlaylistTrackHistory>().Count(x =>  x.PlaylistId == playlistId &&  x.TrackId == trackId &&  x.WrittenAt == writtenAt) > 0;
		}

        public virtual Task<bool> ExistsByKeyAsync(Int32 playlistId, Int32 trackId, DateTime writtenAt)
		=> Task.Run(() => ExistsByKey(playlistId, trackId, writtenAt));

		/// <summary>
		/// 기본키가 일치하는 엔터티를 삭제한다.
		/// </summary>
				/// <param name="playlistId">기본키</param>		/// <param name="trackId">기본키</param>		/// <param name="writtenAt">기본키</param>
		/// <returns>삭제된 엔터티의 갯수</returns>
        public virtual int DeleteByKey(Int32 playlistId, Int32 trackId, DateTime writtenAt)
		{
            using var context = DbContextFactory.Create();

			var query = from x in context.Set<PlaylistTrackHistory>()
			where x.PlaylistId == playlistId && x.TrackId == trackId && x.WrittenAt == writtenAt
			select x;

			var entity = query.FirstOrDefault();

            if (entity == null)
                return 0;

			MarkToDelete(context, entity);

			return context.SaveChanges();
		}

        public virtual Task<int> DeleteByKeyAsync(Int32 playlistId, Int32 trackId, DateTime writtenAt)
		=> Task.Run(() => DeleteByKey(playlistId, trackId, writtenAt));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입할 엔터티</param>
		/// <param name="withAudit">감사정보(수정자, 수정일)를 기록한다.</param>
		/// <returns>삽입된 엔터티</returns>
        public virtual PlaylistTrackHistory InsertIfNotExist(PlaylistTrackHistory entity, bool withAudit = false)
	    {
            using var context = DbContextFactory.Create();

	        if (context.Set<PlaylistTrackHistory>().Count(x =>  x.PlaylistId == entity.PlaylistId &&  x.TrackId == entity.TrackId &&  x.WrittenAt == entity.WrittenAt) > 0)
	            return null;

	        MarkToInsert(context, entity);

			if (withAudit)
                entity.WriteAuditInfo();

			context.SaveChanges();

	        return entity;
	    }

        public virtual Task<PlaylistTrackHistory> InsertIfNotExistAsync(PlaylistTrackHistory entity)
		=> Task.Run(() => InsertIfNotExist(entity));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 있으면 갱신하고 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입 혹은 갱신할 엔터티</param>
		/// <param name="withAudit">감사정보(수정자, 수정일)를 기록한다.</param>
		/// <returns>삽입했으면 true, 갱신했으면 false</returns>
        public virtual bool InsertOrUpdate(PlaylistTrackHistory entity, bool withAudit = false)
	    {
            using var context = DbContextFactory.Create();

			if (withAudit)
                entity.WriteAuditInfo();
            
	        if (context.Set<PlaylistTrackHistory>().Count(x =>  x.PlaylistId == entity.PlaylistId &&  x.TrackId == entity.TrackId &&  x.WrittenAt == entity.WrittenAt) > 0)
	        {
	            MarkToUpdate(context, entity);
	            
				context.SaveChanges();

	            return false;
            }
            else
	        {
	            MarkToInsert(context, entity);
	            
				context.SaveChanges();

	            return true;
            }
	    }

        public virtual Task<bool> InsertOrUpdateAsync(PlaylistTrackHistory entity, bool withAudit = false)
		=> Task.Run(() => InsertOrUpdate(entity, withAudit));
		
				/// <summary>
		/// 외래키 PlaylistId 이(가) 일치하는 엔터티 컬렉션을 구한다.
		/// </summary>
		/// <param name="playlistId">외래키</param>
		/// <returns>PlaylistId 이(가) 일치하는 엔터티 컬렉션</returns>
        public virtual List<PlaylistTrackHistory> GetByPlaylistId(Int32 playlistId)
		{
            using var context = DbContextFactory.Create();

			return context.Set<PlaylistTrackHistory>().Where(x => x.PlaylistId == playlistId).ToList();
		}

        public virtual Task<List<PlaylistTrackHistory>> GetByPlaylistIdAsync(Int32 playlistId)
		=> Task.Run(() => GetByPlaylistId(playlistId));
		/// <summary>
		/// 외래키 TrackId 이(가) 일치하는 엔터티 컬렉션을 구한다.
		/// </summary>
		/// <param name="trackId">외래키</param>
		/// <returns>TrackId 이(가) 일치하는 엔터티 컬렉션</returns>
        public virtual List<PlaylistTrackHistory> GetByTrackId(Int32 trackId)
		{
            using var context = DbContextFactory.Create();

			return context.Set<PlaylistTrackHistory>().Where(x => x.TrackId == trackId).ToList();
		}

        public virtual Task<List<PlaylistTrackHistory>> GetByTrackIdAsync(Int32 trackId)
		=> Task.Run(() => GetByTrackId(trackId));
	}
	#endregion
	#region TrackDao
	/// <summary>
	/// Track 데이터 클래스
	/// </summary>
	public partial class TrackDao : EntityDao<Track>
	{
		internal TrackDao() {}

		
		/// <summary>
		/// 기본키가 일치하는 엔터티를 구한다.
		/// </summary>
				/// <param name="trackId">기본키</param>
		/// <returns>기본키가 일치하는 엔터티</returns>
        public virtual Track GetByKey(Int32 trackId)
		{
            using var context = DbContextFactory.Create();

            return context.Set<Track>().FirstOrDefault(x =>  x.TrackId == trackId);
		}

        public virtual Task<Track> GetByKeyAsync(Int32 trackId)
			=> Task.Run(() => GetByKey(trackId));

		/// <summary>
		/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
		/// </summary>
				/// <param name="trackId">기본키</param>
		/// <returns>존재 여부</returns>
        public virtual bool ExistsByKey(Int32 trackId)
		{
            using var context = DbContextFactory.Create();

			return context.Set<Track>().Count(x =>  x.TrackId == trackId) > 0;
		}

        public virtual Task<bool> ExistsByKeyAsync(Int32 trackId)
		=> Task.Run(() => ExistsByKey(trackId));

		/// <summary>
		/// 기본키가 일치하는 엔터티를 삭제한다.
		/// </summary>
				/// <param name="trackId">기본키</param>
		/// <returns>삭제된 엔터티의 갯수</returns>
        public virtual int DeleteByKey(Int32 trackId)
		{
            using var context = DbContextFactory.Create();

			var query = from x in context.Set<Track>()
			where x.TrackId == trackId
			select x;

			var entity = query.FirstOrDefault();

            if (entity == null)
                return 0;

			MarkToDelete(context, entity);

			return context.SaveChanges();
		}

        public virtual Task<int> DeleteByKeyAsync(Int32 trackId)
		=> Task.Run(() => DeleteByKey(trackId));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입할 엔터티</param>
		/// <param name="withAudit">감사정보(수정자, 수정일)를 기록한다.</param>
		/// <returns>삽입된 엔터티</returns>
        public virtual Track InsertIfNotExist(Track entity, bool withAudit = false)
	    {
            using var context = DbContextFactory.Create();

	        if (context.Set<Track>().Count(x =>  x.TrackId == entity.TrackId) > 0)
	            return null;

	        MarkToInsert(context, entity);

			if (withAudit)
                entity.WriteAuditInfo();

			context.SaveChanges();

	        return entity;
	    }

        public virtual Task<Track> InsertIfNotExistAsync(Track entity)
		=> Task.Run(() => InsertIfNotExist(entity));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 있으면 갱신하고 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입 혹은 갱신할 엔터티</param>
		/// <param name="withAudit">감사정보(수정자, 수정일)를 기록한다.</param>
		/// <returns>삽입했으면 true, 갱신했으면 false</returns>
        public virtual bool InsertOrUpdate(Track entity, bool withAudit = false)
	    {
            using var context = DbContextFactory.Create();

			if (withAudit)
                entity.WriteAuditInfo();
            
	        if (context.Set<Track>().Count(x =>  x.TrackId == entity.TrackId) > 0)
	        {
	            MarkToUpdate(context, entity);
	            
				context.SaveChanges();

	            return false;
            }
            else
	        {
	            MarkToInsert(context, entity);
	            
				context.SaveChanges();

	            return true;
            }
	    }

        public virtual Task<bool> InsertOrUpdateAsync(Track entity, bool withAudit = false)
		=> Task.Run(() => InsertOrUpdate(entity, withAudit));
		
				/// <summary>
		/// 외래키 AlbumId 이(가) 일치하는 엔터티 컬렉션을 구한다.
		/// </summary>
		/// <param name="albumId">외래키</param>
		/// <returns>AlbumId 이(가) 일치하는 엔터티 컬렉션</returns>
        public virtual List<Track> GetByAlbumId(Int32? albumId)
		{
            using var context = DbContextFactory.Create();

			return context.Set<Track>().Where(x => x.AlbumId == albumId).ToList();
		}

        public virtual Task<List<Track>> GetByAlbumIdAsync(Int32? albumId)
		=> Task.Run(() => GetByAlbumId(albumId));
	}
	#endregion
	#endregion

	#region Types
	/// <summary>
	/// 엔티티를 추가/수정/삭제 할 때 기록하는 로그의 종류
	/// </summary>
	internal enum LogType
	{
		/// <summary>
		/// 엔티티 삽입
		/// </summary>
		Insert,

		/// <summary>
		/// 엔티티 컬렉션 삽입
		/// </summary>
		InsertMany,

		/// <summary>
		/// 엔티티 갱신
		/// </summary>
		Update,

		/// <summary>
		/// 엔티티 컬렉션 갱신
		/// </summary>
		UpdateMany,

		/// <summary>
		/// 엔티티 삭제
		/// </summary>
		Delete,

		/// <summary>
		/// 엔티티 컬렉션 삭제
		/// </summary>
		DeleteMany
	}

    public interface IIntKeyDao<T> where T:Entity<T>, new()
    {
        T Create();

        T GetByKey(int key);

        Task<T> GetByKeyAsync(int key);

        bool ExistsByKey(int key);
        
        Task<bool> ExistsByKeyAsync(int key);

        int DeleteByKey(int key);

        Task<int> DeleteByKeyAsync(int key);

        List<T> Get();

        T Insert(T entity, bool withAudit = false);

        int Update(T entity, bool withAudit = false);
    }
	#endregion

	#region DaoBase
	/// <summary>
	/// Dao의 부모. Dao를 확장하는 용도로 사용한다.
	/// </summary>
	public partial class DaoBase
	{
	}
	#endregion

	#region Dao
	/// <summary>
	/// 각 엔터티 데이터 객체의 모음
	/// </summary>
	public partial class Dao : DaoBase
	{
		static Dao()
		{
						Album = new AlbumDao();
			Artist = new ArtistDao();
			Company = new CompanyDao();
			Playlist = new PlaylistDao();
			PlaylistTrack = new PlaylistTrackDao();
			PlaylistTrackHistory = new PlaylistTrackHistoryDao();
			Track = new TrackDao();

			#region Of
						_dictionary.Add(typeof(Chinook.Data.Album), Album);
			_dictionary.Add(typeof(Chinook.Data.Artist), Artist);
			_dictionary.Add(typeof(Chinook.Data.Company), Company);
			_dictionary.Add(typeof(Chinook.Data.Playlist), Playlist);
			_dictionary.Add(typeof(Chinook.Data.PlaylistTrack), PlaylistTrack);
			_dictionary.Add(typeof(Chinook.Data.PlaylistTrackHistory), PlaylistTrackHistory);
			_dictionary.Add(typeof(Chinook.Data.Track), Track);
			#endregion
		}

		#region Data objects
				public static AlbumDao Album { get; }
		public static ArtistDao Artist { get; }
		public static CompanyDao Company { get; }
		public static PlaylistDao Playlist { get; }
		public static PlaylistTrackDao PlaylistTrack { get; }
		public static PlaylistTrackHistoryDao PlaylistTrackHistory { get; }
		public static TrackDao Track { get; }
		#endregion

        public static IIntKeyDao<T> Of<T>() where T : Entity<T>, new()
        {
            object dao = _dictionary[typeof(T)];

            if (dao is not IIntKeyDao<T> intKeyDao)
                throw new InvalidCastException($"Could not cast to {typeof(T)}");

            return intKeyDao;
        }

        private static readonly Dictionary<Type, object> _dictionary = new();
	}
	#endregion

	#region DbContextFactory
	/// <summary>
	/// ChinookEntities객체 생성기
	/// </summary>
	public partial class DbContextFactory
	{
		/// <summary>
		/// MP에서 설정된 연결 문자열을 오버라이드 한다.
		/// </summary>
		/// <param name="connectionString"></param>
		static partial void GetConnectionStringCore(ref string connectionString);

	    /// <summary>
        /// ChinookEntities 객체가 생성되었을 때 호출된다.
        /// </summary>
        /// <param name="context">생성된 ChinookEntities 객체</param>
	    static partial void OnCreated(ChinookEntities context);

		/// <summary>
		/// 연결 문자열을 생성한다. GetConnectionStringCore 부분 메서드를 구현하지 않으면 MP에서 설정된 값을 사용한다.
		/// </summary>
		/// <returns></returns>
		public static string GetConnectionString()
		{
			string connectionString = string.Empty;

			GetConnectionStringCore(ref connectionString);

			if (string.IsNullOrEmpty(connectionString))
			return "name=ChinookEntities";
			else
			return connectionString;
		}

		/// <summary>
		/// ChinookEntities 객체를 생성한다.
		/// </summary>
		/// <returns></returns>
	    public static ChinookEntities Create(bool lazyLoadingEnabled = false, bool proxyCreationEnabled = false, bool autoDetectChangesEnabled = false)
	    {
	        string connectionString = GetConnectionString();

	        var context = new ChinookEntities(connectionString);

	        context.Configuration.LazyLoadingEnabled = lazyLoadingEnabled;
	        context.Configuration.ProxyCreationEnabled = proxyCreationEnabled;
	        context.Configuration.AutoDetectChangesEnabled = autoDetectChangesEnabled;

	        CreateCore(context);

	        return context;
	    }

	    /// <summary>
	    /// ChinookEntities 객체의 옵션을 설정한다.
	    /// </summary>
	    /// <param name="context">생성된 ChinookEntities 객체</param>
	    static partial void CreateCore(ChinookEntities context);
	}
	#endregion

	#region ChinookEntities
	public partial class ChinookEntities
	{
	    internal ChinookEntities(string nameOrConnectionString) : base(nameOrConnectionString)
	    {
	    }

	    public List<string> ValidationErrorMessages
	    {
	        get
	        {
	            return GetValidationErrors()
	            .SelectMany(x => x.ValidationErrors)
	            .Select(x => $"[{x.PropertyName}] {x.ErrorMessage}")
	            .ToList();
	        }
	    }

	    public string ValidationErrorMessage => string.Join(Environment.NewLine, ValidationErrorMessages);
	    }
	#endregion
}
